/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.meshtastic = (function() {

    /**
     * Namespace meshtastic.
     * @exports meshtastic
     * @namespace
     */
    var meshtastic = {};

    meshtastic.ServiceEnvelope = (function() {

        /**
         * Properties of a ServiceEnvelope.
         * @memberof meshtastic
         * @interface IServiceEnvelope
         * @property {meshtastic.IMeshPacket|null} [packet] ServiceEnvelope packet
         * @property {string|null} [channelId] ServiceEnvelope channelId
         * @property {string|null} [gatewayId] ServiceEnvelope gatewayId
         */

        /**
         * Constructs a new ServiceEnvelope.
         * @memberof meshtastic
         * @classdesc Represents a ServiceEnvelope.
         * @implements IServiceEnvelope
         * @constructor
         * @param {meshtastic.IServiceEnvelope=} [properties] Properties to set
         */
        function ServiceEnvelope(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceEnvelope packet.
         * @member {meshtastic.IMeshPacket|null|undefined} packet
         * @memberof meshtastic.ServiceEnvelope
         * @instance
         */
        ServiceEnvelope.prototype.packet = null;

        /**
         * ServiceEnvelope channelId.
         * @member {string} channelId
         * @memberof meshtastic.ServiceEnvelope
         * @instance
         */
        ServiceEnvelope.prototype.channelId = "";

        /**
         * ServiceEnvelope gatewayId.
         * @member {string} gatewayId
         * @memberof meshtastic.ServiceEnvelope
         * @instance
         */
        ServiceEnvelope.prototype.gatewayId = "";

        /**
         * Creates a new ServiceEnvelope instance using the specified properties.
         * @function create
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {meshtastic.IServiceEnvelope=} [properties] Properties to set
         * @returns {meshtastic.ServiceEnvelope} ServiceEnvelope instance
         */
        ServiceEnvelope.create = function create(properties) {
            return new ServiceEnvelope(properties);
        };

        /**
         * Encodes the specified ServiceEnvelope message. Does not implicitly {@link meshtastic.ServiceEnvelope.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {meshtastic.IServiceEnvelope} message ServiceEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceEnvelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.packet != null && Object.hasOwnProperty.call(message, "packet"))
                $root.meshtastic.MeshPacket.encode(message.packet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelId);
            if (message.gatewayId != null && Object.hasOwnProperty.call(message, "gatewayId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gatewayId);
            return writer;
        };

        /**
         * Encodes the specified ServiceEnvelope message, length delimited. Does not implicitly {@link meshtastic.ServiceEnvelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {meshtastic.IServiceEnvelope} message ServiceEnvelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceEnvelope message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ServiceEnvelope} ServiceEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceEnvelope.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ServiceEnvelope();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.packet = $root.meshtastic.MeshPacket.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.channelId = reader.string();
                        break;
                    }
                case 3: {
                        message.gatewayId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceEnvelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ServiceEnvelope} ServiceEnvelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceEnvelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceEnvelope message.
         * @function verify
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceEnvelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.packet != null && message.hasOwnProperty("packet")) {
                var error = $root.meshtastic.MeshPacket.verify(message.packet);
                if (error)
                    return "packet." + error;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            if (message.gatewayId != null && message.hasOwnProperty("gatewayId"))
                if (!$util.isString(message.gatewayId))
                    return "gatewayId: string expected";
            return null;
        };

        /**
         * Creates a ServiceEnvelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ServiceEnvelope} ServiceEnvelope
         */
        ServiceEnvelope.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ServiceEnvelope)
                return object;
            var message = new $root.meshtastic.ServiceEnvelope();
            if (object.packet != null) {
                if (typeof object.packet !== "object")
                    throw TypeError(".meshtastic.ServiceEnvelope.packet: object expected");
                message.packet = $root.meshtastic.MeshPacket.fromObject(object.packet);
            }
            if (object.channelId != null)
                message.channelId = String(object.channelId);
            if (object.gatewayId != null)
                message.gatewayId = String(object.gatewayId);
            return message;
        };

        /**
         * Creates a plain object from a ServiceEnvelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {meshtastic.ServiceEnvelope} message ServiceEnvelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceEnvelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.packet = null;
                object.channelId = "";
                object.gatewayId = "";
            }
            if (message.packet != null && message.hasOwnProperty("packet"))
                object.packet = $root.meshtastic.MeshPacket.toObject(message.packet, options);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = message.channelId;
            if (message.gatewayId != null && message.hasOwnProperty("gatewayId"))
                object.gatewayId = message.gatewayId;
            return object;
        };

        /**
         * Converts this ServiceEnvelope to JSON.
         * @function toJSON
         * @memberof meshtastic.ServiceEnvelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceEnvelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServiceEnvelope
         * @function getTypeUrl
         * @memberof meshtastic.ServiceEnvelope
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServiceEnvelope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ServiceEnvelope";
        };

        return ServiceEnvelope;
    })();

    meshtastic.MapReport = (function() {

        /**
         * Properties of a MapReport.
         * @memberof meshtastic
         * @interface IMapReport
         * @property {string|null} [longName] MapReport longName
         * @property {string|null} [shortName] MapReport shortName
         * @property {meshtastic.Config.DeviceConfig.Role|null} [role] MapReport role
         * @property {meshtastic.HardwareModel|null} [hwModel] MapReport hwModel
         * @property {string|null} [firmwareVersion] MapReport firmwareVersion
         * @property {meshtastic.Config.LoRaConfig.RegionCode|null} [region] MapReport region
         * @property {meshtastic.Config.LoRaConfig.ModemPreset|null} [modemPreset] MapReport modemPreset
         * @property {boolean|null} [hasDefaultChannel] MapReport hasDefaultChannel
         * @property {number|null} [latitudeI] MapReport latitudeI
         * @property {number|null} [longitudeI] MapReport longitudeI
         * @property {number|null} [altitude] MapReport altitude
         * @property {number|null} [positionPrecision] MapReport positionPrecision
         * @property {number|null} [numOnlineLocalNodes] MapReport numOnlineLocalNodes
         * @property {boolean|null} [hasOptedReportLocation] MapReport hasOptedReportLocation
         */

        /**
         * Constructs a new MapReport.
         * @memberof meshtastic
         * @classdesc Represents a MapReport.
         * @implements IMapReport
         * @constructor
         * @param {meshtastic.IMapReport=} [properties] Properties to set
         */
        function MapReport(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapReport longName.
         * @member {string} longName
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.longName = "";

        /**
         * MapReport shortName.
         * @member {string} shortName
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.shortName = "";

        /**
         * MapReport role.
         * @member {meshtastic.Config.DeviceConfig.Role} role
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.role = 0;

        /**
         * MapReport hwModel.
         * @member {meshtastic.HardwareModel} hwModel
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.hwModel = 0;

        /**
         * MapReport firmwareVersion.
         * @member {string} firmwareVersion
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.firmwareVersion = "";

        /**
         * MapReport region.
         * @member {meshtastic.Config.LoRaConfig.RegionCode} region
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.region = 0;

        /**
         * MapReport modemPreset.
         * @member {meshtastic.Config.LoRaConfig.ModemPreset} modemPreset
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.modemPreset = 0;

        /**
         * MapReport hasDefaultChannel.
         * @member {boolean} hasDefaultChannel
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.hasDefaultChannel = false;

        /**
         * MapReport latitudeI.
         * @member {number} latitudeI
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.latitudeI = 0;

        /**
         * MapReport longitudeI.
         * @member {number} longitudeI
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.longitudeI = 0;

        /**
         * MapReport altitude.
         * @member {number} altitude
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.altitude = 0;

        /**
         * MapReport positionPrecision.
         * @member {number} positionPrecision
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.positionPrecision = 0;

        /**
         * MapReport numOnlineLocalNodes.
         * @member {number} numOnlineLocalNodes
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.numOnlineLocalNodes = 0;

        /**
         * MapReport hasOptedReportLocation.
         * @member {boolean} hasOptedReportLocation
         * @memberof meshtastic.MapReport
         * @instance
         */
        MapReport.prototype.hasOptedReportLocation = false;

        /**
         * Creates a new MapReport instance using the specified properties.
         * @function create
         * @memberof meshtastic.MapReport
         * @static
         * @param {meshtastic.IMapReport=} [properties] Properties to set
         * @returns {meshtastic.MapReport} MapReport instance
         */
        MapReport.create = function create(properties) {
            return new MapReport(properties);
        };

        /**
         * Encodes the specified MapReport message. Does not implicitly {@link meshtastic.MapReport.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.MapReport
         * @static
         * @param {meshtastic.IMapReport} message MapReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.longName != null && Object.hasOwnProperty.call(message, "longName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.longName);
            if (message.shortName != null && Object.hasOwnProperty.call(message, "shortName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.shortName);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.role);
            if (message.hwModel != null && Object.hasOwnProperty.call(message, "hwModel"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hwModel);
            if (message.firmwareVersion != null && Object.hasOwnProperty.call(message, "firmwareVersion"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.firmwareVersion);
            if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.region);
            if (message.modemPreset != null && Object.hasOwnProperty.call(message, "modemPreset"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.modemPreset);
            if (message.hasDefaultChannel != null && Object.hasOwnProperty.call(message, "hasDefaultChannel"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasDefaultChannel);
            if (message.latitudeI != null && Object.hasOwnProperty.call(message, "latitudeI"))
                writer.uint32(/* id 9, wireType 5 =*/77).sfixed32(message.latitudeI);
            if (message.longitudeI != null && Object.hasOwnProperty.call(message, "longitudeI"))
                writer.uint32(/* id 10, wireType 5 =*/85).sfixed32(message.longitudeI);
            if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.altitude);
            if (message.positionPrecision != null && Object.hasOwnProperty.call(message, "positionPrecision"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.positionPrecision);
            if (message.numOnlineLocalNodes != null && Object.hasOwnProperty.call(message, "numOnlineLocalNodes"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.numOnlineLocalNodes);
            if (message.hasOptedReportLocation != null && Object.hasOwnProperty.call(message, "hasOptedReportLocation"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.hasOptedReportLocation);
            return writer;
        };

        /**
         * Encodes the specified MapReport message, length delimited. Does not implicitly {@link meshtastic.MapReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.MapReport
         * @static
         * @param {meshtastic.IMapReport} message MapReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapReport message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.MapReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.MapReport} MapReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReport.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.MapReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.longName = reader.string();
                        break;
                    }
                case 2: {
                        message.shortName = reader.string();
                        break;
                    }
                case 3: {
                        message.role = reader.int32();
                        break;
                    }
                case 4: {
                        message.hwModel = reader.int32();
                        break;
                    }
                case 5: {
                        message.firmwareVersion = reader.string();
                        break;
                    }
                case 6: {
                        message.region = reader.int32();
                        break;
                    }
                case 7: {
                        message.modemPreset = reader.int32();
                        break;
                    }
                case 8: {
                        message.hasDefaultChannel = reader.bool();
                        break;
                    }
                case 9: {
                        message.latitudeI = reader.sfixed32();
                        break;
                    }
                case 10: {
                        message.longitudeI = reader.sfixed32();
                        break;
                    }
                case 11: {
                        message.altitude = reader.int32();
                        break;
                    }
                case 12: {
                        message.positionPrecision = reader.uint32();
                        break;
                    }
                case 13: {
                        message.numOnlineLocalNodes = reader.uint32();
                        break;
                    }
                case 14: {
                        message.hasOptedReportLocation = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.MapReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.MapReport} MapReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapReport message.
         * @function verify
         * @memberof meshtastic.MapReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.longName != null && message.hasOwnProperty("longName"))
                if (!$util.isString(message.longName))
                    return "longName: string expected";
            if (message.shortName != null && message.hasOwnProperty("shortName"))
                if (!$util.isString(message.shortName))
                    return "shortName: string expected";
            if (message.role != null && message.hasOwnProperty("role"))
                switch (message.role) {
                default:
                    return "role: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                switch (message.hwModel) {
                default:
                    return "hwModel: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 255:
                    break;
                }
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                if (!$util.isString(message.firmwareVersion))
                    return "firmwareVersion: string expected";
            if (message.region != null && message.hasOwnProperty("region"))
                switch (message.region) {
                default:
                    return "region: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                    break;
                }
            if (message.modemPreset != null && message.hasOwnProperty("modemPreset"))
                switch (message.modemPreset) {
                default:
                    return "modemPreset: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.hasDefaultChannel != null && message.hasOwnProperty("hasDefaultChannel"))
                if (typeof message.hasDefaultChannel !== "boolean")
                    return "hasDefaultChannel: boolean expected";
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI"))
                if (!$util.isInteger(message.latitudeI))
                    return "latitudeI: integer expected";
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI"))
                if (!$util.isInteger(message.longitudeI))
                    return "longitudeI: integer expected";
            if (message.altitude != null && message.hasOwnProperty("altitude"))
                if (!$util.isInteger(message.altitude))
                    return "altitude: integer expected";
            if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                if (!$util.isInteger(message.positionPrecision))
                    return "positionPrecision: integer expected";
            if (message.numOnlineLocalNodes != null && message.hasOwnProperty("numOnlineLocalNodes"))
                if (!$util.isInteger(message.numOnlineLocalNodes))
                    return "numOnlineLocalNodes: integer expected";
            if (message.hasOptedReportLocation != null && message.hasOwnProperty("hasOptedReportLocation"))
                if (typeof message.hasOptedReportLocation !== "boolean")
                    return "hasOptedReportLocation: boolean expected";
            return null;
        };

        /**
         * Creates a MapReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.MapReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.MapReport} MapReport
         */
        MapReport.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.MapReport)
                return object;
            var message = new $root.meshtastic.MapReport();
            if (object.longName != null)
                message.longName = String(object.longName);
            if (object.shortName != null)
                message.shortName = String(object.shortName);
            switch (object.role) {
            default:
                if (typeof object.role === "number") {
                    message.role = object.role;
                    break;
                }
                break;
            case "CLIENT":
            case 0:
                message.role = 0;
                break;
            case "CLIENT_MUTE":
            case 1:
                message.role = 1;
                break;
            case "ROUTER":
            case 2:
                message.role = 2;
                break;
            case "ROUTER_CLIENT":
            case 3:
                message.role = 3;
                break;
            case "REPEATER":
            case 4:
                message.role = 4;
                break;
            case "TRACKER":
            case 5:
                message.role = 5;
                break;
            case "SENSOR":
            case 6:
                message.role = 6;
                break;
            case "TAK":
            case 7:
                message.role = 7;
                break;
            case "CLIENT_HIDDEN":
            case 8:
                message.role = 8;
                break;
            case "LOST_AND_FOUND":
            case 9:
                message.role = 9;
                break;
            case "TAK_TRACKER":
            case 10:
                message.role = 10;
                break;
            case "ROUTER_LATE":
            case 11:
                message.role = 11;
                break;
            case "CLIENT_BASE":
            case 12:
                message.role = 12;
                break;
            }
            switch (object.hwModel) {
            default:
                if (typeof object.hwModel === "number") {
                    message.hwModel = object.hwModel;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.hwModel = 0;
                break;
            case "TLORA_V2":
            case 1:
                message.hwModel = 1;
                break;
            case "TLORA_V1":
            case 2:
                message.hwModel = 2;
                break;
            case "TLORA_V2_1_1P6":
            case 3:
                message.hwModel = 3;
                break;
            case "TBEAM":
            case 4:
                message.hwModel = 4;
                break;
            case "HELTEC_V2_0":
            case 5:
                message.hwModel = 5;
                break;
            case "TBEAM_V0P7":
            case 6:
                message.hwModel = 6;
                break;
            case "T_ECHO":
            case 7:
                message.hwModel = 7;
                break;
            case "TLORA_V1_1P3":
            case 8:
                message.hwModel = 8;
                break;
            case "RAK4631":
            case 9:
                message.hwModel = 9;
                break;
            case "HELTEC_V2_1":
            case 10:
                message.hwModel = 10;
                break;
            case "HELTEC_V1":
            case 11:
                message.hwModel = 11;
                break;
            case "LILYGO_TBEAM_S3_CORE":
            case 12:
                message.hwModel = 12;
                break;
            case "RAK11200":
            case 13:
                message.hwModel = 13;
                break;
            case "NANO_G1":
            case 14:
                message.hwModel = 14;
                break;
            case "TLORA_V2_1_1P8":
            case 15:
                message.hwModel = 15;
                break;
            case "TLORA_T3_S3":
            case 16:
                message.hwModel = 16;
                break;
            case "NANO_G1_EXPLORER":
            case 17:
                message.hwModel = 17;
                break;
            case "NANO_G2_ULTRA":
            case 18:
                message.hwModel = 18;
                break;
            case "LORA_TYPE":
            case 19:
                message.hwModel = 19;
                break;
            case "WIPHONE":
            case 20:
                message.hwModel = 20;
                break;
            case "WIO_WM1110":
            case 21:
                message.hwModel = 21;
                break;
            case "RAK2560":
            case 22:
                message.hwModel = 22;
                break;
            case "HELTEC_HRU_3601":
            case 23:
                message.hwModel = 23;
                break;
            case "HELTEC_WIRELESS_BRIDGE":
            case 24:
                message.hwModel = 24;
                break;
            case "STATION_G1":
            case 25:
                message.hwModel = 25;
                break;
            case "RAK11310":
            case 26:
                message.hwModel = 26;
                break;
            case "SENSELORA_RP2040":
            case 27:
                message.hwModel = 27;
                break;
            case "SENSELORA_S3":
            case 28:
                message.hwModel = 28;
                break;
            case "CANARYONE":
            case 29:
                message.hwModel = 29;
                break;
            case "RP2040_LORA":
            case 30:
                message.hwModel = 30;
                break;
            case "STATION_G2":
            case 31:
                message.hwModel = 31;
                break;
            case "LORA_RELAY_V1":
            case 32:
                message.hwModel = 32;
                break;
            case "NRF52840DK":
            case 33:
                message.hwModel = 33;
                break;
            case "PPR":
            case 34:
                message.hwModel = 34;
                break;
            case "GENIEBLOCKS":
            case 35:
                message.hwModel = 35;
                break;
            case "NRF52_UNKNOWN":
            case 36:
                message.hwModel = 36;
                break;
            case "PORTDUINO":
            case 37:
                message.hwModel = 37;
                break;
            case "ANDROID_SIM":
            case 38:
                message.hwModel = 38;
                break;
            case "DIY_V1":
            case 39:
                message.hwModel = 39;
                break;
            case "NRF52840_PCA10059":
            case 40:
                message.hwModel = 40;
                break;
            case "DR_DEV":
            case 41:
                message.hwModel = 41;
                break;
            case "M5STACK":
            case 42:
                message.hwModel = 42;
                break;
            case "HELTEC_V3":
            case 43:
                message.hwModel = 43;
                break;
            case "HELTEC_WSL_V3":
            case 44:
                message.hwModel = 44;
                break;
            case "BETAFPV_2400_TX":
            case 45:
                message.hwModel = 45;
                break;
            case "BETAFPV_900_NANO_TX":
            case 46:
                message.hwModel = 46;
                break;
            case "RPI_PICO":
            case 47:
                message.hwModel = 47;
                break;
            case "HELTEC_WIRELESS_TRACKER":
            case 48:
                message.hwModel = 48;
                break;
            case "HELTEC_WIRELESS_PAPER":
            case 49:
                message.hwModel = 49;
                break;
            case "T_DECK":
            case 50:
                message.hwModel = 50;
                break;
            case "T_WATCH_S3":
            case 51:
                message.hwModel = 51;
                break;
            case "PICOMPUTER_S3":
            case 52:
                message.hwModel = 52;
                break;
            case "HELTEC_HT62":
            case 53:
                message.hwModel = 53;
                break;
            case "EBYTE_ESP32_S3":
            case 54:
                message.hwModel = 54;
                break;
            case "ESP32_S3_PICO":
            case 55:
                message.hwModel = 55;
                break;
            case "CHATTER_2":
            case 56:
                message.hwModel = 56;
                break;
            case "HELTEC_WIRELESS_PAPER_V1_0":
            case 57:
                message.hwModel = 57;
                break;
            case "HELTEC_WIRELESS_TRACKER_V1_0":
            case 58:
                message.hwModel = 58;
                break;
            case "UNPHONE":
            case 59:
                message.hwModel = 59;
                break;
            case "TD_LORAC":
            case 60:
                message.hwModel = 60;
                break;
            case "CDEBYTE_EORA_S3":
            case 61:
                message.hwModel = 61;
                break;
            case "TWC_MESH_V4":
            case 62:
                message.hwModel = 62;
                break;
            case "NRF52_PROMICRO_DIY":
            case 63:
                message.hwModel = 63;
                break;
            case "RADIOMASTER_900_BANDIT_NANO":
            case 64:
                message.hwModel = 64;
                break;
            case "HELTEC_CAPSULE_SENSOR_V3":
            case 65:
                message.hwModel = 65;
                break;
            case "HELTEC_VISION_MASTER_T190":
            case 66:
                message.hwModel = 66;
                break;
            case "HELTEC_VISION_MASTER_E213":
            case 67:
                message.hwModel = 67;
                break;
            case "HELTEC_VISION_MASTER_E290":
            case 68:
                message.hwModel = 68;
                break;
            case "HELTEC_MESH_NODE_T114":
            case 69:
                message.hwModel = 69;
                break;
            case "SENSECAP_INDICATOR":
            case 70:
                message.hwModel = 70;
                break;
            case "TRACKER_T1000_E":
            case 71:
                message.hwModel = 71;
                break;
            case "RAK3172":
            case 72:
                message.hwModel = 72;
                break;
            case "WIO_E5":
            case 73:
                message.hwModel = 73;
                break;
            case "RADIOMASTER_900_BANDIT":
            case 74:
                message.hwModel = 74;
                break;
            case "ME25LS01_4Y10TD":
            case 75:
                message.hwModel = 75;
                break;
            case "RP2040_FEATHER_RFM95":
            case 76:
                message.hwModel = 76;
                break;
            case "M5STACK_COREBASIC":
            case 77:
                message.hwModel = 77;
                break;
            case "M5STACK_CORE2":
            case 78:
                message.hwModel = 78;
                break;
            case "RPI_PICO2":
            case 79:
                message.hwModel = 79;
                break;
            case "M5STACK_CORES3":
            case 80:
                message.hwModel = 80;
                break;
            case "SEEED_XIAO_S3":
            case 81:
                message.hwModel = 81;
                break;
            case "MS24SF1":
            case 82:
                message.hwModel = 82;
                break;
            case "TLORA_C6":
            case 83:
                message.hwModel = 83;
                break;
            case "WISMESH_TAP":
            case 84:
                message.hwModel = 84;
                break;
            case "ROUTASTIC":
            case 85:
                message.hwModel = 85;
                break;
            case "MESH_TAB":
            case 86:
                message.hwModel = 86;
                break;
            case "MESHLINK":
            case 87:
                message.hwModel = 87;
                break;
            case "XIAO_NRF52_KIT":
            case 88:
                message.hwModel = 88;
                break;
            case "THINKNODE_M1":
            case 89:
                message.hwModel = 89;
                break;
            case "THINKNODE_M2":
            case 90:
                message.hwModel = 90;
                break;
            case "T_ETH_ELITE":
            case 91:
                message.hwModel = 91;
                break;
            case "HELTEC_SENSOR_HUB":
            case 92:
                message.hwModel = 92;
                break;
            case "RESERVED_FRIED_CHICKEN":
            case 93:
                message.hwModel = 93;
                break;
            case "HELTEC_MESH_POCKET":
            case 94:
                message.hwModel = 94;
                break;
            case "SEEED_SOLAR_NODE":
            case 95:
                message.hwModel = 95;
                break;
            case "NOMADSTAR_METEOR_PRO":
            case 96:
                message.hwModel = 96;
                break;
            case "CROWPANEL":
            case 97:
                message.hwModel = 97;
                break;
            case "LINK_32":
            case 98:
                message.hwModel = 98;
                break;
            case "SEEED_WIO_TRACKER_L1":
            case 99:
                message.hwModel = 99;
                break;
            case "SEEED_WIO_TRACKER_L1_EINK":
            case 100:
                message.hwModel = 100;
                break;
            case "MUZI_R1_NEO":
            case 101:
                message.hwModel = 101;
                break;
            case "T_DECK_PRO":
            case 102:
                message.hwModel = 102;
                break;
            case "T_LORA_PAGER":
            case 103:
                message.hwModel = 103;
                break;
            case "M5STACK_RESERVED":
            case 104:
                message.hwModel = 104;
                break;
            case "WISMESH_TAG":
            case 105:
                message.hwModel = 105;
                break;
            case "RAK3312":
            case 106:
                message.hwModel = 106;
                break;
            case "THINKNODE_M5":
            case 107:
                message.hwModel = 107;
                break;
            case "HELTEC_MESH_SOLAR":
            case 108:
                message.hwModel = 108;
                break;
            case "T_ECHO_LITE":
            case 109:
                message.hwModel = 109;
                break;
            case "HELTEC_V4":
            case 110:
                message.hwModel = 110;
                break;
            case "M5STACK_C6L":
            case 111:
                message.hwModel = 111;
                break;
            case "M5STACK_CARDPUTER_ADV":
            case 112:
                message.hwModel = 112;
                break;
            case "HELTEC_WIRELESS_TRACKER_V2":
            case 113:
                message.hwModel = 113;
                break;
            case "T_WATCH_ULTRA":
            case 114:
                message.hwModel = 114;
                break;
            case "THINKNODE_M3":
            case 115:
                message.hwModel = 115;
                break;
            case "WISMESH_TAP_V2":
            case 116:
                message.hwModel = 116;
                break;
            case "RAK3401":
            case 117:
                message.hwModel = 117;
                break;
            case "RAK6421":
            case 118:
                message.hwModel = 118;
                break;
            case "THINKNODE_M4":
            case 119:
                message.hwModel = 119;
                break;
            case "THINKNODE_M6":
            case 120:
                message.hwModel = 120;
                break;
            case "PRIVATE_HW":
            case 255:
                message.hwModel = 255;
                break;
            }
            if (object.firmwareVersion != null)
                message.firmwareVersion = String(object.firmwareVersion);
            switch (object.region) {
            default:
                if (typeof object.region === "number") {
                    message.region = object.region;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.region = 0;
                break;
            case "US":
            case 1:
                message.region = 1;
                break;
            case "EU_433":
            case 2:
                message.region = 2;
                break;
            case "EU_868":
            case 3:
                message.region = 3;
                break;
            case "CN":
            case 4:
                message.region = 4;
                break;
            case "JP":
            case 5:
                message.region = 5;
                break;
            case "ANZ":
            case 6:
                message.region = 6;
                break;
            case "KR":
            case 7:
                message.region = 7;
                break;
            case "TW":
            case 8:
                message.region = 8;
                break;
            case "RU":
            case 9:
                message.region = 9;
                break;
            case "IN":
            case 10:
                message.region = 10;
                break;
            case "NZ_865":
            case 11:
                message.region = 11;
                break;
            case "TH":
            case 12:
                message.region = 12;
                break;
            case "LORA_24":
            case 13:
                message.region = 13;
                break;
            case "UA_433":
            case 14:
                message.region = 14;
                break;
            case "UA_868":
            case 15:
                message.region = 15;
                break;
            case "MY_433":
            case 16:
                message.region = 16;
                break;
            case "MY_919":
            case 17:
                message.region = 17;
                break;
            case "SG_923":
            case 18:
                message.region = 18;
                break;
            case "PH_433":
            case 19:
                message.region = 19;
                break;
            case "PH_868":
            case 20:
                message.region = 20;
                break;
            case "PH_915":
            case 21:
                message.region = 21;
                break;
            case "ANZ_433":
            case 22:
                message.region = 22;
                break;
            case "KZ_433":
            case 23:
                message.region = 23;
                break;
            case "KZ_863":
            case 24:
                message.region = 24;
                break;
            case "NP_865":
            case 25:
                message.region = 25;
                break;
            case "BR_902":
            case 26:
                message.region = 26;
                break;
            }
            switch (object.modemPreset) {
            default:
                if (typeof object.modemPreset === "number") {
                    message.modemPreset = object.modemPreset;
                    break;
                }
                break;
            case "LONG_FAST":
            case 0:
                message.modemPreset = 0;
                break;
            case "LONG_SLOW":
            case 1:
                message.modemPreset = 1;
                break;
            case "VERY_LONG_SLOW":
            case 2:
                message.modemPreset = 2;
                break;
            case "MEDIUM_SLOW":
            case 3:
                message.modemPreset = 3;
                break;
            case "MEDIUM_FAST":
            case 4:
                message.modemPreset = 4;
                break;
            case "SHORT_SLOW":
            case 5:
                message.modemPreset = 5;
                break;
            case "SHORT_FAST":
            case 6:
                message.modemPreset = 6;
                break;
            case "LONG_MODERATE":
            case 7:
                message.modemPreset = 7;
                break;
            case "SHORT_TURBO":
            case 8:
                message.modemPreset = 8;
                break;
            }
            if (object.hasDefaultChannel != null)
                message.hasDefaultChannel = Boolean(object.hasDefaultChannel);
            if (object.latitudeI != null)
                message.latitudeI = object.latitudeI | 0;
            if (object.longitudeI != null)
                message.longitudeI = object.longitudeI | 0;
            if (object.altitude != null)
                message.altitude = object.altitude | 0;
            if (object.positionPrecision != null)
                message.positionPrecision = object.positionPrecision >>> 0;
            if (object.numOnlineLocalNodes != null)
                message.numOnlineLocalNodes = object.numOnlineLocalNodes >>> 0;
            if (object.hasOptedReportLocation != null)
                message.hasOptedReportLocation = Boolean(object.hasOptedReportLocation);
            return message;
        };

        /**
         * Creates a plain object from a MapReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.MapReport
         * @static
         * @param {meshtastic.MapReport} message MapReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.longName = "";
                object.shortName = "";
                object.role = options.enums === String ? "CLIENT" : 0;
                object.hwModel = options.enums === String ? "UNSET" : 0;
                object.firmwareVersion = "";
                object.region = options.enums === String ? "UNSET" : 0;
                object.modemPreset = options.enums === String ? "LONG_FAST" : 0;
                object.hasDefaultChannel = false;
                object.latitudeI = 0;
                object.longitudeI = 0;
                object.altitude = 0;
                object.positionPrecision = 0;
                object.numOnlineLocalNodes = 0;
                object.hasOptedReportLocation = false;
            }
            if (message.longName != null && message.hasOwnProperty("longName"))
                object.longName = message.longName;
            if (message.shortName != null && message.hasOwnProperty("shortName"))
                object.shortName = message.shortName;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = options.enums === String ? $root.meshtastic.Config.DeviceConfig.Role[message.role] === undefined ? message.role : $root.meshtastic.Config.DeviceConfig.Role[message.role] : message.role;
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                object.hwModel = options.enums === String ? $root.meshtastic.HardwareModel[message.hwModel] === undefined ? message.hwModel : $root.meshtastic.HardwareModel[message.hwModel] : message.hwModel;
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                object.firmwareVersion = message.firmwareVersion;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = options.enums === String ? $root.meshtastic.Config.LoRaConfig.RegionCode[message.region] === undefined ? message.region : $root.meshtastic.Config.LoRaConfig.RegionCode[message.region] : message.region;
            if (message.modemPreset != null && message.hasOwnProperty("modemPreset"))
                object.modemPreset = options.enums === String ? $root.meshtastic.Config.LoRaConfig.ModemPreset[message.modemPreset] === undefined ? message.modemPreset : $root.meshtastic.Config.LoRaConfig.ModemPreset[message.modemPreset] : message.modemPreset;
            if (message.hasDefaultChannel != null && message.hasOwnProperty("hasDefaultChannel"))
                object.hasDefaultChannel = message.hasDefaultChannel;
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI"))
                object.latitudeI = message.latitudeI;
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI"))
                object.longitudeI = message.longitudeI;
            if (message.altitude != null && message.hasOwnProperty("altitude"))
                object.altitude = message.altitude;
            if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                object.positionPrecision = message.positionPrecision;
            if (message.numOnlineLocalNodes != null && message.hasOwnProperty("numOnlineLocalNodes"))
                object.numOnlineLocalNodes = message.numOnlineLocalNodes;
            if (message.hasOptedReportLocation != null && message.hasOwnProperty("hasOptedReportLocation"))
                object.hasOptedReportLocation = message.hasOptedReportLocation;
            return object;
        };

        /**
         * Converts this MapReport to JSON.
         * @function toJSON
         * @memberof meshtastic.MapReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MapReport
         * @function getTypeUrl
         * @memberof meshtastic.MapReport
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MapReport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.MapReport";
        };

        return MapReport;
    })();

    meshtastic.Config = (function() {

        /**
         * Properties of a Config.
         * @memberof meshtastic
         * @interface IConfig
         * @property {meshtastic.Config.IDeviceConfig|null} [device] Config device
         * @property {meshtastic.Config.IPositionConfig|null} [position] Config position
         * @property {meshtastic.Config.IPowerConfig|null} [power] Config power
         * @property {meshtastic.Config.INetworkConfig|null} [network] Config network
         * @property {meshtastic.Config.IDisplayConfig|null} [display] Config display
         * @property {meshtastic.Config.ILoRaConfig|null} [lora] Config lora
         * @property {meshtastic.Config.IBluetoothConfig|null} [bluetooth] Config bluetooth
         * @property {meshtastic.Config.ISecurityConfig|null} [security] Config security
         * @property {meshtastic.Config.ISessionkeyConfig|null} [sessionkey] Config sessionkey
         * @property {meshtastic.IDeviceUIConfig|null} [deviceUi] Config deviceUi
         */

        /**
         * Constructs a new Config.
         * @memberof meshtastic
         * @classdesc Represents a Config.
         * @implements IConfig
         * @constructor
         * @param {meshtastic.IConfig=} [properties] Properties to set
         */
        function Config(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Config device.
         * @member {meshtastic.Config.IDeviceConfig|null|undefined} device
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.device = null;

        /**
         * Config position.
         * @member {meshtastic.Config.IPositionConfig|null|undefined} position
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.position = null;

        /**
         * Config power.
         * @member {meshtastic.Config.IPowerConfig|null|undefined} power
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.power = null;

        /**
         * Config network.
         * @member {meshtastic.Config.INetworkConfig|null|undefined} network
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.network = null;

        /**
         * Config display.
         * @member {meshtastic.Config.IDisplayConfig|null|undefined} display
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.display = null;

        /**
         * Config lora.
         * @member {meshtastic.Config.ILoRaConfig|null|undefined} lora
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.lora = null;

        /**
         * Config bluetooth.
         * @member {meshtastic.Config.IBluetoothConfig|null|undefined} bluetooth
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.bluetooth = null;

        /**
         * Config security.
         * @member {meshtastic.Config.ISecurityConfig|null|undefined} security
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.security = null;

        /**
         * Config sessionkey.
         * @member {meshtastic.Config.ISessionkeyConfig|null|undefined} sessionkey
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.sessionkey = null;

        /**
         * Config deviceUi.
         * @member {meshtastic.IDeviceUIConfig|null|undefined} deviceUi
         * @memberof meshtastic.Config
         * @instance
         */
        Config.prototype.deviceUi = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Config payloadVariant.
         * @member {"device"|"position"|"power"|"network"|"display"|"lora"|"bluetooth"|"security"|"sessionkey"|"deviceUi"|undefined} payloadVariant
         * @memberof meshtastic.Config
         * @instance
         */
        Object.defineProperty(Config.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["device", "position", "power", "network", "display", "lora", "bluetooth", "security", "sessionkey", "deviceUi"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Config instance using the specified properties.
         * @function create
         * @memberof meshtastic.Config
         * @static
         * @param {meshtastic.IConfig=} [properties] Properties to set
         * @returns {meshtastic.Config} Config instance
         */
        Config.create = function create(properties) {
            return new Config(properties);
        };

        /**
         * Encodes the specified Config message. Does not implicitly {@link meshtastic.Config.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Config
         * @static
         * @param {meshtastic.IConfig} message Config message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Config.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                $root.meshtastic.Config.DeviceConfig.encode(message.device, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.meshtastic.Config.PositionConfig.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                $root.meshtastic.Config.PowerConfig.encode(message.power, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                $root.meshtastic.Config.NetworkConfig.encode(message.network, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.display != null && Object.hasOwnProperty.call(message, "display"))
                $root.meshtastic.Config.DisplayConfig.encode(message.display, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.lora != null && Object.hasOwnProperty.call(message, "lora"))
                $root.meshtastic.Config.LoRaConfig.encode(message.lora, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.bluetooth != null && Object.hasOwnProperty.call(message, "bluetooth"))
                $root.meshtastic.Config.BluetoothConfig.encode(message.bluetooth, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.security != null && Object.hasOwnProperty.call(message, "security"))
                $root.meshtastic.Config.SecurityConfig.encode(message.security, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.sessionkey != null && Object.hasOwnProperty.call(message, "sessionkey"))
                $root.meshtastic.Config.SessionkeyConfig.encode(message.sessionkey, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.deviceUi != null && Object.hasOwnProperty.call(message, "deviceUi"))
                $root.meshtastic.DeviceUIConfig.encode(message.deviceUi, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Config message, length delimited. Does not implicitly {@link meshtastic.Config.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Config
         * @static
         * @param {meshtastic.IConfig} message Config message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Config.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Config message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Config
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Config} Config
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Config.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.device = $root.meshtastic.Config.DeviceConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.position = $root.meshtastic.Config.PositionConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.power = $root.meshtastic.Config.PowerConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.network = $root.meshtastic.Config.NetworkConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.display = $root.meshtastic.Config.DisplayConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.lora = $root.meshtastic.Config.LoRaConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.bluetooth = $root.meshtastic.Config.BluetoothConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.security = $root.meshtastic.Config.SecurityConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.sessionkey = $root.meshtastic.Config.SessionkeyConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.deviceUi = $root.meshtastic.DeviceUIConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Config message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Config
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Config} Config
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Config.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Config message.
         * @function verify
         * @memberof meshtastic.Config
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Config.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.device != null && message.hasOwnProperty("device")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.DeviceConfig.verify(message.device);
                    if (error)
                        return "device." + error;
                }
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.PositionConfig.verify(message.position);
                    if (error)
                        return "position." + error;
                }
            }
            if (message.power != null && message.hasOwnProperty("power")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.PowerConfig.verify(message.power);
                    if (error)
                        return "power." + error;
                }
            }
            if (message.network != null && message.hasOwnProperty("network")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.NetworkConfig.verify(message.network);
                    if (error)
                        return "network." + error;
                }
            }
            if (message.display != null && message.hasOwnProperty("display")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.DisplayConfig.verify(message.display);
                    if (error)
                        return "display." + error;
                }
            }
            if (message.lora != null && message.hasOwnProperty("lora")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.LoRaConfig.verify(message.lora);
                    if (error)
                        return "lora." + error;
                }
            }
            if (message.bluetooth != null && message.hasOwnProperty("bluetooth")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.BluetoothConfig.verify(message.bluetooth);
                    if (error)
                        return "bluetooth." + error;
                }
            }
            if (message.security != null && message.hasOwnProperty("security")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.SecurityConfig.verify(message.security);
                    if (error)
                        return "security." + error;
                }
            }
            if (message.sessionkey != null && message.hasOwnProperty("sessionkey")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.SessionkeyConfig.verify(message.sessionkey);
                    if (error)
                        return "sessionkey." + error;
                }
            }
            if (message.deviceUi != null && message.hasOwnProperty("deviceUi")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.DeviceUIConfig.verify(message.deviceUi);
                    if (error)
                        return "deviceUi." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Config message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Config
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Config} Config
         */
        Config.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Config)
                return object;
            var message = new $root.meshtastic.Config();
            if (object.device != null) {
                if (typeof object.device !== "object")
                    throw TypeError(".meshtastic.Config.device: object expected");
                message.device = $root.meshtastic.Config.DeviceConfig.fromObject(object.device);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".meshtastic.Config.position: object expected");
                message.position = $root.meshtastic.Config.PositionConfig.fromObject(object.position);
            }
            if (object.power != null) {
                if (typeof object.power !== "object")
                    throw TypeError(".meshtastic.Config.power: object expected");
                message.power = $root.meshtastic.Config.PowerConfig.fromObject(object.power);
            }
            if (object.network != null) {
                if (typeof object.network !== "object")
                    throw TypeError(".meshtastic.Config.network: object expected");
                message.network = $root.meshtastic.Config.NetworkConfig.fromObject(object.network);
            }
            if (object.display != null) {
                if (typeof object.display !== "object")
                    throw TypeError(".meshtastic.Config.display: object expected");
                message.display = $root.meshtastic.Config.DisplayConfig.fromObject(object.display);
            }
            if (object.lora != null) {
                if (typeof object.lora !== "object")
                    throw TypeError(".meshtastic.Config.lora: object expected");
                message.lora = $root.meshtastic.Config.LoRaConfig.fromObject(object.lora);
            }
            if (object.bluetooth != null) {
                if (typeof object.bluetooth !== "object")
                    throw TypeError(".meshtastic.Config.bluetooth: object expected");
                message.bluetooth = $root.meshtastic.Config.BluetoothConfig.fromObject(object.bluetooth);
            }
            if (object.security != null) {
                if (typeof object.security !== "object")
                    throw TypeError(".meshtastic.Config.security: object expected");
                message.security = $root.meshtastic.Config.SecurityConfig.fromObject(object.security);
            }
            if (object.sessionkey != null) {
                if (typeof object.sessionkey !== "object")
                    throw TypeError(".meshtastic.Config.sessionkey: object expected");
                message.sessionkey = $root.meshtastic.Config.SessionkeyConfig.fromObject(object.sessionkey);
            }
            if (object.deviceUi != null) {
                if (typeof object.deviceUi !== "object")
                    throw TypeError(".meshtastic.Config.deviceUi: object expected");
                message.deviceUi = $root.meshtastic.DeviceUIConfig.fromObject(object.deviceUi);
            }
            return message;
        };

        /**
         * Creates a plain object from a Config message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Config
         * @static
         * @param {meshtastic.Config} message Config
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Config.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.device != null && message.hasOwnProperty("device")) {
                object.device = $root.meshtastic.Config.DeviceConfig.toObject(message.device, options);
                if (options.oneofs)
                    object.payloadVariant = "device";
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                object.position = $root.meshtastic.Config.PositionConfig.toObject(message.position, options);
                if (options.oneofs)
                    object.payloadVariant = "position";
            }
            if (message.power != null && message.hasOwnProperty("power")) {
                object.power = $root.meshtastic.Config.PowerConfig.toObject(message.power, options);
                if (options.oneofs)
                    object.payloadVariant = "power";
            }
            if (message.network != null && message.hasOwnProperty("network")) {
                object.network = $root.meshtastic.Config.NetworkConfig.toObject(message.network, options);
                if (options.oneofs)
                    object.payloadVariant = "network";
            }
            if (message.display != null && message.hasOwnProperty("display")) {
                object.display = $root.meshtastic.Config.DisplayConfig.toObject(message.display, options);
                if (options.oneofs)
                    object.payloadVariant = "display";
            }
            if (message.lora != null && message.hasOwnProperty("lora")) {
                object.lora = $root.meshtastic.Config.LoRaConfig.toObject(message.lora, options);
                if (options.oneofs)
                    object.payloadVariant = "lora";
            }
            if (message.bluetooth != null && message.hasOwnProperty("bluetooth")) {
                object.bluetooth = $root.meshtastic.Config.BluetoothConfig.toObject(message.bluetooth, options);
                if (options.oneofs)
                    object.payloadVariant = "bluetooth";
            }
            if (message.security != null && message.hasOwnProperty("security")) {
                object.security = $root.meshtastic.Config.SecurityConfig.toObject(message.security, options);
                if (options.oneofs)
                    object.payloadVariant = "security";
            }
            if (message.sessionkey != null && message.hasOwnProperty("sessionkey")) {
                object.sessionkey = $root.meshtastic.Config.SessionkeyConfig.toObject(message.sessionkey, options);
                if (options.oneofs)
                    object.payloadVariant = "sessionkey";
            }
            if (message.deviceUi != null && message.hasOwnProperty("deviceUi")) {
                object.deviceUi = $root.meshtastic.DeviceUIConfig.toObject(message.deviceUi, options);
                if (options.oneofs)
                    object.payloadVariant = "deviceUi";
            }
            return object;
        };

        /**
         * Converts this Config to JSON.
         * @function toJSON
         * @memberof meshtastic.Config
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Config.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Config
         * @function getTypeUrl
         * @memberof meshtastic.Config
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Config.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Config";
        };

        Config.DeviceConfig = (function() {

            /**
             * Properties of a DeviceConfig.
             * @memberof meshtastic.Config
             * @interface IDeviceConfig
             * @property {meshtastic.Config.DeviceConfig.Role|null} [role] DeviceConfig role
             * @property {boolean|null} [serialEnabled] DeviceConfig serialEnabled
             * @property {number|null} [buttonGpio] DeviceConfig buttonGpio
             * @property {number|null} [buzzerGpio] DeviceConfig buzzerGpio
             * @property {meshtastic.Config.DeviceConfig.RebroadcastMode|null} [rebroadcastMode] DeviceConfig rebroadcastMode
             * @property {number|null} [nodeInfoBroadcastSecs] DeviceConfig nodeInfoBroadcastSecs
             * @property {boolean|null} [doubleTapAsButtonPress] DeviceConfig doubleTapAsButtonPress
             * @property {boolean|null} [isManaged] DeviceConfig isManaged
             * @property {boolean|null} [disableTripleClick] DeviceConfig disableTripleClick
             * @property {string|null} [tzdef] DeviceConfig tzdef
             * @property {boolean|null} [ledHeartbeatDisabled] DeviceConfig ledHeartbeatDisabled
             * @property {meshtastic.Config.DeviceConfig.BuzzerMode|null} [buzzerMode] DeviceConfig buzzerMode
             */

            /**
             * Constructs a new DeviceConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a DeviceConfig.
             * @implements IDeviceConfig
             * @constructor
             * @param {meshtastic.Config.IDeviceConfig=} [properties] Properties to set
             */
            function DeviceConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceConfig role.
             * @member {meshtastic.Config.DeviceConfig.Role} role
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.role = 0;

            /**
             * DeviceConfig serialEnabled.
             * @member {boolean} serialEnabled
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.serialEnabled = false;

            /**
             * DeviceConfig buttonGpio.
             * @member {number} buttonGpio
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.buttonGpio = 0;

            /**
             * DeviceConfig buzzerGpio.
             * @member {number} buzzerGpio
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.buzzerGpio = 0;

            /**
             * DeviceConfig rebroadcastMode.
             * @member {meshtastic.Config.DeviceConfig.RebroadcastMode} rebroadcastMode
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.rebroadcastMode = 0;

            /**
             * DeviceConfig nodeInfoBroadcastSecs.
             * @member {number} nodeInfoBroadcastSecs
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.nodeInfoBroadcastSecs = 0;

            /**
             * DeviceConfig doubleTapAsButtonPress.
             * @member {boolean} doubleTapAsButtonPress
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.doubleTapAsButtonPress = false;

            /**
             * DeviceConfig isManaged.
             * @member {boolean} isManaged
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.isManaged = false;

            /**
             * DeviceConfig disableTripleClick.
             * @member {boolean} disableTripleClick
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.disableTripleClick = false;

            /**
             * DeviceConfig tzdef.
             * @member {string} tzdef
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.tzdef = "";

            /**
             * DeviceConfig ledHeartbeatDisabled.
             * @member {boolean} ledHeartbeatDisabled
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.ledHeartbeatDisabled = false;

            /**
             * DeviceConfig buzzerMode.
             * @member {meshtastic.Config.DeviceConfig.BuzzerMode} buzzerMode
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             */
            DeviceConfig.prototype.buzzerMode = 0;

            /**
             * Creates a new DeviceConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {meshtastic.Config.IDeviceConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.DeviceConfig} DeviceConfig instance
             */
            DeviceConfig.create = function create(properties) {
                return new DeviceConfig(properties);
            };

            /**
             * Encodes the specified DeviceConfig message. Does not implicitly {@link meshtastic.Config.DeviceConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {meshtastic.Config.IDeviceConfig} message DeviceConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.role);
                if (message.serialEnabled != null && Object.hasOwnProperty.call(message, "serialEnabled"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.serialEnabled);
                if (message.buttonGpio != null && Object.hasOwnProperty.call(message, "buttonGpio"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.buttonGpio);
                if (message.buzzerGpio != null && Object.hasOwnProperty.call(message, "buzzerGpio"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.buzzerGpio);
                if (message.rebroadcastMode != null && Object.hasOwnProperty.call(message, "rebroadcastMode"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rebroadcastMode);
                if (message.nodeInfoBroadcastSecs != null && Object.hasOwnProperty.call(message, "nodeInfoBroadcastSecs"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.nodeInfoBroadcastSecs);
                if (message.doubleTapAsButtonPress != null && Object.hasOwnProperty.call(message, "doubleTapAsButtonPress"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.doubleTapAsButtonPress);
                if (message.isManaged != null && Object.hasOwnProperty.call(message, "isManaged"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isManaged);
                if (message.disableTripleClick != null && Object.hasOwnProperty.call(message, "disableTripleClick"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.disableTripleClick);
                if (message.tzdef != null && Object.hasOwnProperty.call(message, "tzdef"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.tzdef);
                if (message.ledHeartbeatDisabled != null && Object.hasOwnProperty.call(message, "ledHeartbeatDisabled"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.ledHeartbeatDisabled);
                if (message.buzzerMode != null && Object.hasOwnProperty.call(message, "buzzerMode"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.buzzerMode);
                return writer;
            };

            /**
             * Encodes the specified DeviceConfig message, length delimited. Does not implicitly {@link meshtastic.Config.DeviceConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {meshtastic.Config.IDeviceConfig} message DeviceConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.DeviceConfig} DeviceConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.DeviceConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.role = reader.int32();
                            break;
                        }
                    case 2: {
                            message.serialEnabled = reader.bool();
                            break;
                        }
                    case 4: {
                            message.buttonGpio = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.buzzerGpio = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.rebroadcastMode = reader.int32();
                            break;
                        }
                    case 7: {
                            message.nodeInfoBroadcastSecs = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.doubleTapAsButtonPress = reader.bool();
                            break;
                        }
                    case 9: {
                            message.isManaged = reader.bool();
                            break;
                        }
                    case 10: {
                            message.disableTripleClick = reader.bool();
                            break;
                        }
                    case 11: {
                            message.tzdef = reader.string();
                            break;
                        }
                    case 12: {
                            message.ledHeartbeatDisabled = reader.bool();
                            break;
                        }
                    case 13: {
                            message.buzzerMode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.DeviceConfig} DeviceConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceConfig message.
             * @function verify
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    switch (message.role) {
                    default:
                        return "role: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.serialEnabled != null && message.hasOwnProperty("serialEnabled"))
                    if (typeof message.serialEnabled !== "boolean")
                        return "serialEnabled: boolean expected";
                if (message.buttonGpio != null && message.hasOwnProperty("buttonGpio"))
                    if (!$util.isInteger(message.buttonGpio))
                        return "buttonGpio: integer expected";
                if (message.buzzerGpio != null && message.hasOwnProperty("buzzerGpio"))
                    if (!$util.isInteger(message.buzzerGpio))
                        return "buzzerGpio: integer expected";
                if (message.rebroadcastMode != null && message.hasOwnProperty("rebroadcastMode"))
                    switch (message.rebroadcastMode) {
                    default:
                        return "rebroadcastMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.nodeInfoBroadcastSecs != null && message.hasOwnProperty("nodeInfoBroadcastSecs"))
                    if (!$util.isInteger(message.nodeInfoBroadcastSecs))
                        return "nodeInfoBroadcastSecs: integer expected";
                if (message.doubleTapAsButtonPress != null && message.hasOwnProperty("doubleTapAsButtonPress"))
                    if (typeof message.doubleTapAsButtonPress !== "boolean")
                        return "doubleTapAsButtonPress: boolean expected";
                if (message.isManaged != null && message.hasOwnProperty("isManaged"))
                    if (typeof message.isManaged !== "boolean")
                        return "isManaged: boolean expected";
                if (message.disableTripleClick != null && message.hasOwnProperty("disableTripleClick"))
                    if (typeof message.disableTripleClick !== "boolean")
                        return "disableTripleClick: boolean expected";
                if (message.tzdef != null && message.hasOwnProperty("tzdef"))
                    if (!$util.isString(message.tzdef))
                        return "tzdef: string expected";
                if (message.ledHeartbeatDisabled != null && message.hasOwnProperty("ledHeartbeatDisabled"))
                    if (typeof message.ledHeartbeatDisabled !== "boolean")
                        return "ledHeartbeatDisabled: boolean expected";
                if (message.buzzerMode != null && message.hasOwnProperty("buzzerMode"))
                    switch (message.buzzerMode) {
                    default:
                        return "buzzerMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a DeviceConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.DeviceConfig} DeviceConfig
             */
            DeviceConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.DeviceConfig)
                    return object;
                var message = new $root.meshtastic.Config.DeviceConfig();
                switch (object.role) {
                default:
                    if (typeof object.role === "number") {
                        message.role = object.role;
                        break;
                    }
                    break;
                case "CLIENT":
                case 0:
                    message.role = 0;
                    break;
                case "CLIENT_MUTE":
                case 1:
                    message.role = 1;
                    break;
                case "ROUTER":
                case 2:
                    message.role = 2;
                    break;
                case "ROUTER_CLIENT":
                case 3:
                    message.role = 3;
                    break;
                case "REPEATER":
                case 4:
                    message.role = 4;
                    break;
                case "TRACKER":
                case 5:
                    message.role = 5;
                    break;
                case "SENSOR":
                case 6:
                    message.role = 6;
                    break;
                case "TAK":
                case 7:
                    message.role = 7;
                    break;
                case "CLIENT_HIDDEN":
                case 8:
                    message.role = 8;
                    break;
                case "LOST_AND_FOUND":
                case 9:
                    message.role = 9;
                    break;
                case "TAK_TRACKER":
                case 10:
                    message.role = 10;
                    break;
                case "ROUTER_LATE":
                case 11:
                    message.role = 11;
                    break;
                case "CLIENT_BASE":
                case 12:
                    message.role = 12;
                    break;
                }
                if (object.serialEnabled != null)
                    message.serialEnabled = Boolean(object.serialEnabled);
                if (object.buttonGpio != null)
                    message.buttonGpio = object.buttonGpio >>> 0;
                if (object.buzzerGpio != null)
                    message.buzzerGpio = object.buzzerGpio >>> 0;
                switch (object.rebroadcastMode) {
                default:
                    if (typeof object.rebroadcastMode === "number") {
                        message.rebroadcastMode = object.rebroadcastMode;
                        break;
                    }
                    break;
                case "ALL":
                case 0:
                    message.rebroadcastMode = 0;
                    break;
                case "ALL_SKIP_DECODING":
                case 1:
                    message.rebroadcastMode = 1;
                    break;
                case "LOCAL_ONLY":
                case 2:
                    message.rebroadcastMode = 2;
                    break;
                case "KNOWN_ONLY":
                case 3:
                    message.rebroadcastMode = 3;
                    break;
                case "NONE":
                case 4:
                    message.rebroadcastMode = 4;
                    break;
                case "CORE_PORTNUMS_ONLY":
                case 5:
                    message.rebroadcastMode = 5;
                    break;
                }
                if (object.nodeInfoBroadcastSecs != null)
                    message.nodeInfoBroadcastSecs = object.nodeInfoBroadcastSecs >>> 0;
                if (object.doubleTapAsButtonPress != null)
                    message.doubleTapAsButtonPress = Boolean(object.doubleTapAsButtonPress);
                if (object.isManaged != null)
                    message.isManaged = Boolean(object.isManaged);
                if (object.disableTripleClick != null)
                    message.disableTripleClick = Boolean(object.disableTripleClick);
                if (object.tzdef != null)
                    message.tzdef = String(object.tzdef);
                if (object.ledHeartbeatDisabled != null)
                    message.ledHeartbeatDisabled = Boolean(object.ledHeartbeatDisabled);
                switch (object.buzzerMode) {
                default:
                    if (typeof object.buzzerMode === "number") {
                        message.buzzerMode = object.buzzerMode;
                        break;
                    }
                    break;
                case "ALL_ENABLED":
                case 0:
                    message.buzzerMode = 0;
                    break;
                case "DISABLED":
                case 1:
                    message.buzzerMode = 1;
                    break;
                case "NOTIFICATIONS_ONLY":
                case 2:
                    message.buzzerMode = 2;
                    break;
                case "SYSTEM_ONLY":
                case 3:
                    message.buzzerMode = 3;
                    break;
                case "DIRECT_MSG_ONLY":
                case 4:
                    message.buzzerMode = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DeviceConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {meshtastic.Config.DeviceConfig} message DeviceConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.role = options.enums === String ? "CLIENT" : 0;
                    object.serialEnabled = false;
                    object.buttonGpio = 0;
                    object.buzzerGpio = 0;
                    object.rebroadcastMode = options.enums === String ? "ALL" : 0;
                    object.nodeInfoBroadcastSecs = 0;
                    object.doubleTapAsButtonPress = false;
                    object.isManaged = false;
                    object.disableTripleClick = false;
                    object.tzdef = "";
                    object.ledHeartbeatDisabled = false;
                    object.buzzerMode = options.enums === String ? "ALL_ENABLED" : 0;
                }
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.enums === String ? $root.meshtastic.Config.DeviceConfig.Role[message.role] === undefined ? message.role : $root.meshtastic.Config.DeviceConfig.Role[message.role] : message.role;
                if (message.serialEnabled != null && message.hasOwnProperty("serialEnabled"))
                    object.serialEnabled = message.serialEnabled;
                if (message.buttonGpio != null && message.hasOwnProperty("buttonGpio"))
                    object.buttonGpio = message.buttonGpio;
                if (message.buzzerGpio != null && message.hasOwnProperty("buzzerGpio"))
                    object.buzzerGpio = message.buzzerGpio;
                if (message.rebroadcastMode != null && message.hasOwnProperty("rebroadcastMode"))
                    object.rebroadcastMode = options.enums === String ? $root.meshtastic.Config.DeviceConfig.RebroadcastMode[message.rebroadcastMode] === undefined ? message.rebroadcastMode : $root.meshtastic.Config.DeviceConfig.RebroadcastMode[message.rebroadcastMode] : message.rebroadcastMode;
                if (message.nodeInfoBroadcastSecs != null && message.hasOwnProperty("nodeInfoBroadcastSecs"))
                    object.nodeInfoBroadcastSecs = message.nodeInfoBroadcastSecs;
                if (message.doubleTapAsButtonPress != null && message.hasOwnProperty("doubleTapAsButtonPress"))
                    object.doubleTapAsButtonPress = message.doubleTapAsButtonPress;
                if (message.isManaged != null && message.hasOwnProperty("isManaged"))
                    object.isManaged = message.isManaged;
                if (message.disableTripleClick != null && message.hasOwnProperty("disableTripleClick"))
                    object.disableTripleClick = message.disableTripleClick;
                if (message.tzdef != null && message.hasOwnProperty("tzdef"))
                    object.tzdef = message.tzdef;
                if (message.ledHeartbeatDisabled != null && message.hasOwnProperty("ledHeartbeatDisabled"))
                    object.ledHeartbeatDisabled = message.ledHeartbeatDisabled;
                if (message.buzzerMode != null && message.hasOwnProperty("buzzerMode"))
                    object.buzzerMode = options.enums === String ? $root.meshtastic.Config.DeviceConfig.BuzzerMode[message.buzzerMode] === undefined ? message.buzzerMode : $root.meshtastic.Config.DeviceConfig.BuzzerMode[message.buzzerMode] : message.buzzerMode;
                return object;
            };

            /**
             * Converts this DeviceConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.DeviceConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeviceConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.DeviceConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeviceConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.DeviceConfig";
            };

            /**
             * Role enum.
             * @name meshtastic.Config.DeviceConfig.Role
             * @enum {number}
             * @property {number} CLIENT=0 CLIENT value
             * @property {number} CLIENT_MUTE=1 CLIENT_MUTE value
             * @property {number} ROUTER=2 ROUTER value
             * @property {number} ROUTER_CLIENT=3 ROUTER_CLIENT value
             * @property {number} REPEATER=4 REPEATER value
             * @property {number} TRACKER=5 TRACKER value
             * @property {number} SENSOR=6 SENSOR value
             * @property {number} TAK=7 TAK value
             * @property {number} CLIENT_HIDDEN=8 CLIENT_HIDDEN value
             * @property {number} LOST_AND_FOUND=9 LOST_AND_FOUND value
             * @property {number} TAK_TRACKER=10 TAK_TRACKER value
             * @property {number} ROUTER_LATE=11 ROUTER_LATE value
             * @property {number} CLIENT_BASE=12 CLIENT_BASE value
             */
            DeviceConfig.Role = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CLIENT"] = 0;
                values[valuesById[1] = "CLIENT_MUTE"] = 1;
                values[valuesById[2] = "ROUTER"] = 2;
                values[valuesById[3] = "ROUTER_CLIENT"] = 3;
                values[valuesById[4] = "REPEATER"] = 4;
                values[valuesById[5] = "TRACKER"] = 5;
                values[valuesById[6] = "SENSOR"] = 6;
                values[valuesById[7] = "TAK"] = 7;
                values[valuesById[8] = "CLIENT_HIDDEN"] = 8;
                values[valuesById[9] = "LOST_AND_FOUND"] = 9;
                values[valuesById[10] = "TAK_TRACKER"] = 10;
                values[valuesById[11] = "ROUTER_LATE"] = 11;
                values[valuesById[12] = "CLIENT_BASE"] = 12;
                return values;
            })();

            /**
             * RebroadcastMode enum.
             * @name meshtastic.Config.DeviceConfig.RebroadcastMode
             * @enum {number}
             * @property {number} ALL=0 ALL value
             * @property {number} ALL_SKIP_DECODING=1 ALL_SKIP_DECODING value
             * @property {number} LOCAL_ONLY=2 LOCAL_ONLY value
             * @property {number} KNOWN_ONLY=3 KNOWN_ONLY value
             * @property {number} NONE=4 NONE value
             * @property {number} CORE_PORTNUMS_ONLY=5 CORE_PORTNUMS_ONLY value
             */
            DeviceConfig.RebroadcastMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ALL"] = 0;
                values[valuesById[1] = "ALL_SKIP_DECODING"] = 1;
                values[valuesById[2] = "LOCAL_ONLY"] = 2;
                values[valuesById[3] = "KNOWN_ONLY"] = 3;
                values[valuesById[4] = "NONE"] = 4;
                values[valuesById[5] = "CORE_PORTNUMS_ONLY"] = 5;
                return values;
            })();

            /**
             * BuzzerMode enum.
             * @name meshtastic.Config.DeviceConfig.BuzzerMode
             * @enum {number}
             * @property {number} ALL_ENABLED=0 ALL_ENABLED value
             * @property {number} DISABLED=1 DISABLED value
             * @property {number} NOTIFICATIONS_ONLY=2 NOTIFICATIONS_ONLY value
             * @property {number} SYSTEM_ONLY=3 SYSTEM_ONLY value
             * @property {number} DIRECT_MSG_ONLY=4 DIRECT_MSG_ONLY value
             */
            DeviceConfig.BuzzerMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ALL_ENABLED"] = 0;
                values[valuesById[1] = "DISABLED"] = 1;
                values[valuesById[2] = "NOTIFICATIONS_ONLY"] = 2;
                values[valuesById[3] = "SYSTEM_ONLY"] = 3;
                values[valuesById[4] = "DIRECT_MSG_ONLY"] = 4;
                return values;
            })();

            return DeviceConfig;
        })();

        Config.PositionConfig = (function() {

            /**
             * Properties of a PositionConfig.
             * @memberof meshtastic.Config
             * @interface IPositionConfig
             * @property {number|null} [positionBroadcastSecs] PositionConfig positionBroadcastSecs
             * @property {boolean|null} [positionBroadcastSmartEnabled] PositionConfig positionBroadcastSmartEnabled
             * @property {boolean|null} [fixedPosition] PositionConfig fixedPosition
             * @property {boolean|null} [gpsEnabled] PositionConfig gpsEnabled
             * @property {number|null} [gpsUpdateInterval] PositionConfig gpsUpdateInterval
             * @property {number|null} [gpsAttemptTime] PositionConfig gpsAttemptTime
             * @property {number|null} [positionFlags] PositionConfig positionFlags
             * @property {number|null} [rxGpio] PositionConfig rxGpio
             * @property {number|null} [txGpio] PositionConfig txGpio
             * @property {number|null} [broadcastSmartMinimumDistance] PositionConfig broadcastSmartMinimumDistance
             * @property {number|null} [broadcastSmartMinimumIntervalSecs] PositionConfig broadcastSmartMinimumIntervalSecs
             * @property {number|null} [gpsEnGpio] PositionConfig gpsEnGpio
             * @property {meshtastic.Config.PositionConfig.GpsMode|null} [gpsMode] PositionConfig gpsMode
             */

            /**
             * Constructs a new PositionConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a PositionConfig.
             * @implements IPositionConfig
             * @constructor
             * @param {meshtastic.Config.IPositionConfig=} [properties] Properties to set
             */
            function PositionConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PositionConfig positionBroadcastSecs.
             * @member {number} positionBroadcastSecs
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.positionBroadcastSecs = 0;

            /**
             * PositionConfig positionBroadcastSmartEnabled.
             * @member {boolean} positionBroadcastSmartEnabled
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.positionBroadcastSmartEnabled = false;

            /**
             * PositionConfig fixedPosition.
             * @member {boolean} fixedPosition
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.fixedPosition = false;

            /**
             * PositionConfig gpsEnabled.
             * @member {boolean} gpsEnabled
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.gpsEnabled = false;

            /**
             * PositionConfig gpsUpdateInterval.
             * @member {number} gpsUpdateInterval
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.gpsUpdateInterval = 0;

            /**
             * PositionConfig gpsAttemptTime.
             * @member {number} gpsAttemptTime
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.gpsAttemptTime = 0;

            /**
             * PositionConfig positionFlags.
             * @member {number} positionFlags
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.positionFlags = 0;

            /**
             * PositionConfig rxGpio.
             * @member {number} rxGpio
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.rxGpio = 0;

            /**
             * PositionConfig txGpio.
             * @member {number} txGpio
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.txGpio = 0;

            /**
             * PositionConfig broadcastSmartMinimumDistance.
             * @member {number} broadcastSmartMinimumDistance
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.broadcastSmartMinimumDistance = 0;

            /**
             * PositionConfig broadcastSmartMinimumIntervalSecs.
             * @member {number} broadcastSmartMinimumIntervalSecs
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.broadcastSmartMinimumIntervalSecs = 0;

            /**
             * PositionConfig gpsEnGpio.
             * @member {number} gpsEnGpio
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.gpsEnGpio = 0;

            /**
             * PositionConfig gpsMode.
             * @member {meshtastic.Config.PositionConfig.GpsMode} gpsMode
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             */
            PositionConfig.prototype.gpsMode = 0;

            /**
             * Creates a new PositionConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {meshtastic.Config.IPositionConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.PositionConfig} PositionConfig instance
             */
            PositionConfig.create = function create(properties) {
                return new PositionConfig(properties);
            };

            /**
             * Encodes the specified PositionConfig message. Does not implicitly {@link meshtastic.Config.PositionConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {meshtastic.Config.IPositionConfig} message PositionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PositionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.positionBroadcastSecs != null && Object.hasOwnProperty.call(message, "positionBroadcastSecs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.positionBroadcastSecs);
                if (message.positionBroadcastSmartEnabled != null && Object.hasOwnProperty.call(message, "positionBroadcastSmartEnabled"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.positionBroadcastSmartEnabled);
                if (message.fixedPosition != null && Object.hasOwnProperty.call(message, "fixedPosition"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fixedPosition);
                if (message.gpsEnabled != null && Object.hasOwnProperty.call(message, "gpsEnabled"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.gpsEnabled);
                if (message.gpsUpdateInterval != null && Object.hasOwnProperty.call(message, "gpsUpdateInterval"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.gpsUpdateInterval);
                if (message.gpsAttemptTime != null && Object.hasOwnProperty.call(message, "gpsAttemptTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.gpsAttemptTime);
                if (message.positionFlags != null && Object.hasOwnProperty.call(message, "positionFlags"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.positionFlags);
                if (message.rxGpio != null && Object.hasOwnProperty.call(message, "rxGpio"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.rxGpio);
                if (message.txGpio != null && Object.hasOwnProperty.call(message, "txGpio"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.txGpio);
                if (message.broadcastSmartMinimumDistance != null && Object.hasOwnProperty.call(message, "broadcastSmartMinimumDistance"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.broadcastSmartMinimumDistance);
                if (message.broadcastSmartMinimumIntervalSecs != null && Object.hasOwnProperty.call(message, "broadcastSmartMinimumIntervalSecs"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.broadcastSmartMinimumIntervalSecs);
                if (message.gpsEnGpio != null && Object.hasOwnProperty.call(message, "gpsEnGpio"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.gpsEnGpio);
                if (message.gpsMode != null && Object.hasOwnProperty.call(message, "gpsMode"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.gpsMode);
                return writer;
            };

            /**
             * Encodes the specified PositionConfig message, length delimited. Does not implicitly {@link meshtastic.Config.PositionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {meshtastic.Config.IPositionConfig} message PositionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PositionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PositionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.PositionConfig} PositionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PositionConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.PositionConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.positionBroadcastSecs = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.positionBroadcastSmartEnabled = reader.bool();
                            break;
                        }
                    case 3: {
                            message.fixedPosition = reader.bool();
                            break;
                        }
                    case 4: {
                            message.gpsEnabled = reader.bool();
                            break;
                        }
                    case 5: {
                            message.gpsUpdateInterval = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.gpsAttemptTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.positionFlags = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.rxGpio = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.txGpio = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.broadcastSmartMinimumDistance = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.broadcastSmartMinimumIntervalSecs = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.gpsEnGpio = reader.uint32();
                            break;
                        }
                    case 13: {
                            message.gpsMode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PositionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.PositionConfig} PositionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PositionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PositionConfig message.
             * @function verify
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PositionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.positionBroadcastSecs != null && message.hasOwnProperty("positionBroadcastSecs"))
                    if (!$util.isInteger(message.positionBroadcastSecs))
                        return "positionBroadcastSecs: integer expected";
                if (message.positionBroadcastSmartEnabled != null && message.hasOwnProperty("positionBroadcastSmartEnabled"))
                    if (typeof message.positionBroadcastSmartEnabled !== "boolean")
                        return "positionBroadcastSmartEnabled: boolean expected";
                if (message.fixedPosition != null && message.hasOwnProperty("fixedPosition"))
                    if (typeof message.fixedPosition !== "boolean")
                        return "fixedPosition: boolean expected";
                if (message.gpsEnabled != null && message.hasOwnProperty("gpsEnabled"))
                    if (typeof message.gpsEnabled !== "boolean")
                        return "gpsEnabled: boolean expected";
                if (message.gpsUpdateInterval != null && message.hasOwnProperty("gpsUpdateInterval"))
                    if (!$util.isInteger(message.gpsUpdateInterval))
                        return "gpsUpdateInterval: integer expected";
                if (message.gpsAttemptTime != null && message.hasOwnProperty("gpsAttemptTime"))
                    if (!$util.isInteger(message.gpsAttemptTime))
                        return "gpsAttemptTime: integer expected";
                if (message.positionFlags != null && message.hasOwnProperty("positionFlags"))
                    if (!$util.isInteger(message.positionFlags))
                        return "positionFlags: integer expected";
                if (message.rxGpio != null && message.hasOwnProperty("rxGpio"))
                    if (!$util.isInteger(message.rxGpio))
                        return "rxGpio: integer expected";
                if (message.txGpio != null && message.hasOwnProperty("txGpio"))
                    if (!$util.isInteger(message.txGpio))
                        return "txGpio: integer expected";
                if (message.broadcastSmartMinimumDistance != null && message.hasOwnProperty("broadcastSmartMinimumDistance"))
                    if (!$util.isInteger(message.broadcastSmartMinimumDistance))
                        return "broadcastSmartMinimumDistance: integer expected";
                if (message.broadcastSmartMinimumIntervalSecs != null && message.hasOwnProperty("broadcastSmartMinimumIntervalSecs"))
                    if (!$util.isInteger(message.broadcastSmartMinimumIntervalSecs))
                        return "broadcastSmartMinimumIntervalSecs: integer expected";
                if (message.gpsEnGpio != null && message.hasOwnProperty("gpsEnGpio"))
                    if (!$util.isInteger(message.gpsEnGpio))
                        return "gpsEnGpio: integer expected";
                if (message.gpsMode != null && message.hasOwnProperty("gpsMode"))
                    switch (message.gpsMode) {
                    default:
                        return "gpsMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a PositionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.PositionConfig} PositionConfig
             */
            PositionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.PositionConfig)
                    return object;
                var message = new $root.meshtastic.Config.PositionConfig();
                if (object.positionBroadcastSecs != null)
                    message.positionBroadcastSecs = object.positionBroadcastSecs >>> 0;
                if (object.positionBroadcastSmartEnabled != null)
                    message.positionBroadcastSmartEnabled = Boolean(object.positionBroadcastSmartEnabled);
                if (object.fixedPosition != null)
                    message.fixedPosition = Boolean(object.fixedPosition);
                if (object.gpsEnabled != null)
                    message.gpsEnabled = Boolean(object.gpsEnabled);
                if (object.gpsUpdateInterval != null)
                    message.gpsUpdateInterval = object.gpsUpdateInterval >>> 0;
                if (object.gpsAttemptTime != null)
                    message.gpsAttemptTime = object.gpsAttemptTime >>> 0;
                if (object.positionFlags != null)
                    message.positionFlags = object.positionFlags >>> 0;
                if (object.rxGpio != null)
                    message.rxGpio = object.rxGpio >>> 0;
                if (object.txGpio != null)
                    message.txGpio = object.txGpio >>> 0;
                if (object.broadcastSmartMinimumDistance != null)
                    message.broadcastSmartMinimumDistance = object.broadcastSmartMinimumDistance >>> 0;
                if (object.broadcastSmartMinimumIntervalSecs != null)
                    message.broadcastSmartMinimumIntervalSecs = object.broadcastSmartMinimumIntervalSecs >>> 0;
                if (object.gpsEnGpio != null)
                    message.gpsEnGpio = object.gpsEnGpio >>> 0;
                switch (object.gpsMode) {
                default:
                    if (typeof object.gpsMode === "number") {
                        message.gpsMode = object.gpsMode;
                        break;
                    }
                    break;
                case "DISABLED":
                case 0:
                    message.gpsMode = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.gpsMode = 1;
                    break;
                case "NOT_PRESENT":
                case 2:
                    message.gpsMode = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a PositionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {meshtastic.Config.PositionConfig} message PositionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PositionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.positionBroadcastSecs = 0;
                    object.positionBroadcastSmartEnabled = false;
                    object.fixedPosition = false;
                    object.gpsEnabled = false;
                    object.gpsUpdateInterval = 0;
                    object.gpsAttemptTime = 0;
                    object.positionFlags = 0;
                    object.rxGpio = 0;
                    object.txGpio = 0;
                    object.broadcastSmartMinimumDistance = 0;
                    object.broadcastSmartMinimumIntervalSecs = 0;
                    object.gpsEnGpio = 0;
                    object.gpsMode = options.enums === String ? "DISABLED" : 0;
                }
                if (message.positionBroadcastSecs != null && message.hasOwnProperty("positionBroadcastSecs"))
                    object.positionBroadcastSecs = message.positionBroadcastSecs;
                if (message.positionBroadcastSmartEnabled != null && message.hasOwnProperty("positionBroadcastSmartEnabled"))
                    object.positionBroadcastSmartEnabled = message.positionBroadcastSmartEnabled;
                if (message.fixedPosition != null && message.hasOwnProperty("fixedPosition"))
                    object.fixedPosition = message.fixedPosition;
                if (message.gpsEnabled != null && message.hasOwnProperty("gpsEnabled"))
                    object.gpsEnabled = message.gpsEnabled;
                if (message.gpsUpdateInterval != null && message.hasOwnProperty("gpsUpdateInterval"))
                    object.gpsUpdateInterval = message.gpsUpdateInterval;
                if (message.gpsAttemptTime != null && message.hasOwnProperty("gpsAttemptTime"))
                    object.gpsAttemptTime = message.gpsAttemptTime;
                if (message.positionFlags != null && message.hasOwnProperty("positionFlags"))
                    object.positionFlags = message.positionFlags;
                if (message.rxGpio != null && message.hasOwnProperty("rxGpio"))
                    object.rxGpio = message.rxGpio;
                if (message.txGpio != null && message.hasOwnProperty("txGpio"))
                    object.txGpio = message.txGpio;
                if (message.broadcastSmartMinimumDistance != null && message.hasOwnProperty("broadcastSmartMinimumDistance"))
                    object.broadcastSmartMinimumDistance = message.broadcastSmartMinimumDistance;
                if (message.broadcastSmartMinimumIntervalSecs != null && message.hasOwnProperty("broadcastSmartMinimumIntervalSecs"))
                    object.broadcastSmartMinimumIntervalSecs = message.broadcastSmartMinimumIntervalSecs;
                if (message.gpsEnGpio != null && message.hasOwnProperty("gpsEnGpio"))
                    object.gpsEnGpio = message.gpsEnGpio;
                if (message.gpsMode != null && message.hasOwnProperty("gpsMode"))
                    object.gpsMode = options.enums === String ? $root.meshtastic.Config.PositionConfig.GpsMode[message.gpsMode] === undefined ? message.gpsMode : $root.meshtastic.Config.PositionConfig.GpsMode[message.gpsMode] : message.gpsMode;
                return object;
            };

            /**
             * Converts this PositionConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.PositionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PositionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PositionConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.PositionConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PositionConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.PositionConfig";
            };

            /**
             * PositionFlags enum.
             * @name meshtastic.Config.PositionConfig.PositionFlags
             * @enum {number}
             * @property {number} UNSET=0 UNSET value
             * @property {number} ALTITUDE=1 ALTITUDE value
             * @property {number} ALTITUDE_MSL=2 ALTITUDE_MSL value
             * @property {number} GEOIDAL_SEPARATION=4 GEOIDAL_SEPARATION value
             * @property {number} DOP=8 DOP value
             * @property {number} HVDOP=16 HVDOP value
             * @property {number} SATINVIEW=32 SATINVIEW value
             * @property {number} SEQ_NO=64 SEQ_NO value
             * @property {number} TIMESTAMP=128 TIMESTAMP value
             * @property {number} HEADING=256 HEADING value
             * @property {number} SPEED=512 SPEED value
             */
            PositionConfig.PositionFlags = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSET"] = 0;
                values[valuesById[1] = "ALTITUDE"] = 1;
                values[valuesById[2] = "ALTITUDE_MSL"] = 2;
                values[valuesById[4] = "GEOIDAL_SEPARATION"] = 4;
                values[valuesById[8] = "DOP"] = 8;
                values[valuesById[16] = "HVDOP"] = 16;
                values[valuesById[32] = "SATINVIEW"] = 32;
                values[valuesById[64] = "SEQ_NO"] = 64;
                values[valuesById[128] = "TIMESTAMP"] = 128;
                values[valuesById[256] = "HEADING"] = 256;
                values[valuesById[512] = "SPEED"] = 512;
                return values;
            })();

            /**
             * GpsMode enum.
             * @name meshtastic.Config.PositionConfig.GpsMode
             * @enum {number}
             * @property {number} DISABLED=0 DISABLED value
             * @property {number} ENABLED=1 ENABLED value
             * @property {number} NOT_PRESENT=2 NOT_PRESENT value
             */
            PositionConfig.GpsMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DISABLED"] = 0;
                values[valuesById[1] = "ENABLED"] = 1;
                values[valuesById[2] = "NOT_PRESENT"] = 2;
                return values;
            })();

            return PositionConfig;
        })();

        Config.PowerConfig = (function() {

            /**
             * Properties of a PowerConfig.
             * @memberof meshtastic.Config
             * @interface IPowerConfig
             * @property {boolean|null} [isPowerSaving] PowerConfig isPowerSaving
             * @property {number|null} [onBatteryShutdownAfterSecs] PowerConfig onBatteryShutdownAfterSecs
             * @property {number|null} [adcMultiplierOverride] PowerConfig adcMultiplierOverride
             * @property {number|null} [waitBluetoothSecs] PowerConfig waitBluetoothSecs
             * @property {number|null} [sdsSecs] PowerConfig sdsSecs
             * @property {number|null} [lsSecs] PowerConfig lsSecs
             * @property {number|null} [minWakeSecs] PowerConfig minWakeSecs
             * @property {number|null} [deviceBatteryInaAddress] PowerConfig deviceBatteryInaAddress
             * @property {number|Long|null} [powermonEnables] PowerConfig powermonEnables
             */

            /**
             * Constructs a new PowerConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a PowerConfig.
             * @implements IPowerConfig
             * @constructor
             * @param {meshtastic.Config.IPowerConfig=} [properties] Properties to set
             */
            function PowerConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PowerConfig isPowerSaving.
             * @member {boolean} isPowerSaving
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.isPowerSaving = false;

            /**
             * PowerConfig onBatteryShutdownAfterSecs.
             * @member {number} onBatteryShutdownAfterSecs
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.onBatteryShutdownAfterSecs = 0;

            /**
             * PowerConfig adcMultiplierOverride.
             * @member {number} adcMultiplierOverride
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.adcMultiplierOverride = 0;

            /**
             * PowerConfig waitBluetoothSecs.
             * @member {number} waitBluetoothSecs
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.waitBluetoothSecs = 0;

            /**
             * PowerConfig sdsSecs.
             * @member {number} sdsSecs
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.sdsSecs = 0;

            /**
             * PowerConfig lsSecs.
             * @member {number} lsSecs
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.lsSecs = 0;

            /**
             * PowerConfig minWakeSecs.
             * @member {number} minWakeSecs
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.minWakeSecs = 0;

            /**
             * PowerConfig deviceBatteryInaAddress.
             * @member {number} deviceBatteryInaAddress
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.deviceBatteryInaAddress = 0;

            /**
             * PowerConfig powermonEnables.
             * @member {number|Long} powermonEnables
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             */
            PowerConfig.prototype.powermonEnables = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new PowerConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {meshtastic.Config.IPowerConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.PowerConfig} PowerConfig instance
             */
            PowerConfig.create = function create(properties) {
                return new PowerConfig(properties);
            };

            /**
             * Encodes the specified PowerConfig message. Does not implicitly {@link meshtastic.Config.PowerConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {meshtastic.Config.IPowerConfig} message PowerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PowerConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isPowerSaving != null && Object.hasOwnProperty.call(message, "isPowerSaving"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isPowerSaving);
                if (message.onBatteryShutdownAfterSecs != null && Object.hasOwnProperty.call(message, "onBatteryShutdownAfterSecs"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.onBatteryShutdownAfterSecs);
                if (message.adcMultiplierOverride != null && Object.hasOwnProperty.call(message, "adcMultiplierOverride"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.adcMultiplierOverride);
                if (message.waitBluetoothSecs != null && Object.hasOwnProperty.call(message, "waitBluetoothSecs"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.waitBluetoothSecs);
                if (message.sdsSecs != null && Object.hasOwnProperty.call(message, "sdsSecs"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sdsSecs);
                if (message.lsSecs != null && Object.hasOwnProperty.call(message, "lsSecs"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.lsSecs);
                if (message.minWakeSecs != null && Object.hasOwnProperty.call(message, "minWakeSecs"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.minWakeSecs);
                if (message.deviceBatteryInaAddress != null && Object.hasOwnProperty.call(message, "deviceBatteryInaAddress"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.deviceBatteryInaAddress);
                if (message.powermonEnables != null && Object.hasOwnProperty.call(message, "powermonEnables"))
                    writer.uint32(/* id 32, wireType 0 =*/256).uint64(message.powermonEnables);
                return writer;
            };

            /**
             * Encodes the specified PowerConfig message, length delimited. Does not implicitly {@link meshtastic.Config.PowerConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {meshtastic.Config.IPowerConfig} message PowerConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PowerConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PowerConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.PowerConfig} PowerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PowerConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.PowerConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.isPowerSaving = reader.bool();
                            break;
                        }
                    case 2: {
                            message.onBatteryShutdownAfterSecs = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.adcMultiplierOverride = reader.float();
                            break;
                        }
                    case 4: {
                            message.waitBluetoothSecs = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.sdsSecs = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.lsSecs = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.minWakeSecs = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.deviceBatteryInaAddress = reader.uint32();
                            break;
                        }
                    case 32: {
                            message.powermonEnables = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PowerConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.PowerConfig} PowerConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PowerConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PowerConfig message.
             * @function verify
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PowerConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isPowerSaving != null && message.hasOwnProperty("isPowerSaving"))
                    if (typeof message.isPowerSaving !== "boolean")
                        return "isPowerSaving: boolean expected";
                if (message.onBatteryShutdownAfterSecs != null && message.hasOwnProperty("onBatteryShutdownAfterSecs"))
                    if (!$util.isInteger(message.onBatteryShutdownAfterSecs))
                        return "onBatteryShutdownAfterSecs: integer expected";
                if (message.adcMultiplierOverride != null && message.hasOwnProperty("adcMultiplierOverride"))
                    if (typeof message.adcMultiplierOverride !== "number")
                        return "adcMultiplierOverride: number expected";
                if (message.waitBluetoothSecs != null && message.hasOwnProperty("waitBluetoothSecs"))
                    if (!$util.isInteger(message.waitBluetoothSecs))
                        return "waitBluetoothSecs: integer expected";
                if (message.sdsSecs != null && message.hasOwnProperty("sdsSecs"))
                    if (!$util.isInteger(message.sdsSecs))
                        return "sdsSecs: integer expected";
                if (message.lsSecs != null && message.hasOwnProperty("lsSecs"))
                    if (!$util.isInteger(message.lsSecs))
                        return "lsSecs: integer expected";
                if (message.minWakeSecs != null && message.hasOwnProperty("minWakeSecs"))
                    if (!$util.isInteger(message.minWakeSecs))
                        return "minWakeSecs: integer expected";
                if (message.deviceBatteryInaAddress != null && message.hasOwnProperty("deviceBatteryInaAddress"))
                    if (!$util.isInteger(message.deviceBatteryInaAddress))
                        return "deviceBatteryInaAddress: integer expected";
                if (message.powermonEnables != null && message.hasOwnProperty("powermonEnables"))
                    if (!$util.isInteger(message.powermonEnables) && !(message.powermonEnables && $util.isInteger(message.powermonEnables.low) && $util.isInteger(message.powermonEnables.high)))
                        return "powermonEnables: integer|Long expected";
                return null;
            };

            /**
             * Creates a PowerConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.PowerConfig} PowerConfig
             */
            PowerConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.PowerConfig)
                    return object;
                var message = new $root.meshtastic.Config.PowerConfig();
                if (object.isPowerSaving != null)
                    message.isPowerSaving = Boolean(object.isPowerSaving);
                if (object.onBatteryShutdownAfterSecs != null)
                    message.onBatteryShutdownAfterSecs = object.onBatteryShutdownAfterSecs >>> 0;
                if (object.adcMultiplierOverride != null)
                    message.adcMultiplierOverride = Number(object.adcMultiplierOverride);
                if (object.waitBluetoothSecs != null)
                    message.waitBluetoothSecs = object.waitBluetoothSecs >>> 0;
                if (object.sdsSecs != null)
                    message.sdsSecs = object.sdsSecs >>> 0;
                if (object.lsSecs != null)
                    message.lsSecs = object.lsSecs >>> 0;
                if (object.minWakeSecs != null)
                    message.minWakeSecs = object.minWakeSecs >>> 0;
                if (object.deviceBatteryInaAddress != null)
                    message.deviceBatteryInaAddress = object.deviceBatteryInaAddress >>> 0;
                if (object.powermonEnables != null)
                    if ($util.Long)
                        (message.powermonEnables = $util.Long.fromValue(object.powermonEnables)).unsigned = true;
                    else if (typeof object.powermonEnables === "string")
                        message.powermonEnables = parseInt(object.powermonEnables, 10);
                    else if (typeof object.powermonEnables === "number")
                        message.powermonEnables = object.powermonEnables;
                    else if (typeof object.powermonEnables === "object")
                        message.powermonEnables = new $util.LongBits(object.powermonEnables.low >>> 0, object.powermonEnables.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PowerConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {meshtastic.Config.PowerConfig} message PowerConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PowerConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isPowerSaving = false;
                    object.onBatteryShutdownAfterSecs = 0;
                    object.adcMultiplierOverride = 0;
                    object.waitBluetoothSecs = 0;
                    object.sdsSecs = 0;
                    object.lsSecs = 0;
                    object.minWakeSecs = 0;
                    object.deviceBatteryInaAddress = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.powermonEnables = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.powermonEnables = options.longs === String ? "0" : 0;
                }
                if (message.isPowerSaving != null && message.hasOwnProperty("isPowerSaving"))
                    object.isPowerSaving = message.isPowerSaving;
                if (message.onBatteryShutdownAfterSecs != null && message.hasOwnProperty("onBatteryShutdownAfterSecs"))
                    object.onBatteryShutdownAfterSecs = message.onBatteryShutdownAfterSecs;
                if (message.adcMultiplierOverride != null && message.hasOwnProperty("adcMultiplierOverride"))
                    object.adcMultiplierOverride = options.json && !isFinite(message.adcMultiplierOverride) ? String(message.adcMultiplierOverride) : message.adcMultiplierOverride;
                if (message.waitBluetoothSecs != null && message.hasOwnProperty("waitBluetoothSecs"))
                    object.waitBluetoothSecs = message.waitBluetoothSecs;
                if (message.sdsSecs != null && message.hasOwnProperty("sdsSecs"))
                    object.sdsSecs = message.sdsSecs;
                if (message.lsSecs != null && message.hasOwnProperty("lsSecs"))
                    object.lsSecs = message.lsSecs;
                if (message.minWakeSecs != null && message.hasOwnProperty("minWakeSecs"))
                    object.minWakeSecs = message.minWakeSecs;
                if (message.deviceBatteryInaAddress != null && message.hasOwnProperty("deviceBatteryInaAddress"))
                    object.deviceBatteryInaAddress = message.deviceBatteryInaAddress;
                if (message.powermonEnables != null && message.hasOwnProperty("powermonEnables"))
                    if (typeof message.powermonEnables === "number")
                        object.powermonEnables = options.longs === String ? String(message.powermonEnables) : message.powermonEnables;
                    else
                        object.powermonEnables = options.longs === String ? $util.Long.prototype.toString.call(message.powermonEnables) : options.longs === Number ? new $util.LongBits(message.powermonEnables.low >>> 0, message.powermonEnables.high >>> 0).toNumber(true) : message.powermonEnables;
                return object;
            };

            /**
             * Converts this PowerConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.PowerConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PowerConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PowerConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.PowerConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PowerConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.PowerConfig";
            };

            return PowerConfig;
        })();

        Config.NetworkConfig = (function() {

            /**
             * Properties of a NetworkConfig.
             * @memberof meshtastic.Config
             * @interface INetworkConfig
             * @property {boolean|null} [wifiEnabled] NetworkConfig wifiEnabled
             * @property {string|null} [wifiSsid] NetworkConfig wifiSsid
             * @property {string|null} [wifiPsk] NetworkConfig wifiPsk
             * @property {string|null} [ntpServer] NetworkConfig ntpServer
             * @property {boolean|null} [ethEnabled] NetworkConfig ethEnabled
             * @property {meshtastic.Config.NetworkConfig.AddressMode|null} [addressMode] NetworkConfig addressMode
             * @property {meshtastic.Config.NetworkConfig.IIpV4Config|null} [ipv4Config] NetworkConfig ipv4Config
             * @property {string|null} [rsyslogServer] NetworkConfig rsyslogServer
             * @property {number|null} [enabledProtocols] NetworkConfig enabledProtocols
             * @property {boolean|null} [ipv6Enabled] NetworkConfig ipv6Enabled
             */

            /**
             * Constructs a new NetworkConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a NetworkConfig.
             * @implements INetworkConfig
             * @constructor
             * @param {meshtastic.Config.INetworkConfig=} [properties] Properties to set
             */
            function NetworkConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NetworkConfig wifiEnabled.
             * @member {boolean} wifiEnabled
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.wifiEnabled = false;

            /**
             * NetworkConfig wifiSsid.
             * @member {string} wifiSsid
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.wifiSsid = "";

            /**
             * NetworkConfig wifiPsk.
             * @member {string} wifiPsk
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.wifiPsk = "";

            /**
             * NetworkConfig ntpServer.
             * @member {string} ntpServer
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.ntpServer = "";

            /**
             * NetworkConfig ethEnabled.
             * @member {boolean} ethEnabled
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.ethEnabled = false;

            /**
             * NetworkConfig addressMode.
             * @member {meshtastic.Config.NetworkConfig.AddressMode} addressMode
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.addressMode = 0;

            /**
             * NetworkConfig ipv4Config.
             * @member {meshtastic.Config.NetworkConfig.IIpV4Config|null|undefined} ipv4Config
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.ipv4Config = null;

            /**
             * NetworkConfig rsyslogServer.
             * @member {string} rsyslogServer
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.rsyslogServer = "";

            /**
             * NetworkConfig enabledProtocols.
             * @member {number} enabledProtocols
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.enabledProtocols = 0;

            /**
             * NetworkConfig ipv6Enabled.
             * @member {boolean} ipv6Enabled
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             */
            NetworkConfig.prototype.ipv6Enabled = false;

            /**
             * Creates a new NetworkConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {meshtastic.Config.INetworkConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.NetworkConfig} NetworkConfig instance
             */
            NetworkConfig.create = function create(properties) {
                return new NetworkConfig(properties);
            };

            /**
             * Encodes the specified NetworkConfig message. Does not implicitly {@link meshtastic.Config.NetworkConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {meshtastic.Config.INetworkConfig} message NetworkConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.wifiEnabled != null && Object.hasOwnProperty.call(message, "wifiEnabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.wifiEnabled);
                if (message.wifiSsid != null && Object.hasOwnProperty.call(message, "wifiSsid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.wifiSsid);
                if (message.wifiPsk != null && Object.hasOwnProperty.call(message, "wifiPsk"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.wifiPsk);
                if (message.ntpServer != null && Object.hasOwnProperty.call(message, "ntpServer"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.ntpServer);
                if (message.ethEnabled != null && Object.hasOwnProperty.call(message, "ethEnabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.ethEnabled);
                if (message.addressMode != null && Object.hasOwnProperty.call(message, "addressMode"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.addressMode);
                if (message.ipv4Config != null && Object.hasOwnProperty.call(message, "ipv4Config"))
                    $root.meshtastic.Config.NetworkConfig.IpV4Config.encode(message.ipv4Config, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.rsyslogServer != null && Object.hasOwnProperty.call(message, "rsyslogServer"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.rsyslogServer);
                if (message.enabledProtocols != null && Object.hasOwnProperty.call(message, "enabledProtocols"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.enabledProtocols);
                if (message.ipv6Enabled != null && Object.hasOwnProperty.call(message, "ipv6Enabled"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.ipv6Enabled);
                return writer;
            };

            /**
             * Encodes the specified NetworkConfig message, length delimited. Does not implicitly {@link meshtastic.Config.NetworkConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {meshtastic.Config.INetworkConfig} message NetworkConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NetworkConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.NetworkConfig} NetworkConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.NetworkConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.wifiEnabled = reader.bool();
                            break;
                        }
                    case 3: {
                            message.wifiSsid = reader.string();
                            break;
                        }
                    case 4: {
                            message.wifiPsk = reader.string();
                            break;
                        }
                    case 5: {
                            message.ntpServer = reader.string();
                            break;
                        }
                    case 6: {
                            message.ethEnabled = reader.bool();
                            break;
                        }
                    case 7: {
                            message.addressMode = reader.int32();
                            break;
                        }
                    case 8: {
                            message.ipv4Config = $root.meshtastic.Config.NetworkConfig.IpV4Config.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.rsyslogServer = reader.string();
                            break;
                        }
                    case 10: {
                            message.enabledProtocols = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.ipv6Enabled = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NetworkConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.NetworkConfig} NetworkConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NetworkConfig message.
             * @function verify
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NetworkConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.wifiEnabled != null && message.hasOwnProperty("wifiEnabled"))
                    if (typeof message.wifiEnabled !== "boolean")
                        return "wifiEnabled: boolean expected";
                if (message.wifiSsid != null && message.hasOwnProperty("wifiSsid"))
                    if (!$util.isString(message.wifiSsid))
                        return "wifiSsid: string expected";
                if (message.wifiPsk != null && message.hasOwnProperty("wifiPsk"))
                    if (!$util.isString(message.wifiPsk))
                        return "wifiPsk: string expected";
                if (message.ntpServer != null && message.hasOwnProperty("ntpServer"))
                    if (!$util.isString(message.ntpServer))
                        return "ntpServer: string expected";
                if (message.ethEnabled != null && message.hasOwnProperty("ethEnabled"))
                    if (typeof message.ethEnabled !== "boolean")
                        return "ethEnabled: boolean expected";
                if (message.addressMode != null && message.hasOwnProperty("addressMode"))
                    switch (message.addressMode) {
                    default:
                        return "addressMode: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.ipv4Config != null && message.hasOwnProperty("ipv4Config")) {
                    var error = $root.meshtastic.Config.NetworkConfig.IpV4Config.verify(message.ipv4Config);
                    if (error)
                        return "ipv4Config." + error;
                }
                if (message.rsyslogServer != null && message.hasOwnProperty("rsyslogServer"))
                    if (!$util.isString(message.rsyslogServer))
                        return "rsyslogServer: string expected";
                if (message.enabledProtocols != null && message.hasOwnProperty("enabledProtocols"))
                    if (!$util.isInteger(message.enabledProtocols))
                        return "enabledProtocols: integer expected";
                if (message.ipv6Enabled != null && message.hasOwnProperty("ipv6Enabled"))
                    if (typeof message.ipv6Enabled !== "boolean")
                        return "ipv6Enabled: boolean expected";
                return null;
            };

            /**
             * Creates a NetworkConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.NetworkConfig} NetworkConfig
             */
            NetworkConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.NetworkConfig)
                    return object;
                var message = new $root.meshtastic.Config.NetworkConfig();
                if (object.wifiEnabled != null)
                    message.wifiEnabled = Boolean(object.wifiEnabled);
                if (object.wifiSsid != null)
                    message.wifiSsid = String(object.wifiSsid);
                if (object.wifiPsk != null)
                    message.wifiPsk = String(object.wifiPsk);
                if (object.ntpServer != null)
                    message.ntpServer = String(object.ntpServer);
                if (object.ethEnabled != null)
                    message.ethEnabled = Boolean(object.ethEnabled);
                switch (object.addressMode) {
                default:
                    if (typeof object.addressMode === "number") {
                        message.addressMode = object.addressMode;
                        break;
                    }
                    break;
                case "DHCP":
                case 0:
                    message.addressMode = 0;
                    break;
                case "STATIC":
                case 1:
                    message.addressMode = 1;
                    break;
                }
                if (object.ipv4Config != null) {
                    if (typeof object.ipv4Config !== "object")
                        throw TypeError(".meshtastic.Config.NetworkConfig.ipv4Config: object expected");
                    message.ipv4Config = $root.meshtastic.Config.NetworkConfig.IpV4Config.fromObject(object.ipv4Config);
                }
                if (object.rsyslogServer != null)
                    message.rsyslogServer = String(object.rsyslogServer);
                if (object.enabledProtocols != null)
                    message.enabledProtocols = object.enabledProtocols >>> 0;
                if (object.ipv6Enabled != null)
                    message.ipv6Enabled = Boolean(object.ipv6Enabled);
                return message;
            };

            /**
             * Creates a plain object from a NetworkConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {meshtastic.Config.NetworkConfig} message NetworkConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NetworkConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.wifiEnabled = false;
                    object.wifiSsid = "";
                    object.wifiPsk = "";
                    object.ntpServer = "";
                    object.ethEnabled = false;
                    object.addressMode = options.enums === String ? "DHCP" : 0;
                    object.ipv4Config = null;
                    object.rsyslogServer = "";
                    object.enabledProtocols = 0;
                    object.ipv6Enabled = false;
                }
                if (message.wifiEnabled != null && message.hasOwnProperty("wifiEnabled"))
                    object.wifiEnabled = message.wifiEnabled;
                if (message.wifiSsid != null && message.hasOwnProperty("wifiSsid"))
                    object.wifiSsid = message.wifiSsid;
                if (message.wifiPsk != null && message.hasOwnProperty("wifiPsk"))
                    object.wifiPsk = message.wifiPsk;
                if (message.ntpServer != null && message.hasOwnProperty("ntpServer"))
                    object.ntpServer = message.ntpServer;
                if (message.ethEnabled != null && message.hasOwnProperty("ethEnabled"))
                    object.ethEnabled = message.ethEnabled;
                if (message.addressMode != null && message.hasOwnProperty("addressMode"))
                    object.addressMode = options.enums === String ? $root.meshtastic.Config.NetworkConfig.AddressMode[message.addressMode] === undefined ? message.addressMode : $root.meshtastic.Config.NetworkConfig.AddressMode[message.addressMode] : message.addressMode;
                if (message.ipv4Config != null && message.hasOwnProperty("ipv4Config"))
                    object.ipv4Config = $root.meshtastic.Config.NetworkConfig.IpV4Config.toObject(message.ipv4Config, options);
                if (message.rsyslogServer != null && message.hasOwnProperty("rsyslogServer"))
                    object.rsyslogServer = message.rsyslogServer;
                if (message.enabledProtocols != null && message.hasOwnProperty("enabledProtocols"))
                    object.enabledProtocols = message.enabledProtocols;
                if (message.ipv6Enabled != null && message.hasOwnProperty("ipv6Enabled"))
                    object.ipv6Enabled = message.ipv6Enabled;
                return object;
            };

            /**
             * Converts this NetworkConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.NetworkConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NetworkConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NetworkConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.NetworkConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NetworkConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.NetworkConfig";
            };

            /**
             * AddressMode enum.
             * @name meshtastic.Config.NetworkConfig.AddressMode
             * @enum {number}
             * @property {number} DHCP=0 DHCP value
             * @property {number} STATIC=1 STATIC value
             */
            NetworkConfig.AddressMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DHCP"] = 0;
                values[valuesById[1] = "STATIC"] = 1;
                return values;
            })();

            NetworkConfig.IpV4Config = (function() {

                /**
                 * Properties of an IpV4Config.
                 * @memberof meshtastic.Config.NetworkConfig
                 * @interface IIpV4Config
                 * @property {number|null} [ip] IpV4Config ip
                 * @property {number|null} [gateway] IpV4Config gateway
                 * @property {number|null} [subnet] IpV4Config subnet
                 * @property {number|null} [dns] IpV4Config dns
                 */

                /**
                 * Constructs a new IpV4Config.
                 * @memberof meshtastic.Config.NetworkConfig
                 * @classdesc Represents an IpV4Config.
                 * @implements IIpV4Config
                 * @constructor
                 * @param {meshtastic.Config.NetworkConfig.IIpV4Config=} [properties] Properties to set
                 */
                function IpV4Config(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IpV4Config ip.
                 * @member {number} ip
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @instance
                 */
                IpV4Config.prototype.ip = 0;

                /**
                 * IpV4Config gateway.
                 * @member {number} gateway
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @instance
                 */
                IpV4Config.prototype.gateway = 0;

                /**
                 * IpV4Config subnet.
                 * @member {number} subnet
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @instance
                 */
                IpV4Config.prototype.subnet = 0;

                /**
                 * IpV4Config dns.
                 * @member {number} dns
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @instance
                 */
                IpV4Config.prototype.dns = 0;

                /**
                 * Creates a new IpV4Config instance using the specified properties.
                 * @function create
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {meshtastic.Config.NetworkConfig.IIpV4Config=} [properties] Properties to set
                 * @returns {meshtastic.Config.NetworkConfig.IpV4Config} IpV4Config instance
                 */
                IpV4Config.create = function create(properties) {
                    return new IpV4Config(properties);
                };

                /**
                 * Encodes the specified IpV4Config message. Does not implicitly {@link meshtastic.Config.NetworkConfig.IpV4Config.verify|verify} messages.
                 * @function encode
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {meshtastic.Config.NetworkConfig.IIpV4Config} message IpV4Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IpV4Config.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.ip);
                    if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                        writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.gateway);
                    if (message.subnet != null && Object.hasOwnProperty.call(message, "subnet"))
                        writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.subnet);
                    if (message.dns != null && Object.hasOwnProperty.call(message, "dns"))
                        writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.dns);
                    return writer;
                };

                /**
                 * Encodes the specified IpV4Config message, length delimited. Does not implicitly {@link meshtastic.Config.NetworkConfig.IpV4Config.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {meshtastic.Config.NetworkConfig.IIpV4Config} message IpV4Config message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IpV4Config.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IpV4Config message from the specified reader or buffer.
                 * @function decode
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {meshtastic.Config.NetworkConfig.IpV4Config} IpV4Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IpV4Config.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.NetworkConfig.IpV4Config();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.ip = reader.fixed32();
                                break;
                            }
                        case 2: {
                                message.gateway = reader.fixed32();
                                break;
                            }
                        case 3: {
                                message.subnet = reader.fixed32();
                                break;
                            }
                        case 4: {
                                message.dns = reader.fixed32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IpV4Config message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {meshtastic.Config.NetworkConfig.IpV4Config} IpV4Config
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IpV4Config.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an IpV4Config message.
                 * @function verify
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IpV4Config.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ip != null && message.hasOwnProperty("ip"))
                        if (!$util.isInteger(message.ip))
                            return "ip: integer expected";
                    if (message.gateway != null && message.hasOwnProperty("gateway"))
                        if (!$util.isInteger(message.gateway))
                            return "gateway: integer expected";
                    if (message.subnet != null && message.hasOwnProperty("subnet"))
                        if (!$util.isInteger(message.subnet))
                            return "subnet: integer expected";
                    if (message.dns != null && message.hasOwnProperty("dns"))
                        if (!$util.isInteger(message.dns))
                            return "dns: integer expected";
                    return null;
                };

                /**
                 * Creates an IpV4Config message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {meshtastic.Config.NetworkConfig.IpV4Config} IpV4Config
                 */
                IpV4Config.fromObject = function fromObject(object) {
                    if (object instanceof $root.meshtastic.Config.NetworkConfig.IpV4Config)
                        return object;
                    var message = new $root.meshtastic.Config.NetworkConfig.IpV4Config();
                    if (object.ip != null)
                        message.ip = object.ip >>> 0;
                    if (object.gateway != null)
                        message.gateway = object.gateway >>> 0;
                    if (object.subnet != null)
                        message.subnet = object.subnet >>> 0;
                    if (object.dns != null)
                        message.dns = object.dns >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an IpV4Config message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {meshtastic.Config.NetworkConfig.IpV4Config} message IpV4Config
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IpV4Config.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ip = 0;
                        object.gateway = 0;
                        object.subnet = 0;
                        object.dns = 0;
                    }
                    if (message.ip != null && message.hasOwnProperty("ip"))
                        object.ip = message.ip;
                    if (message.gateway != null && message.hasOwnProperty("gateway"))
                        object.gateway = message.gateway;
                    if (message.subnet != null && message.hasOwnProperty("subnet"))
                        object.subnet = message.subnet;
                    if (message.dns != null && message.hasOwnProperty("dns"))
                        object.dns = message.dns;
                    return object;
                };

                /**
                 * Converts this IpV4Config to JSON.
                 * @function toJSON
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IpV4Config.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for IpV4Config
                 * @function getTypeUrl
                 * @memberof meshtastic.Config.NetworkConfig.IpV4Config
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                IpV4Config.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/meshtastic.Config.NetworkConfig.IpV4Config";
                };

                return IpV4Config;
            })();

            /**
             * ProtocolFlags enum.
             * @name meshtastic.Config.NetworkConfig.ProtocolFlags
             * @enum {number}
             * @property {number} NO_BROADCAST=0 NO_BROADCAST value
             * @property {number} UDP_BROADCAST=1 UDP_BROADCAST value
             */
            NetworkConfig.ProtocolFlags = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NO_BROADCAST"] = 0;
                values[valuesById[1] = "UDP_BROADCAST"] = 1;
                return values;
            })();

            return NetworkConfig;
        })();

        Config.DisplayConfig = (function() {

            /**
             * Properties of a DisplayConfig.
             * @memberof meshtastic.Config
             * @interface IDisplayConfig
             * @property {number|null} [screenOnSecs] DisplayConfig screenOnSecs
             * @property {meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat|null} [gpsFormat] DisplayConfig gpsFormat
             * @property {number|null} [autoScreenCarouselSecs] DisplayConfig autoScreenCarouselSecs
             * @property {boolean|null} [compassNorthTop] DisplayConfig compassNorthTop
             * @property {boolean|null} [flipScreen] DisplayConfig flipScreen
             * @property {meshtastic.Config.DisplayConfig.DisplayUnits|null} [units] DisplayConfig units
             * @property {meshtastic.Config.DisplayConfig.OledType|null} [oled] DisplayConfig oled
             * @property {meshtastic.Config.DisplayConfig.DisplayMode|null} [displaymode] DisplayConfig displaymode
             * @property {boolean|null} [headingBold] DisplayConfig headingBold
             * @property {boolean|null} [wakeOnTapOrMotion] DisplayConfig wakeOnTapOrMotion
             * @property {meshtastic.Config.DisplayConfig.CompassOrientation|null} [compassOrientation] DisplayConfig compassOrientation
             * @property {boolean|null} [use_12hClock] DisplayConfig use_12hClock
             * @property {boolean|null} [useLongNodeName] DisplayConfig useLongNodeName
             */

            /**
             * Constructs a new DisplayConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a DisplayConfig.
             * @implements IDisplayConfig
             * @constructor
             * @param {meshtastic.Config.IDisplayConfig=} [properties] Properties to set
             */
            function DisplayConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DisplayConfig screenOnSecs.
             * @member {number} screenOnSecs
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.screenOnSecs = 0;

            /**
             * DisplayConfig gpsFormat.
             * @member {meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat} gpsFormat
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.gpsFormat = 0;

            /**
             * DisplayConfig autoScreenCarouselSecs.
             * @member {number} autoScreenCarouselSecs
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.autoScreenCarouselSecs = 0;

            /**
             * DisplayConfig compassNorthTop.
             * @member {boolean} compassNorthTop
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.compassNorthTop = false;

            /**
             * DisplayConfig flipScreen.
             * @member {boolean} flipScreen
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.flipScreen = false;

            /**
             * DisplayConfig units.
             * @member {meshtastic.Config.DisplayConfig.DisplayUnits} units
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.units = 0;

            /**
             * DisplayConfig oled.
             * @member {meshtastic.Config.DisplayConfig.OledType} oled
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.oled = 0;

            /**
             * DisplayConfig displaymode.
             * @member {meshtastic.Config.DisplayConfig.DisplayMode} displaymode
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.displaymode = 0;

            /**
             * DisplayConfig headingBold.
             * @member {boolean} headingBold
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.headingBold = false;

            /**
             * DisplayConfig wakeOnTapOrMotion.
             * @member {boolean} wakeOnTapOrMotion
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.wakeOnTapOrMotion = false;

            /**
             * DisplayConfig compassOrientation.
             * @member {meshtastic.Config.DisplayConfig.CompassOrientation} compassOrientation
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.compassOrientation = 0;

            /**
             * DisplayConfig use_12hClock.
             * @member {boolean} use_12hClock
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.use_12hClock = false;

            /**
             * DisplayConfig useLongNodeName.
             * @member {boolean} useLongNodeName
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             */
            DisplayConfig.prototype.useLongNodeName = false;

            /**
             * Creates a new DisplayConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {meshtastic.Config.IDisplayConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.DisplayConfig} DisplayConfig instance
             */
            DisplayConfig.create = function create(properties) {
                return new DisplayConfig(properties);
            };

            /**
             * Encodes the specified DisplayConfig message. Does not implicitly {@link meshtastic.Config.DisplayConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {meshtastic.Config.IDisplayConfig} message DisplayConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisplayConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.screenOnSecs != null && Object.hasOwnProperty.call(message, "screenOnSecs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.screenOnSecs);
                if (message.gpsFormat != null && Object.hasOwnProperty.call(message, "gpsFormat"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gpsFormat);
                if (message.autoScreenCarouselSecs != null && Object.hasOwnProperty.call(message, "autoScreenCarouselSecs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.autoScreenCarouselSecs);
                if (message.compassNorthTop != null && Object.hasOwnProperty.call(message, "compassNorthTop"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.compassNorthTop);
                if (message.flipScreen != null && Object.hasOwnProperty.call(message, "flipScreen"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.flipScreen);
                if (message.units != null && Object.hasOwnProperty.call(message, "units"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.units);
                if (message.oled != null && Object.hasOwnProperty.call(message, "oled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.oled);
                if (message.displaymode != null && Object.hasOwnProperty.call(message, "displaymode"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.displaymode);
                if (message.headingBold != null && Object.hasOwnProperty.call(message, "headingBold"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.headingBold);
                if (message.wakeOnTapOrMotion != null && Object.hasOwnProperty.call(message, "wakeOnTapOrMotion"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.wakeOnTapOrMotion);
                if (message.compassOrientation != null && Object.hasOwnProperty.call(message, "compassOrientation"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.compassOrientation);
                if (message.use_12hClock != null && Object.hasOwnProperty.call(message, "use_12hClock"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.use_12hClock);
                if (message.useLongNodeName != null && Object.hasOwnProperty.call(message, "useLongNodeName"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.useLongNodeName);
                return writer;
            };

            /**
             * Encodes the specified DisplayConfig message, length delimited. Does not implicitly {@link meshtastic.Config.DisplayConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {meshtastic.Config.IDisplayConfig} message DisplayConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DisplayConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DisplayConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.DisplayConfig} DisplayConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisplayConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.DisplayConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.screenOnSecs = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.gpsFormat = reader.int32();
                            break;
                        }
                    case 3: {
                            message.autoScreenCarouselSecs = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.compassNorthTop = reader.bool();
                            break;
                        }
                    case 5: {
                            message.flipScreen = reader.bool();
                            break;
                        }
                    case 6: {
                            message.units = reader.int32();
                            break;
                        }
                    case 7: {
                            message.oled = reader.int32();
                            break;
                        }
                    case 8: {
                            message.displaymode = reader.int32();
                            break;
                        }
                    case 9: {
                            message.headingBold = reader.bool();
                            break;
                        }
                    case 10: {
                            message.wakeOnTapOrMotion = reader.bool();
                            break;
                        }
                    case 11: {
                            message.compassOrientation = reader.int32();
                            break;
                        }
                    case 12: {
                            message.use_12hClock = reader.bool();
                            break;
                        }
                    case 13: {
                            message.useLongNodeName = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DisplayConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.DisplayConfig} DisplayConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DisplayConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DisplayConfig message.
             * @function verify
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DisplayConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.screenOnSecs != null && message.hasOwnProperty("screenOnSecs"))
                    if (!$util.isInteger(message.screenOnSecs))
                        return "screenOnSecs: integer expected";
                if (message.gpsFormat != null && message.hasOwnProperty("gpsFormat"))
                    switch (message.gpsFormat) {
                    default:
                        return "gpsFormat: enum value expected";
                    case 0:
                        break;
                    }
                if (message.autoScreenCarouselSecs != null && message.hasOwnProperty("autoScreenCarouselSecs"))
                    if (!$util.isInteger(message.autoScreenCarouselSecs))
                        return "autoScreenCarouselSecs: integer expected";
                if (message.compassNorthTop != null && message.hasOwnProperty("compassNorthTop"))
                    if (typeof message.compassNorthTop !== "boolean")
                        return "compassNorthTop: boolean expected";
                if (message.flipScreen != null && message.hasOwnProperty("flipScreen"))
                    if (typeof message.flipScreen !== "boolean")
                        return "flipScreen: boolean expected";
                if (message.units != null && message.hasOwnProperty("units"))
                    switch (message.units) {
                    default:
                        return "units: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.oled != null && message.hasOwnProperty("oled"))
                    switch (message.oled) {
                    default:
                        return "oled: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.displaymode != null && message.hasOwnProperty("displaymode"))
                    switch (message.displaymode) {
                    default:
                        return "displaymode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.headingBold != null && message.hasOwnProperty("headingBold"))
                    if (typeof message.headingBold !== "boolean")
                        return "headingBold: boolean expected";
                if (message.wakeOnTapOrMotion != null && message.hasOwnProperty("wakeOnTapOrMotion"))
                    if (typeof message.wakeOnTapOrMotion !== "boolean")
                        return "wakeOnTapOrMotion: boolean expected";
                if (message.compassOrientation != null && message.hasOwnProperty("compassOrientation"))
                    switch (message.compassOrientation) {
                    default:
                        return "compassOrientation: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.use_12hClock != null && message.hasOwnProperty("use_12hClock"))
                    if (typeof message.use_12hClock !== "boolean")
                        return "use_12hClock: boolean expected";
                if (message.useLongNodeName != null && message.hasOwnProperty("useLongNodeName"))
                    if (typeof message.useLongNodeName !== "boolean")
                        return "useLongNodeName: boolean expected";
                return null;
            };

            /**
             * Creates a DisplayConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.DisplayConfig} DisplayConfig
             */
            DisplayConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.DisplayConfig)
                    return object;
                var message = new $root.meshtastic.Config.DisplayConfig();
                if (object.screenOnSecs != null)
                    message.screenOnSecs = object.screenOnSecs >>> 0;
                switch (object.gpsFormat) {
                default:
                    if (typeof object.gpsFormat === "number") {
                        message.gpsFormat = object.gpsFormat;
                        break;
                    }
                    break;
                case "UNUSED":
                case 0:
                    message.gpsFormat = 0;
                    break;
                }
                if (object.autoScreenCarouselSecs != null)
                    message.autoScreenCarouselSecs = object.autoScreenCarouselSecs >>> 0;
                if (object.compassNorthTop != null)
                    message.compassNorthTop = Boolean(object.compassNorthTop);
                if (object.flipScreen != null)
                    message.flipScreen = Boolean(object.flipScreen);
                switch (object.units) {
                default:
                    if (typeof object.units === "number") {
                        message.units = object.units;
                        break;
                    }
                    break;
                case "METRIC":
                case 0:
                    message.units = 0;
                    break;
                case "IMPERIAL":
                case 1:
                    message.units = 1;
                    break;
                }
                switch (object.oled) {
                default:
                    if (typeof object.oled === "number") {
                        message.oled = object.oled;
                        break;
                    }
                    break;
                case "OLED_AUTO":
                case 0:
                    message.oled = 0;
                    break;
                case "OLED_SSD1306":
                case 1:
                    message.oled = 1;
                    break;
                case "OLED_SH1106":
                case 2:
                    message.oled = 2;
                    break;
                case "OLED_SH1107":
                case 3:
                    message.oled = 3;
                    break;
                case "OLED_SH1107_128_128":
                case 4:
                    message.oled = 4;
                    break;
                }
                switch (object.displaymode) {
                default:
                    if (typeof object.displaymode === "number") {
                        message.displaymode = object.displaymode;
                        break;
                    }
                    break;
                case "DEFAULT":
                case 0:
                    message.displaymode = 0;
                    break;
                case "TWOCOLOR":
                case 1:
                    message.displaymode = 1;
                    break;
                case "INVERTED":
                case 2:
                    message.displaymode = 2;
                    break;
                case "COLOR":
                case 3:
                    message.displaymode = 3;
                    break;
                }
                if (object.headingBold != null)
                    message.headingBold = Boolean(object.headingBold);
                if (object.wakeOnTapOrMotion != null)
                    message.wakeOnTapOrMotion = Boolean(object.wakeOnTapOrMotion);
                switch (object.compassOrientation) {
                default:
                    if (typeof object.compassOrientation === "number") {
                        message.compassOrientation = object.compassOrientation;
                        break;
                    }
                    break;
                case "DEGREES_0":
                case 0:
                    message.compassOrientation = 0;
                    break;
                case "DEGREES_90":
                case 1:
                    message.compassOrientation = 1;
                    break;
                case "DEGREES_180":
                case 2:
                    message.compassOrientation = 2;
                    break;
                case "DEGREES_270":
                case 3:
                    message.compassOrientation = 3;
                    break;
                case "DEGREES_0_INVERTED":
                case 4:
                    message.compassOrientation = 4;
                    break;
                case "DEGREES_90_INVERTED":
                case 5:
                    message.compassOrientation = 5;
                    break;
                case "DEGREES_180_INVERTED":
                case 6:
                    message.compassOrientation = 6;
                    break;
                case "DEGREES_270_INVERTED":
                case 7:
                    message.compassOrientation = 7;
                    break;
                }
                if (object.use_12hClock != null)
                    message.use_12hClock = Boolean(object.use_12hClock);
                if (object.useLongNodeName != null)
                    message.useLongNodeName = Boolean(object.useLongNodeName);
                return message;
            };

            /**
             * Creates a plain object from a DisplayConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {meshtastic.Config.DisplayConfig} message DisplayConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DisplayConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.screenOnSecs = 0;
                    object.gpsFormat = options.enums === String ? "UNUSED" : 0;
                    object.autoScreenCarouselSecs = 0;
                    object.compassNorthTop = false;
                    object.flipScreen = false;
                    object.units = options.enums === String ? "METRIC" : 0;
                    object.oled = options.enums === String ? "OLED_AUTO" : 0;
                    object.displaymode = options.enums === String ? "DEFAULT" : 0;
                    object.headingBold = false;
                    object.wakeOnTapOrMotion = false;
                    object.compassOrientation = options.enums === String ? "DEGREES_0" : 0;
                    object.use_12hClock = false;
                    object.useLongNodeName = false;
                }
                if (message.screenOnSecs != null && message.hasOwnProperty("screenOnSecs"))
                    object.screenOnSecs = message.screenOnSecs;
                if (message.gpsFormat != null && message.hasOwnProperty("gpsFormat"))
                    object.gpsFormat = options.enums === String ? $root.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat[message.gpsFormat] === undefined ? message.gpsFormat : $root.meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat[message.gpsFormat] : message.gpsFormat;
                if (message.autoScreenCarouselSecs != null && message.hasOwnProperty("autoScreenCarouselSecs"))
                    object.autoScreenCarouselSecs = message.autoScreenCarouselSecs;
                if (message.compassNorthTop != null && message.hasOwnProperty("compassNorthTop"))
                    object.compassNorthTop = message.compassNorthTop;
                if (message.flipScreen != null && message.hasOwnProperty("flipScreen"))
                    object.flipScreen = message.flipScreen;
                if (message.units != null && message.hasOwnProperty("units"))
                    object.units = options.enums === String ? $root.meshtastic.Config.DisplayConfig.DisplayUnits[message.units] === undefined ? message.units : $root.meshtastic.Config.DisplayConfig.DisplayUnits[message.units] : message.units;
                if (message.oled != null && message.hasOwnProperty("oled"))
                    object.oled = options.enums === String ? $root.meshtastic.Config.DisplayConfig.OledType[message.oled] === undefined ? message.oled : $root.meshtastic.Config.DisplayConfig.OledType[message.oled] : message.oled;
                if (message.displaymode != null && message.hasOwnProperty("displaymode"))
                    object.displaymode = options.enums === String ? $root.meshtastic.Config.DisplayConfig.DisplayMode[message.displaymode] === undefined ? message.displaymode : $root.meshtastic.Config.DisplayConfig.DisplayMode[message.displaymode] : message.displaymode;
                if (message.headingBold != null && message.hasOwnProperty("headingBold"))
                    object.headingBold = message.headingBold;
                if (message.wakeOnTapOrMotion != null && message.hasOwnProperty("wakeOnTapOrMotion"))
                    object.wakeOnTapOrMotion = message.wakeOnTapOrMotion;
                if (message.compassOrientation != null && message.hasOwnProperty("compassOrientation"))
                    object.compassOrientation = options.enums === String ? $root.meshtastic.Config.DisplayConfig.CompassOrientation[message.compassOrientation] === undefined ? message.compassOrientation : $root.meshtastic.Config.DisplayConfig.CompassOrientation[message.compassOrientation] : message.compassOrientation;
                if (message.use_12hClock != null && message.hasOwnProperty("use_12hClock"))
                    object.use_12hClock = message.use_12hClock;
                if (message.useLongNodeName != null && message.hasOwnProperty("useLongNodeName"))
                    object.useLongNodeName = message.useLongNodeName;
                return object;
            };

            /**
             * Converts this DisplayConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.DisplayConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DisplayConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DisplayConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.DisplayConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DisplayConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.DisplayConfig";
            };

            /**
             * DeprecatedGpsCoordinateFormat enum.
             * @name meshtastic.Config.DisplayConfig.DeprecatedGpsCoordinateFormat
             * @enum {number}
             * @property {number} UNUSED=0 UNUSED value
             */
            DisplayConfig.DeprecatedGpsCoordinateFormat = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNUSED"] = 0;
                return values;
            })();

            /**
             * DisplayUnits enum.
             * @name meshtastic.Config.DisplayConfig.DisplayUnits
             * @enum {number}
             * @property {number} METRIC=0 METRIC value
             * @property {number} IMPERIAL=1 IMPERIAL value
             */
            DisplayConfig.DisplayUnits = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METRIC"] = 0;
                values[valuesById[1] = "IMPERIAL"] = 1;
                return values;
            })();

            /**
             * OledType enum.
             * @name meshtastic.Config.DisplayConfig.OledType
             * @enum {number}
             * @property {number} OLED_AUTO=0 OLED_AUTO value
             * @property {number} OLED_SSD1306=1 OLED_SSD1306 value
             * @property {number} OLED_SH1106=2 OLED_SH1106 value
             * @property {number} OLED_SH1107=3 OLED_SH1107 value
             * @property {number} OLED_SH1107_128_128=4 OLED_SH1107_128_128 value
             */
            DisplayConfig.OledType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OLED_AUTO"] = 0;
                values[valuesById[1] = "OLED_SSD1306"] = 1;
                values[valuesById[2] = "OLED_SH1106"] = 2;
                values[valuesById[3] = "OLED_SH1107"] = 3;
                values[valuesById[4] = "OLED_SH1107_128_128"] = 4;
                return values;
            })();

            /**
             * DisplayMode enum.
             * @name meshtastic.Config.DisplayConfig.DisplayMode
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} TWOCOLOR=1 TWOCOLOR value
             * @property {number} INVERTED=2 INVERTED value
             * @property {number} COLOR=3 COLOR value
             */
            DisplayConfig.DisplayMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "TWOCOLOR"] = 1;
                values[valuesById[2] = "INVERTED"] = 2;
                values[valuesById[3] = "COLOR"] = 3;
                return values;
            })();

            /**
             * CompassOrientation enum.
             * @name meshtastic.Config.DisplayConfig.CompassOrientation
             * @enum {number}
             * @property {number} DEGREES_0=0 DEGREES_0 value
             * @property {number} DEGREES_90=1 DEGREES_90 value
             * @property {number} DEGREES_180=2 DEGREES_180 value
             * @property {number} DEGREES_270=3 DEGREES_270 value
             * @property {number} DEGREES_0_INVERTED=4 DEGREES_0_INVERTED value
             * @property {number} DEGREES_90_INVERTED=5 DEGREES_90_INVERTED value
             * @property {number} DEGREES_180_INVERTED=6 DEGREES_180_INVERTED value
             * @property {number} DEGREES_270_INVERTED=7 DEGREES_270_INVERTED value
             */
            DisplayConfig.CompassOrientation = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEGREES_0"] = 0;
                values[valuesById[1] = "DEGREES_90"] = 1;
                values[valuesById[2] = "DEGREES_180"] = 2;
                values[valuesById[3] = "DEGREES_270"] = 3;
                values[valuesById[4] = "DEGREES_0_INVERTED"] = 4;
                values[valuesById[5] = "DEGREES_90_INVERTED"] = 5;
                values[valuesById[6] = "DEGREES_180_INVERTED"] = 6;
                values[valuesById[7] = "DEGREES_270_INVERTED"] = 7;
                return values;
            })();

            return DisplayConfig;
        })();

        Config.LoRaConfig = (function() {

            /**
             * Properties of a LoRaConfig.
             * @memberof meshtastic.Config
             * @interface ILoRaConfig
             * @property {boolean|null} [usePreset] LoRaConfig usePreset
             * @property {meshtastic.Config.LoRaConfig.ModemPreset|null} [modemPreset] LoRaConfig modemPreset
             * @property {number|null} [bandwidth] LoRaConfig bandwidth
             * @property {number|null} [spreadFactor] LoRaConfig spreadFactor
             * @property {number|null} [codingRate] LoRaConfig codingRate
             * @property {number|null} [frequencyOffset] LoRaConfig frequencyOffset
             * @property {meshtastic.Config.LoRaConfig.RegionCode|null} [region] LoRaConfig region
             * @property {number|null} [hopLimit] LoRaConfig hopLimit
             * @property {boolean|null} [txEnabled] LoRaConfig txEnabled
             * @property {number|null} [txPower] LoRaConfig txPower
             * @property {number|null} [channelNum] LoRaConfig channelNum
             * @property {boolean|null} [overrideDutyCycle] LoRaConfig overrideDutyCycle
             * @property {boolean|null} [sx126xRxBoostedGain] LoRaConfig sx126xRxBoostedGain
             * @property {number|null} [overrideFrequency] LoRaConfig overrideFrequency
             * @property {boolean|null} [paFanDisabled] LoRaConfig paFanDisabled
             * @property {Array.<number>|null} [ignoreIncoming] LoRaConfig ignoreIncoming
             * @property {boolean|null} [ignoreMqtt] LoRaConfig ignoreMqtt
             * @property {boolean|null} [configOkToMqtt] LoRaConfig configOkToMqtt
             */

            /**
             * Constructs a new LoRaConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a LoRaConfig.
             * @implements ILoRaConfig
             * @constructor
             * @param {meshtastic.Config.ILoRaConfig=} [properties] Properties to set
             */
            function LoRaConfig(properties) {
                this.ignoreIncoming = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoRaConfig usePreset.
             * @member {boolean} usePreset
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.usePreset = false;

            /**
             * LoRaConfig modemPreset.
             * @member {meshtastic.Config.LoRaConfig.ModemPreset} modemPreset
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.modemPreset = 0;

            /**
             * LoRaConfig bandwidth.
             * @member {number} bandwidth
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.bandwidth = 0;

            /**
             * LoRaConfig spreadFactor.
             * @member {number} spreadFactor
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.spreadFactor = 0;

            /**
             * LoRaConfig codingRate.
             * @member {number} codingRate
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.codingRate = 0;

            /**
             * LoRaConfig frequencyOffset.
             * @member {number} frequencyOffset
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.frequencyOffset = 0;

            /**
             * LoRaConfig region.
             * @member {meshtastic.Config.LoRaConfig.RegionCode} region
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.region = 0;

            /**
             * LoRaConfig hopLimit.
             * @member {number} hopLimit
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.hopLimit = 0;

            /**
             * LoRaConfig txEnabled.
             * @member {boolean} txEnabled
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.txEnabled = false;

            /**
             * LoRaConfig txPower.
             * @member {number} txPower
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.txPower = 0;

            /**
             * LoRaConfig channelNum.
             * @member {number} channelNum
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.channelNum = 0;

            /**
             * LoRaConfig overrideDutyCycle.
             * @member {boolean} overrideDutyCycle
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.overrideDutyCycle = false;

            /**
             * LoRaConfig sx126xRxBoostedGain.
             * @member {boolean} sx126xRxBoostedGain
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.sx126xRxBoostedGain = false;

            /**
             * LoRaConfig overrideFrequency.
             * @member {number} overrideFrequency
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.overrideFrequency = 0;

            /**
             * LoRaConfig paFanDisabled.
             * @member {boolean} paFanDisabled
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.paFanDisabled = false;

            /**
             * LoRaConfig ignoreIncoming.
             * @member {Array.<number>} ignoreIncoming
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.ignoreIncoming = $util.emptyArray;

            /**
             * LoRaConfig ignoreMqtt.
             * @member {boolean} ignoreMqtt
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.ignoreMqtt = false;

            /**
             * LoRaConfig configOkToMqtt.
             * @member {boolean} configOkToMqtt
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             */
            LoRaConfig.prototype.configOkToMqtt = false;

            /**
             * Creates a new LoRaConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {meshtastic.Config.ILoRaConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.LoRaConfig} LoRaConfig instance
             */
            LoRaConfig.create = function create(properties) {
                return new LoRaConfig(properties);
            };

            /**
             * Encodes the specified LoRaConfig message. Does not implicitly {@link meshtastic.Config.LoRaConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {meshtastic.Config.ILoRaConfig} message LoRaConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoRaConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.usePreset != null && Object.hasOwnProperty.call(message, "usePreset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.usePreset);
                if (message.modemPreset != null && Object.hasOwnProperty.call(message, "modemPreset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.modemPreset);
                if (message.bandwidth != null && Object.hasOwnProperty.call(message, "bandwidth"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.bandwidth);
                if (message.spreadFactor != null && Object.hasOwnProperty.call(message, "spreadFactor"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.spreadFactor);
                if (message.codingRate != null && Object.hasOwnProperty.call(message, "codingRate"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.codingRate);
                if (message.frequencyOffset != null && Object.hasOwnProperty.call(message, "frequencyOffset"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.frequencyOffset);
                if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.region);
                if (message.hopLimit != null && Object.hasOwnProperty.call(message, "hopLimit"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.hopLimit);
                if (message.txEnabled != null && Object.hasOwnProperty.call(message, "txEnabled"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.txEnabled);
                if (message.txPower != null && Object.hasOwnProperty.call(message, "txPower"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.txPower);
                if (message.channelNum != null && Object.hasOwnProperty.call(message, "channelNum"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.channelNum);
                if (message.overrideDutyCycle != null && Object.hasOwnProperty.call(message, "overrideDutyCycle"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.overrideDutyCycle);
                if (message.sx126xRxBoostedGain != null && Object.hasOwnProperty.call(message, "sx126xRxBoostedGain"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.sx126xRxBoostedGain);
                if (message.overrideFrequency != null && Object.hasOwnProperty.call(message, "overrideFrequency"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.overrideFrequency);
                if (message.paFanDisabled != null && Object.hasOwnProperty.call(message, "paFanDisabled"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.paFanDisabled);
                if (message.ignoreIncoming != null && message.ignoreIncoming.length) {
                    writer.uint32(/* id 103, wireType 2 =*/826).fork();
                    for (var i = 0; i < message.ignoreIncoming.length; ++i)
                        writer.uint32(message.ignoreIncoming[i]);
                    writer.ldelim();
                }
                if (message.ignoreMqtt != null && Object.hasOwnProperty.call(message, "ignoreMqtt"))
                    writer.uint32(/* id 104, wireType 0 =*/832).bool(message.ignoreMqtt);
                if (message.configOkToMqtt != null && Object.hasOwnProperty.call(message, "configOkToMqtt"))
                    writer.uint32(/* id 105, wireType 0 =*/840).bool(message.configOkToMqtt);
                return writer;
            };

            /**
             * Encodes the specified LoRaConfig message, length delimited. Does not implicitly {@link meshtastic.Config.LoRaConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {meshtastic.Config.ILoRaConfig} message LoRaConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoRaConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoRaConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.LoRaConfig} LoRaConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoRaConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.LoRaConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.usePreset = reader.bool();
                            break;
                        }
                    case 2: {
                            message.modemPreset = reader.int32();
                            break;
                        }
                    case 3: {
                            message.bandwidth = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.spreadFactor = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.codingRate = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.frequencyOffset = reader.float();
                            break;
                        }
                    case 7: {
                            message.region = reader.int32();
                            break;
                        }
                    case 8: {
                            message.hopLimit = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.txEnabled = reader.bool();
                            break;
                        }
                    case 10: {
                            message.txPower = reader.int32();
                            break;
                        }
                    case 11: {
                            message.channelNum = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.overrideDutyCycle = reader.bool();
                            break;
                        }
                    case 13: {
                            message.sx126xRxBoostedGain = reader.bool();
                            break;
                        }
                    case 14: {
                            message.overrideFrequency = reader.float();
                            break;
                        }
                    case 15: {
                            message.paFanDisabled = reader.bool();
                            break;
                        }
                    case 103: {
                            if (!(message.ignoreIncoming && message.ignoreIncoming.length))
                                message.ignoreIncoming = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.ignoreIncoming.push(reader.uint32());
                            } else
                                message.ignoreIncoming.push(reader.uint32());
                            break;
                        }
                    case 104: {
                            message.ignoreMqtt = reader.bool();
                            break;
                        }
                    case 105: {
                            message.configOkToMqtt = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoRaConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.LoRaConfig} LoRaConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoRaConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoRaConfig message.
             * @function verify
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoRaConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.usePreset != null && message.hasOwnProperty("usePreset"))
                    if (typeof message.usePreset !== "boolean")
                        return "usePreset: boolean expected";
                if (message.modemPreset != null && message.hasOwnProperty("modemPreset"))
                    switch (message.modemPreset) {
                    default:
                        return "modemPreset: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.bandwidth != null && message.hasOwnProperty("bandwidth"))
                    if (!$util.isInteger(message.bandwidth))
                        return "bandwidth: integer expected";
                if (message.spreadFactor != null && message.hasOwnProperty("spreadFactor"))
                    if (!$util.isInteger(message.spreadFactor))
                        return "spreadFactor: integer expected";
                if (message.codingRate != null && message.hasOwnProperty("codingRate"))
                    if (!$util.isInteger(message.codingRate))
                        return "codingRate: integer expected";
                if (message.frequencyOffset != null && message.hasOwnProperty("frequencyOffset"))
                    if (typeof message.frequencyOffset !== "number")
                        return "frequencyOffset: number expected";
                if (message.region != null && message.hasOwnProperty("region"))
                    switch (message.region) {
                    default:
                        return "region: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                        break;
                    }
                if (message.hopLimit != null && message.hasOwnProperty("hopLimit"))
                    if (!$util.isInteger(message.hopLimit))
                        return "hopLimit: integer expected";
                if (message.txEnabled != null && message.hasOwnProperty("txEnabled"))
                    if (typeof message.txEnabled !== "boolean")
                        return "txEnabled: boolean expected";
                if (message.txPower != null && message.hasOwnProperty("txPower"))
                    if (!$util.isInteger(message.txPower))
                        return "txPower: integer expected";
                if (message.channelNum != null && message.hasOwnProperty("channelNum"))
                    if (!$util.isInteger(message.channelNum))
                        return "channelNum: integer expected";
                if (message.overrideDutyCycle != null && message.hasOwnProperty("overrideDutyCycle"))
                    if (typeof message.overrideDutyCycle !== "boolean")
                        return "overrideDutyCycle: boolean expected";
                if (message.sx126xRxBoostedGain != null && message.hasOwnProperty("sx126xRxBoostedGain"))
                    if (typeof message.sx126xRxBoostedGain !== "boolean")
                        return "sx126xRxBoostedGain: boolean expected";
                if (message.overrideFrequency != null && message.hasOwnProperty("overrideFrequency"))
                    if (typeof message.overrideFrequency !== "number")
                        return "overrideFrequency: number expected";
                if (message.paFanDisabled != null && message.hasOwnProperty("paFanDisabled"))
                    if (typeof message.paFanDisabled !== "boolean")
                        return "paFanDisabled: boolean expected";
                if (message.ignoreIncoming != null && message.hasOwnProperty("ignoreIncoming")) {
                    if (!Array.isArray(message.ignoreIncoming))
                        return "ignoreIncoming: array expected";
                    for (var i = 0; i < message.ignoreIncoming.length; ++i)
                        if (!$util.isInteger(message.ignoreIncoming[i]))
                            return "ignoreIncoming: integer[] expected";
                }
                if (message.ignoreMqtt != null && message.hasOwnProperty("ignoreMqtt"))
                    if (typeof message.ignoreMqtt !== "boolean")
                        return "ignoreMqtt: boolean expected";
                if (message.configOkToMqtt != null && message.hasOwnProperty("configOkToMqtt"))
                    if (typeof message.configOkToMqtt !== "boolean")
                        return "configOkToMqtt: boolean expected";
                return null;
            };

            /**
             * Creates a LoRaConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.LoRaConfig} LoRaConfig
             */
            LoRaConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.LoRaConfig)
                    return object;
                var message = new $root.meshtastic.Config.LoRaConfig();
                if (object.usePreset != null)
                    message.usePreset = Boolean(object.usePreset);
                switch (object.modemPreset) {
                default:
                    if (typeof object.modemPreset === "number") {
                        message.modemPreset = object.modemPreset;
                        break;
                    }
                    break;
                case "LONG_FAST":
                case 0:
                    message.modemPreset = 0;
                    break;
                case "LONG_SLOW":
                case 1:
                    message.modemPreset = 1;
                    break;
                case "VERY_LONG_SLOW":
                case 2:
                    message.modemPreset = 2;
                    break;
                case "MEDIUM_SLOW":
                case 3:
                    message.modemPreset = 3;
                    break;
                case "MEDIUM_FAST":
                case 4:
                    message.modemPreset = 4;
                    break;
                case "SHORT_SLOW":
                case 5:
                    message.modemPreset = 5;
                    break;
                case "SHORT_FAST":
                case 6:
                    message.modemPreset = 6;
                    break;
                case "LONG_MODERATE":
                case 7:
                    message.modemPreset = 7;
                    break;
                case "SHORT_TURBO":
                case 8:
                    message.modemPreset = 8;
                    break;
                }
                if (object.bandwidth != null)
                    message.bandwidth = object.bandwidth >>> 0;
                if (object.spreadFactor != null)
                    message.spreadFactor = object.spreadFactor >>> 0;
                if (object.codingRate != null)
                    message.codingRate = object.codingRate >>> 0;
                if (object.frequencyOffset != null)
                    message.frequencyOffset = Number(object.frequencyOffset);
                switch (object.region) {
                default:
                    if (typeof object.region === "number") {
                        message.region = object.region;
                        break;
                    }
                    break;
                case "UNSET":
                case 0:
                    message.region = 0;
                    break;
                case "US":
                case 1:
                    message.region = 1;
                    break;
                case "EU_433":
                case 2:
                    message.region = 2;
                    break;
                case "EU_868":
                case 3:
                    message.region = 3;
                    break;
                case "CN":
                case 4:
                    message.region = 4;
                    break;
                case "JP":
                case 5:
                    message.region = 5;
                    break;
                case "ANZ":
                case 6:
                    message.region = 6;
                    break;
                case "KR":
                case 7:
                    message.region = 7;
                    break;
                case "TW":
                case 8:
                    message.region = 8;
                    break;
                case "RU":
                case 9:
                    message.region = 9;
                    break;
                case "IN":
                case 10:
                    message.region = 10;
                    break;
                case "NZ_865":
                case 11:
                    message.region = 11;
                    break;
                case "TH":
                case 12:
                    message.region = 12;
                    break;
                case "LORA_24":
                case 13:
                    message.region = 13;
                    break;
                case "UA_433":
                case 14:
                    message.region = 14;
                    break;
                case "UA_868":
                case 15:
                    message.region = 15;
                    break;
                case "MY_433":
                case 16:
                    message.region = 16;
                    break;
                case "MY_919":
                case 17:
                    message.region = 17;
                    break;
                case "SG_923":
                case 18:
                    message.region = 18;
                    break;
                case "PH_433":
                case 19:
                    message.region = 19;
                    break;
                case "PH_868":
                case 20:
                    message.region = 20;
                    break;
                case "PH_915":
                case 21:
                    message.region = 21;
                    break;
                case "ANZ_433":
                case 22:
                    message.region = 22;
                    break;
                case "KZ_433":
                case 23:
                    message.region = 23;
                    break;
                case "KZ_863":
                case 24:
                    message.region = 24;
                    break;
                case "NP_865":
                case 25:
                    message.region = 25;
                    break;
                case "BR_902":
                case 26:
                    message.region = 26;
                    break;
                }
                if (object.hopLimit != null)
                    message.hopLimit = object.hopLimit >>> 0;
                if (object.txEnabled != null)
                    message.txEnabled = Boolean(object.txEnabled);
                if (object.txPower != null)
                    message.txPower = object.txPower | 0;
                if (object.channelNum != null)
                    message.channelNum = object.channelNum >>> 0;
                if (object.overrideDutyCycle != null)
                    message.overrideDutyCycle = Boolean(object.overrideDutyCycle);
                if (object.sx126xRxBoostedGain != null)
                    message.sx126xRxBoostedGain = Boolean(object.sx126xRxBoostedGain);
                if (object.overrideFrequency != null)
                    message.overrideFrequency = Number(object.overrideFrequency);
                if (object.paFanDisabled != null)
                    message.paFanDisabled = Boolean(object.paFanDisabled);
                if (object.ignoreIncoming) {
                    if (!Array.isArray(object.ignoreIncoming))
                        throw TypeError(".meshtastic.Config.LoRaConfig.ignoreIncoming: array expected");
                    message.ignoreIncoming = [];
                    for (var i = 0; i < object.ignoreIncoming.length; ++i)
                        message.ignoreIncoming[i] = object.ignoreIncoming[i] >>> 0;
                }
                if (object.ignoreMqtt != null)
                    message.ignoreMqtt = Boolean(object.ignoreMqtt);
                if (object.configOkToMqtt != null)
                    message.configOkToMqtt = Boolean(object.configOkToMqtt);
                return message;
            };

            /**
             * Creates a plain object from a LoRaConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {meshtastic.Config.LoRaConfig} message LoRaConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoRaConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ignoreIncoming = [];
                if (options.defaults) {
                    object.usePreset = false;
                    object.modemPreset = options.enums === String ? "LONG_FAST" : 0;
                    object.bandwidth = 0;
                    object.spreadFactor = 0;
                    object.codingRate = 0;
                    object.frequencyOffset = 0;
                    object.region = options.enums === String ? "UNSET" : 0;
                    object.hopLimit = 0;
                    object.txEnabled = false;
                    object.txPower = 0;
                    object.channelNum = 0;
                    object.overrideDutyCycle = false;
                    object.sx126xRxBoostedGain = false;
                    object.overrideFrequency = 0;
                    object.paFanDisabled = false;
                    object.ignoreMqtt = false;
                    object.configOkToMqtt = false;
                }
                if (message.usePreset != null && message.hasOwnProperty("usePreset"))
                    object.usePreset = message.usePreset;
                if (message.modemPreset != null && message.hasOwnProperty("modemPreset"))
                    object.modemPreset = options.enums === String ? $root.meshtastic.Config.LoRaConfig.ModemPreset[message.modemPreset] === undefined ? message.modemPreset : $root.meshtastic.Config.LoRaConfig.ModemPreset[message.modemPreset] : message.modemPreset;
                if (message.bandwidth != null && message.hasOwnProperty("bandwidth"))
                    object.bandwidth = message.bandwidth;
                if (message.spreadFactor != null && message.hasOwnProperty("spreadFactor"))
                    object.spreadFactor = message.spreadFactor;
                if (message.codingRate != null && message.hasOwnProperty("codingRate"))
                    object.codingRate = message.codingRate;
                if (message.frequencyOffset != null && message.hasOwnProperty("frequencyOffset"))
                    object.frequencyOffset = options.json && !isFinite(message.frequencyOffset) ? String(message.frequencyOffset) : message.frequencyOffset;
                if (message.region != null && message.hasOwnProperty("region"))
                    object.region = options.enums === String ? $root.meshtastic.Config.LoRaConfig.RegionCode[message.region] === undefined ? message.region : $root.meshtastic.Config.LoRaConfig.RegionCode[message.region] : message.region;
                if (message.hopLimit != null && message.hasOwnProperty("hopLimit"))
                    object.hopLimit = message.hopLimit;
                if (message.txEnabled != null && message.hasOwnProperty("txEnabled"))
                    object.txEnabled = message.txEnabled;
                if (message.txPower != null && message.hasOwnProperty("txPower"))
                    object.txPower = message.txPower;
                if (message.channelNum != null && message.hasOwnProperty("channelNum"))
                    object.channelNum = message.channelNum;
                if (message.overrideDutyCycle != null && message.hasOwnProperty("overrideDutyCycle"))
                    object.overrideDutyCycle = message.overrideDutyCycle;
                if (message.sx126xRxBoostedGain != null && message.hasOwnProperty("sx126xRxBoostedGain"))
                    object.sx126xRxBoostedGain = message.sx126xRxBoostedGain;
                if (message.overrideFrequency != null && message.hasOwnProperty("overrideFrequency"))
                    object.overrideFrequency = options.json && !isFinite(message.overrideFrequency) ? String(message.overrideFrequency) : message.overrideFrequency;
                if (message.paFanDisabled != null && message.hasOwnProperty("paFanDisabled"))
                    object.paFanDisabled = message.paFanDisabled;
                if (message.ignoreIncoming && message.ignoreIncoming.length) {
                    object.ignoreIncoming = [];
                    for (var j = 0; j < message.ignoreIncoming.length; ++j)
                        object.ignoreIncoming[j] = message.ignoreIncoming[j];
                }
                if (message.ignoreMqtt != null && message.hasOwnProperty("ignoreMqtt"))
                    object.ignoreMqtt = message.ignoreMqtt;
                if (message.configOkToMqtt != null && message.hasOwnProperty("configOkToMqtt"))
                    object.configOkToMqtt = message.configOkToMqtt;
                return object;
            };

            /**
             * Converts this LoRaConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.LoRaConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoRaConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoRaConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.LoRaConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoRaConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.LoRaConfig";
            };

            /**
             * RegionCode enum.
             * @name meshtastic.Config.LoRaConfig.RegionCode
             * @enum {number}
             * @property {number} UNSET=0 UNSET value
             * @property {number} US=1 US value
             * @property {number} EU_433=2 EU_433 value
             * @property {number} EU_868=3 EU_868 value
             * @property {number} CN=4 CN value
             * @property {number} JP=5 JP value
             * @property {number} ANZ=6 ANZ value
             * @property {number} KR=7 KR value
             * @property {number} TW=8 TW value
             * @property {number} RU=9 RU value
             * @property {number} IN=10 IN value
             * @property {number} NZ_865=11 NZ_865 value
             * @property {number} TH=12 TH value
             * @property {number} LORA_24=13 LORA_24 value
             * @property {number} UA_433=14 UA_433 value
             * @property {number} UA_868=15 UA_868 value
             * @property {number} MY_433=16 MY_433 value
             * @property {number} MY_919=17 MY_919 value
             * @property {number} SG_923=18 SG_923 value
             * @property {number} PH_433=19 PH_433 value
             * @property {number} PH_868=20 PH_868 value
             * @property {number} PH_915=21 PH_915 value
             * @property {number} ANZ_433=22 ANZ_433 value
             * @property {number} KZ_433=23 KZ_433 value
             * @property {number} KZ_863=24 KZ_863 value
             * @property {number} NP_865=25 NP_865 value
             * @property {number} BR_902=26 BR_902 value
             */
            LoRaConfig.RegionCode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSET"] = 0;
                values[valuesById[1] = "US"] = 1;
                values[valuesById[2] = "EU_433"] = 2;
                values[valuesById[3] = "EU_868"] = 3;
                values[valuesById[4] = "CN"] = 4;
                values[valuesById[5] = "JP"] = 5;
                values[valuesById[6] = "ANZ"] = 6;
                values[valuesById[7] = "KR"] = 7;
                values[valuesById[8] = "TW"] = 8;
                values[valuesById[9] = "RU"] = 9;
                values[valuesById[10] = "IN"] = 10;
                values[valuesById[11] = "NZ_865"] = 11;
                values[valuesById[12] = "TH"] = 12;
                values[valuesById[13] = "LORA_24"] = 13;
                values[valuesById[14] = "UA_433"] = 14;
                values[valuesById[15] = "UA_868"] = 15;
                values[valuesById[16] = "MY_433"] = 16;
                values[valuesById[17] = "MY_919"] = 17;
                values[valuesById[18] = "SG_923"] = 18;
                values[valuesById[19] = "PH_433"] = 19;
                values[valuesById[20] = "PH_868"] = 20;
                values[valuesById[21] = "PH_915"] = 21;
                values[valuesById[22] = "ANZ_433"] = 22;
                values[valuesById[23] = "KZ_433"] = 23;
                values[valuesById[24] = "KZ_863"] = 24;
                values[valuesById[25] = "NP_865"] = 25;
                values[valuesById[26] = "BR_902"] = 26;
                return values;
            })();

            /**
             * ModemPreset enum.
             * @name meshtastic.Config.LoRaConfig.ModemPreset
             * @enum {number}
             * @property {number} LONG_FAST=0 LONG_FAST value
             * @property {number} LONG_SLOW=1 LONG_SLOW value
             * @property {number} VERY_LONG_SLOW=2 VERY_LONG_SLOW value
             * @property {number} MEDIUM_SLOW=3 MEDIUM_SLOW value
             * @property {number} MEDIUM_FAST=4 MEDIUM_FAST value
             * @property {number} SHORT_SLOW=5 SHORT_SLOW value
             * @property {number} SHORT_FAST=6 SHORT_FAST value
             * @property {number} LONG_MODERATE=7 LONG_MODERATE value
             * @property {number} SHORT_TURBO=8 SHORT_TURBO value
             */
            LoRaConfig.ModemPreset = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LONG_FAST"] = 0;
                values[valuesById[1] = "LONG_SLOW"] = 1;
                values[valuesById[2] = "VERY_LONG_SLOW"] = 2;
                values[valuesById[3] = "MEDIUM_SLOW"] = 3;
                values[valuesById[4] = "MEDIUM_FAST"] = 4;
                values[valuesById[5] = "SHORT_SLOW"] = 5;
                values[valuesById[6] = "SHORT_FAST"] = 6;
                values[valuesById[7] = "LONG_MODERATE"] = 7;
                values[valuesById[8] = "SHORT_TURBO"] = 8;
                return values;
            })();

            return LoRaConfig;
        })();

        Config.BluetoothConfig = (function() {

            /**
             * Properties of a BluetoothConfig.
             * @memberof meshtastic.Config
             * @interface IBluetoothConfig
             * @property {boolean|null} [enabled] BluetoothConfig enabled
             * @property {meshtastic.Config.BluetoothConfig.PairingMode|null} [mode] BluetoothConfig mode
             * @property {number|null} [fixedPin] BluetoothConfig fixedPin
             */

            /**
             * Constructs a new BluetoothConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a BluetoothConfig.
             * @implements IBluetoothConfig
             * @constructor
             * @param {meshtastic.Config.IBluetoothConfig=} [properties] Properties to set
             */
            function BluetoothConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BluetoothConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.Config.BluetoothConfig
             * @instance
             */
            BluetoothConfig.prototype.enabled = false;

            /**
             * BluetoothConfig mode.
             * @member {meshtastic.Config.BluetoothConfig.PairingMode} mode
             * @memberof meshtastic.Config.BluetoothConfig
             * @instance
             */
            BluetoothConfig.prototype.mode = 0;

            /**
             * BluetoothConfig fixedPin.
             * @member {number} fixedPin
             * @memberof meshtastic.Config.BluetoothConfig
             * @instance
             */
            BluetoothConfig.prototype.fixedPin = 0;

            /**
             * Creates a new BluetoothConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {meshtastic.Config.IBluetoothConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.BluetoothConfig} BluetoothConfig instance
             */
            BluetoothConfig.create = function create(properties) {
                return new BluetoothConfig(properties);
            };

            /**
             * Encodes the specified BluetoothConfig message. Does not implicitly {@link meshtastic.Config.BluetoothConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {meshtastic.Config.IBluetoothConfig} message BluetoothConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BluetoothConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
                if (message.fixedPin != null && Object.hasOwnProperty.call(message, "fixedPin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.fixedPin);
                return writer;
            };

            /**
             * Encodes the specified BluetoothConfig message, length delimited. Does not implicitly {@link meshtastic.Config.BluetoothConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {meshtastic.Config.IBluetoothConfig} message BluetoothConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BluetoothConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BluetoothConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.BluetoothConfig} BluetoothConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BluetoothConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.BluetoothConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.mode = reader.int32();
                            break;
                        }
                    case 3: {
                            message.fixedPin = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BluetoothConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.BluetoothConfig} BluetoothConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BluetoothConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BluetoothConfig message.
             * @function verify
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BluetoothConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.fixedPin != null && message.hasOwnProperty("fixedPin"))
                    if (!$util.isInteger(message.fixedPin))
                        return "fixedPin: integer expected";
                return null;
            };

            /**
             * Creates a BluetoothConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.BluetoothConfig} BluetoothConfig
             */
            BluetoothConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.BluetoothConfig)
                    return object;
                var message = new $root.meshtastic.Config.BluetoothConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "RANDOM_PIN":
                case 0:
                    message.mode = 0;
                    break;
                case "FIXED_PIN":
                case 1:
                    message.mode = 1;
                    break;
                case "NO_PIN":
                case 2:
                    message.mode = 2;
                    break;
                }
                if (object.fixedPin != null)
                    message.fixedPin = object.fixedPin >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BluetoothConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {meshtastic.Config.BluetoothConfig} message BluetoothConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BluetoothConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.mode = options.enums === String ? "RANDOM_PIN" : 0;
                    object.fixedPin = 0;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.meshtastic.Config.BluetoothConfig.PairingMode[message.mode] === undefined ? message.mode : $root.meshtastic.Config.BluetoothConfig.PairingMode[message.mode] : message.mode;
                if (message.fixedPin != null && message.hasOwnProperty("fixedPin"))
                    object.fixedPin = message.fixedPin;
                return object;
            };

            /**
             * Converts this BluetoothConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.BluetoothConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BluetoothConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BluetoothConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.BluetoothConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BluetoothConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.BluetoothConfig";
            };

            /**
             * PairingMode enum.
             * @name meshtastic.Config.BluetoothConfig.PairingMode
             * @enum {number}
             * @property {number} RANDOM_PIN=0 RANDOM_PIN value
             * @property {number} FIXED_PIN=1 FIXED_PIN value
             * @property {number} NO_PIN=2 NO_PIN value
             */
            BluetoothConfig.PairingMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RANDOM_PIN"] = 0;
                values[valuesById[1] = "FIXED_PIN"] = 1;
                values[valuesById[2] = "NO_PIN"] = 2;
                return values;
            })();

            return BluetoothConfig;
        })();

        Config.SecurityConfig = (function() {

            /**
             * Properties of a SecurityConfig.
             * @memberof meshtastic.Config
             * @interface ISecurityConfig
             * @property {Uint8Array|null} [publicKey] SecurityConfig publicKey
             * @property {Uint8Array|null} [privateKey] SecurityConfig privateKey
             * @property {Array.<Uint8Array>|null} [adminKey] SecurityConfig adminKey
             * @property {boolean|null} [isManaged] SecurityConfig isManaged
             * @property {boolean|null} [serialEnabled] SecurityConfig serialEnabled
             * @property {boolean|null} [debugLogApiEnabled] SecurityConfig debugLogApiEnabled
             * @property {boolean|null} [adminChannelEnabled] SecurityConfig adminChannelEnabled
             */

            /**
             * Constructs a new SecurityConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a SecurityConfig.
             * @implements ISecurityConfig
             * @constructor
             * @param {meshtastic.Config.ISecurityConfig=} [properties] Properties to set
             */
            function SecurityConfig(properties) {
                this.adminKey = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SecurityConfig publicKey.
             * @member {Uint8Array} publicKey
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.publicKey = $util.newBuffer([]);

            /**
             * SecurityConfig privateKey.
             * @member {Uint8Array} privateKey
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.privateKey = $util.newBuffer([]);

            /**
             * SecurityConfig adminKey.
             * @member {Array.<Uint8Array>} adminKey
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.adminKey = $util.emptyArray;

            /**
             * SecurityConfig isManaged.
             * @member {boolean} isManaged
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.isManaged = false;

            /**
             * SecurityConfig serialEnabled.
             * @member {boolean} serialEnabled
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.serialEnabled = false;

            /**
             * SecurityConfig debugLogApiEnabled.
             * @member {boolean} debugLogApiEnabled
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.debugLogApiEnabled = false;

            /**
             * SecurityConfig adminChannelEnabled.
             * @member {boolean} adminChannelEnabled
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             */
            SecurityConfig.prototype.adminChannelEnabled = false;

            /**
             * Creates a new SecurityConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {meshtastic.Config.ISecurityConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.SecurityConfig} SecurityConfig instance
             */
            SecurityConfig.create = function create(properties) {
                return new SecurityConfig(properties);
            };

            /**
             * Encodes the specified SecurityConfig message. Does not implicitly {@link meshtastic.Config.SecurityConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {meshtastic.Config.ISecurityConfig} message SecurityConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecurityConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicKey);
                if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
                if (message.adminKey != null && message.adminKey.length)
                    for (var i = 0; i < message.adminKey.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.adminKey[i]);
                if (message.isManaged != null && Object.hasOwnProperty.call(message, "isManaged"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isManaged);
                if (message.serialEnabled != null && Object.hasOwnProperty.call(message, "serialEnabled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.serialEnabled);
                if (message.debugLogApiEnabled != null && Object.hasOwnProperty.call(message, "debugLogApiEnabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.debugLogApiEnabled);
                if (message.adminChannelEnabled != null && Object.hasOwnProperty.call(message, "adminChannelEnabled"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.adminChannelEnabled);
                return writer;
            };

            /**
             * Encodes the specified SecurityConfig message, length delimited. Does not implicitly {@link meshtastic.Config.SecurityConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {meshtastic.Config.ISecurityConfig} message SecurityConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecurityConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SecurityConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.SecurityConfig} SecurityConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecurityConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.SecurityConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.publicKey = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.privateKey = reader.bytes();
                            break;
                        }
                    case 3: {
                            if (!(message.adminKey && message.adminKey.length))
                                message.adminKey = [];
                            message.adminKey.push(reader.bytes());
                            break;
                        }
                    case 4: {
                            message.isManaged = reader.bool();
                            break;
                        }
                    case 5: {
                            message.serialEnabled = reader.bool();
                            break;
                        }
                    case 6: {
                            message.debugLogApiEnabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.adminChannelEnabled = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SecurityConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.SecurityConfig} SecurityConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecurityConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SecurityConfig message.
             * @function verify
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecurityConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                        return "publicKey: buffer expected";
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                        return "privateKey: buffer expected";
                if (message.adminKey != null && message.hasOwnProperty("adminKey")) {
                    if (!Array.isArray(message.adminKey))
                        return "adminKey: array expected";
                    for (var i = 0; i < message.adminKey.length; ++i)
                        if (!(message.adminKey[i] && typeof message.adminKey[i].length === "number" || $util.isString(message.adminKey[i])))
                            return "adminKey: buffer[] expected";
                }
                if (message.isManaged != null && message.hasOwnProperty("isManaged"))
                    if (typeof message.isManaged !== "boolean")
                        return "isManaged: boolean expected";
                if (message.serialEnabled != null && message.hasOwnProperty("serialEnabled"))
                    if (typeof message.serialEnabled !== "boolean")
                        return "serialEnabled: boolean expected";
                if (message.debugLogApiEnabled != null && message.hasOwnProperty("debugLogApiEnabled"))
                    if (typeof message.debugLogApiEnabled !== "boolean")
                        return "debugLogApiEnabled: boolean expected";
                if (message.adminChannelEnabled != null && message.hasOwnProperty("adminChannelEnabled"))
                    if (typeof message.adminChannelEnabled !== "boolean")
                        return "adminChannelEnabled: boolean expected";
                return null;
            };

            /**
             * Creates a SecurityConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.SecurityConfig} SecurityConfig
             */
            SecurityConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.SecurityConfig)
                    return object;
                var message = new $root.meshtastic.Config.SecurityConfig();
                if (object.publicKey != null)
                    if (typeof object.publicKey === "string")
                        $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                    else if (object.publicKey.length >= 0)
                        message.publicKey = object.publicKey;
                if (object.privateKey != null)
                    if (typeof object.privateKey === "string")
                        $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                    else if (object.privateKey.length >= 0)
                        message.privateKey = object.privateKey;
                if (object.adminKey) {
                    if (!Array.isArray(object.adminKey))
                        throw TypeError(".meshtastic.Config.SecurityConfig.adminKey: array expected");
                    message.adminKey = [];
                    for (var i = 0; i < object.adminKey.length; ++i)
                        if (typeof object.adminKey[i] === "string")
                            $util.base64.decode(object.adminKey[i], message.adminKey[i] = $util.newBuffer($util.base64.length(object.adminKey[i])), 0);
                        else if (object.adminKey[i].length >= 0)
                            message.adminKey[i] = object.adminKey[i];
                }
                if (object.isManaged != null)
                    message.isManaged = Boolean(object.isManaged);
                if (object.serialEnabled != null)
                    message.serialEnabled = Boolean(object.serialEnabled);
                if (object.debugLogApiEnabled != null)
                    message.debugLogApiEnabled = Boolean(object.debugLogApiEnabled);
                if (object.adminChannelEnabled != null)
                    message.adminChannelEnabled = Boolean(object.adminChannelEnabled);
                return message;
            };

            /**
             * Creates a plain object from a SecurityConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {meshtastic.Config.SecurityConfig} message SecurityConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecurityConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.adminKey = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.publicKey = "";
                    else {
                        object.publicKey = [];
                        if (options.bytes !== Array)
                            object.publicKey = $util.newBuffer(object.publicKey);
                    }
                    if (options.bytes === String)
                        object.privateKey = "";
                    else {
                        object.privateKey = [];
                        if (options.bytes !== Array)
                            object.privateKey = $util.newBuffer(object.privateKey);
                    }
                    object.isManaged = false;
                    object.serialEnabled = false;
                    object.debugLogApiEnabled = false;
                    object.adminChannelEnabled = false;
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
                if (message.adminKey && message.adminKey.length) {
                    object.adminKey = [];
                    for (var j = 0; j < message.adminKey.length; ++j)
                        object.adminKey[j] = options.bytes === String ? $util.base64.encode(message.adminKey[j], 0, message.adminKey[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.adminKey[j]) : message.adminKey[j];
                }
                if (message.isManaged != null && message.hasOwnProperty("isManaged"))
                    object.isManaged = message.isManaged;
                if (message.serialEnabled != null && message.hasOwnProperty("serialEnabled"))
                    object.serialEnabled = message.serialEnabled;
                if (message.debugLogApiEnabled != null && message.hasOwnProperty("debugLogApiEnabled"))
                    object.debugLogApiEnabled = message.debugLogApiEnabled;
                if (message.adminChannelEnabled != null && message.hasOwnProperty("adminChannelEnabled"))
                    object.adminChannelEnabled = message.adminChannelEnabled;
                return object;
            };

            /**
             * Converts this SecurityConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.SecurityConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecurityConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SecurityConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.SecurityConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SecurityConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.SecurityConfig";
            };

            return SecurityConfig;
        })();

        Config.SessionkeyConfig = (function() {

            /**
             * Properties of a SessionkeyConfig.
             * @memberof meshtastic.Config
             * @interface ISessionkeyConfig
             */

            /**
             * Constructs a new SessionkeyConfig.
             * @memberof meshtastic.Config
             * @classdesc Represents a SessionkeyConfig.
             * @implements ISessionkeyConfig
             * @constructor
             * @param {meshtastic.Config.ISessionkeyConfig=} [properties] Properties to set
             */
            function SessionkeyConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SessionkeyConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {meshtastic.Config.ISessionkeyConfig=} [properties] Properties to set
             * @returns {meshtastic.Config.SessionkeyConfig} SessionkeyConfig instance
             */
            SessionkeyConfig.create = function create(properties) {
                return new SessionkeyConfig(properties);
            };

            /**
             * Encodes the specified SessionkeyConfig message. Does not implicitly {@link meshtastic.Config.SessionkeyConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {meshtastic.Config.ISessionkeyConfig} message SessionkeyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionkeyConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SessionkeyConfig message, length delimited. Does not implicitly {@link meshtastic.Config.SessionkeyConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {meshtastic.Config.ISessionkeyConfig} message SessionkeyConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SessionkeyConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SessionkeyConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.Config.SessionkeyConfig} SessionkeyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionkeyConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Config.SessionkeyConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SessionkeyConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.Config.SessionkeyConfig} SessionkeyConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SessionkeyConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SessionkeyConfig message.
             * @function verify
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SessionkeyConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SessionkeyConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.Config.SessionkeyConfig} SessionkeyConfig
             */
            SessionkeyConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.Config.SessionkeyConfig)
                    return object;
                return new $root.meshtastic.Config.SessionkeyConfig();
            };

            /**
             * Creates a plain object from a SessionkeyConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {meshtastic.Config.SessionkeyConfig} message SessionkeyConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SessionkeyConfig.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SessionkeyConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.Config.SessionkeyConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SessionkeyConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SessionkeyConfig
             * @function getTypeUrl
             * @memberof meshtastic.Config.SessionkeyConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SessionkeyConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.Config.SessionkeyConfig";
            };

            return SessionkeyConfig;
        })();

        return Config;
    })();

    meshtastic.DeviceUIConfig = (function() {

        /**
         * Properties of a DeviceUIConfig.
         * @memberof meshtastic
         * @interface IDeviceUIConfig
         * @property {number|null} [version] DeviceUIConfig version
         * @property {number|null} [screenBrightness] DeviceUIConfig screenBrightness
         * @property {number|null} [screenTimeout] DeviceUIConfig screenTimeout
         * @property {boolean|null} [screenLock] DeviceUIConfig screenLock
         * @property {boolean|null} [settingsLock] DeviceUIConfig settingsLock
         * @property {number|null} [pinCode] DeviceUIConfig pinCode
         * @property {meshtastic.Theme|null} [theme] DeviceUIConfig theme
         * @property {boolean|null} [alertEnabled] DeviceUIConfig alertEnabled
         * @property {boolean|null} [bannerEnabled] DeviceUIConfig bannerEnabled
         * @property {number|null} [ringToneId] DeviceUIConfig ringToneId
         * @property {meshtastic.Language|null} [language] DeviceUIConfig language
         * @property {meshtastic.INodeFilter|null} [nodeFilter] DeviceUIConfig nodeFilter
         * @property {meshtastic.INodeHighlight|null} [nodeHighlight] DeviceUIConfig nodeHighlight
         * @property {Uint8Array|null} [calibrationData] DeviceUIConfig calibrationData
         * @property {meshtastic.IMap|null} [mapData] DeviceUIConfig mapData
         * @property {meshtastic.CompassMode|null} [compassMode] DeviceUIConfig compassMode
         * @property {number|null} [screenRgbColor] DeviceUIConfig screenRgbColor
         * @property {boolean|null} [isClockfaceAnalog] DeviceUIConfig isClockfaceAnalog
         * @property {meshtastic.DeviceUIConfig.GpsCoordinateFormat|null} [gpsFormat] DeviceUIConfig gpsFormat
         */

        /**
         * Constructs a new DeviceUIConfig.
         * @memberof meshtastic
         * @classdesc Represents a DeviceUIConfig.
         * @implements IDeviceUIConfig
         * @constructor
         * @param {meshtastic.IDeviceUIConfig=} [properties] Properties to set
         */
        function DeviceUIConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceUIConfig version.
         * @member {number} version
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.version = 0;

        /**
         * DeviceUIConfig screenBrightness.
         * @member {number} screenBrightness
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.screenBrightness = 0;

        /**
         * DeviceUIConfig screenTimeout.
         * @member {number} screenTimeout
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.screenTimeout = 0;

        /**
         * DeviceUIConfig screenLock.
         * @member {boolean} screenLock
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.screenLock = false;

        /**
         * DeviceUIConfig settingsLock.
         * @member {boolean} settingsLock
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.settingsLock = false;

        /**
         * DeviceUIConfig pinCode.
         * @member {number} pinCode
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.pinCode = 0;

        /**
         * DeviceUIConfig theme.
         * @member {meshtastic.Theme} theme
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.theme = 0;

        /**
         * DeviceUIConfig alertEnabled.
         * @member {boolean} alertEnabled
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.alertEnabled = false;

        /**
         * DeviceUIConfig bannerEnabled.
         * @member {boolean} bannerEnabled
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.bannerEnabled = false;

        /**
         * DeviceUIConfig ringToneId.
         * @member {number} ringToneId
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.ringToneId = 0;

        /**
         * DeviceUIConfig language.
         * @member {meshtastic.Language} language
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.language = 0;

        /**
         * DeviceUIConfig nodeFilter.
         * @member {meshtastic.INodeFilter|null|undefined} nodeFilter
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.nodeFilter = null;

        /**
         * DeviceUIConfig nodeHighlight.
         * @member {meshtastic.INodeHighlight|null|undefined} nodeHighlight
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.nodeHighlight = null;

        /**
         * DeviceUIConfig calibrationData.
         * @member {Uint8Array} calibrationData
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.calibrationData = $util.newBuffer([]);

        /**
         * DeviceUIConfig mapData.
         * @member {meshtastic.IMap|null|undefined} mapData
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.mapData = null;

        /**
         * DeviceUIConfig compassMode.
         * @member {meshtastic.CompassMode} compassMode
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.compassMode = 0;

        /**
         * DeviceUIConfig screenRgbColor.
         * @member {number} screenRgbColor
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.screenRgbColor = 0;

        /**
         * DeviceUIConfig isClockfaceAnalog.
         * @member {boolean} isClockfaceAnalog
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.isClockfaceAnalog = false;

        /**
         * DeviceUIConfig gpsFormat.
         * @member {meshtastic.DeviceUIConfig.GpsCoordinateFormat} gpsFormat
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         */
        DeviceUIConfig.prototype.gpsFormat = 0;

        /**
         * Creates a new DeviceUIConfig instance using the specified properties.
         * @function create
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {meshtastic.IDeviceUIConfig=} [properties] Properties to set
         * @returns {meshtastic.DeviceUIConfig} DeviceUIConfig instance
         */
        DeviceUIConfig.create = function create(properties) {
            return new DeviceUIConfig(properties);
        };

        /**
         * Encodes the specified DeviceUIConfig message. Does not implicitly {@link meshtastic.DeviceUIConfig.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {meshtastic.IDeviceUIConfig} message DeviceUIConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceUIConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.version);
            if (message.screenBrightness != null && Object.hasOwnProperty.call(message, "screenBrightness"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.screenBrightness);
            if (message.screenTimeout != null && Object.hasOwnProperty.call(message, "screenTimeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.screenTimeout);
            if (message.screenLock != null && Object.hasOwnProperty.call(message, "screenLock"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.screenLock);
            if (message.settingsLock != null && Object.hasOwnProperty.call(message, "settingsLock"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.settingsLock);
            if (message.pinCode != null && Object.hasOwnProperty.call(message, "pinCode"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.pinCode);
            if (message.theme != null && Object.hasOwnProperty.call(message, "theme"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.theme);
            if (message.alertEnabled != null && Object.hasOwnProperty.call(message, "alertEnabled"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.alertEnabled);
            if (message.bannerEnabled != null && Object.hasOwnProperty.call(message, "bannerEnabled"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.bannerEnabled);
            if (message.ringToneId != null && Object.hasOwnProperty.call(message, "ringToneId"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.ringToneId);
            if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.language);
            if (message.nodeFilter != null && Object.hasOwnProperty.call(message, "nodeFilter"))
                $root.meshtastic.NodeFilter.encode(message.nodeFilter, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.nodeHighlight != null && Object.hasOwnProperty.call(message, "nodeHighlight"))
                $root.meshtastic.NodeHighlight.encode(message.nodeHighlight, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.calibrationData != null && Object.hasOwnProperty.call(message, "calibrationData"))
                writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.calibrationData);
            if (message.mapData != null && Object.hasOwnProperty.call(message, "mapData"))
                $root.meshtastic.Map.encode(message.mapData, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.compassMode != null && Object.hasOwnProperty.call(message, "compassMode"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.compassMode);
            if (message.screenRgbColor != null && Object.hasOwnProperty.call(message, "screenRgbColor"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.screenRgbColor);
            if (message.isClockfaceAnalog != null && Object.hasOwnProperty.call(message, "isClockfaceAnalog"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.isClockfaceAnalog);
            if (message.gpsFormat != null && Object.hasOwnProperty.call(message, "gpsFormat"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.gpsFormat);
            return writer;
        };

        /**
         * Encodes the specified DeviceUIConfig message, length delimited. Does not implicitly {@link meshtastic.DeviceUIConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {meshtastic.IDeviceUIConfig} message DeviceUIConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceUIConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceUIConfig message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.DeviceUIConfig} DeviceUIConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceUIConfig.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.DeviceUIConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.version = reader.uint32();
                        break;
                    }
                case 2: {
                        message.screenBrightness = reader.uint32();
                        break;
                    }
                case 3: {
                        message.screenTimeout = reader.uint32();
                        break;
                    }
                case 4: {
                        message.screenLock = reader.bool();
                        break;
                    }
                case 5: {
                        message.settingsLock = reader.bool();
                        break;
                    }
                case 6: {
                        message.pinCode = reader.uint32();
                        break;
                    }
                case 7: {
                        message.theme = reader.int32();
                        break;
                    }
                case 8: {
                        message.alertEnabled = reader.bool();
                        break;
                    }
                case 9: {
                        message.bannerEnabled = reader.bool();
                        break;
                    }
                case 10: {
                        message.ringToneId = reader.uint32();
                        break;
                    }
                case 11: {
                        message.language = reader.int32();
                        break;
                    }
                case 12: {
                        message.nodeFilter = $root.meshtastic.NodeFilter.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.nodeHighlight = $root.meshtastic.NodeHighlight.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.calibrationData = reader.bytes();
                        break;
                    }
                case 15: {
                        message.mapData = $root.meshtastic.Map.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.compassMode = reader.int32();
                        break;
                    }
                case 17: {
                        message.screenRgbColor = reader.uint32();
                        break;
                    }
                case 18: {
                        message.isClockfaceAnalog = reader.bool();
                        break;
                    }
                case 19: {
                        message.gpsFormat = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceUIConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.DeviceUIConfig} DeviceUIConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceUIConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceUIConfig message.
         * @function verify
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceUIConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.screenBrightness != null && message.hasOwnProperty("screenBrightness"))
                if (!$util.isInteger(message.screenBrightness))
                    return "screenBrightness: integer expected";
            if (message.screenTimeout != null && message.hasOwnProperty("screenTimeout"))
                if (!$util.isInteger(message.screenTimeout))
                    return "screenTimeout: integer expected";
            if (message.screenLock != null && message.hasOwnProperty("screenLock"))
                if (typeof message.screenLock !== "boolean")
                    return "screenLock: boolean expected";
            if (message.settingsLock != null && message.hasOwnProperty("settingsLock"))
                if (typeof message.settingsLock !== "boolean")
                    return "settingsLock: boolean expected";
            if (message.pinCode != null && message.hasOwnProperty("pinCode"))
                if (!$util.isInteger(message.pinCode))
                    return "pinCode: integer expected";
            if (message.theme != null && message.hasOwnProperty("theme"))
                switch (message.theme) {
                default:
                    return "theme: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.alertEnabled != null && message.hasOwnProperty("alertEnabled"))
                if (typeof message.alertEnabled !== "boolean")
                    return "alertEnabled: boolean expected";
            if (message.bannerEnabled != null && message.hasOwnProperty("bannerEnabled"))
                if (typeof message.bannerEnabled !== "boolean")
                    return "bannerEnabled: boolean expected";
            if (message.ringToneId != null && message.hasOwnProperty("ringToneId"))
                if (!$util.isInteger(message.ringToneId))
                    return "ringToneId: integer expected";
            if (message.language != null && message.hasOwnProperty("language"))
                switch (message.language) {
                default:
                    return "language: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 30:
                case 31:
                    break;
                }
            if (message.nodeFilter != null && message.hasOwnProperty("nodeFilter")) {
                var error = $root.meshtastic.NodeFilter.verify(message.nodeFilter);
                if (error)
                    return "nodeFilter." + error;
            }
            if (message.nodeHighlight != null && message.hasOwnProperty("nodeHighlight")) {
                var error = $root.meshtastic.NodeHighlight.verify(message.nodeHighlight);
                if (error)
                    return "nodeHighlight." + error;
            }
            if (message.calibrationData != null && message.hasOwnProperty("calibrationData"))
                if (!(message.calibrationData && typeof message.calibrationData.length === "number" || $util.isString(message.calibrationData)))
                    return "calibrationData: buffer expected";
            if (message.mapData != null && message.hasOwnProperty("mapData")) {
                var error = $root.meshtastic.Map.verify(message.mapData);
                if (error)
                    return "mapData." + error;
            }
            if (message.compassMode != null && message.hasOwnProperty("compassMode"))
                switch (message.compassMode) {
                default:
                    return "compassMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.screenRgbColor != null && message.hasOwnProperty("screenRgbColor"))
                if (!$util.isInteger(message.screenRgbColor))
                    return "screenRgbColor: integer expected";
            if (message.isClockfaceAnalog != null && message.hasOwnProperty("isClockfaceAnalog"))
                if (typeof message.isClockfaceAnalog !== "boolean")
                    return "isClockfaceAnalog: boolean expected";
            if (message.gpsFormat != null && message.hasOwnProperty("gpsFormat"))
                switch (message.gpsFormat) {
                default:
                    return "gpsFormat: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceUIConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.DeviceUIConfig} DeviceUIConfig
         */
        DeviceUIConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.DeviceUIConfig)
                return object;
            var message = new $root.meshtastic.DeviceUIConfig();
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.screenBrightness != null)
                message.screenBrightness = object.screenBrightness >>> 0;
            if (object.screenTimeout != null)
                message.screenTimeout = object.screenTimeout >>> 0;
            if (object.screenLock != null)
                message.screenLock = Boolean(object.screenLock);
            if (object.settingsLock != null)
                message.settingsLock = Boolean(object.settingsLock);
            if (object.pinCode != null)
                message.pinCode = object.pinCode >>> 0;
            switch (object.theme) {
            default:
                if (typeof object.theme === "number") {
                    message.theme = object.theme;
                    break;
                }
                break;
            case "DARK":
            case 0:
                message.theme = 0;
                break;
            case "LIGHT":
            case 1:
                message.theme = 1;
                break;
            case "RED":
            case 2:
                message.theme = 2;
                break;
            }
            if (object.alertEnabled != null)
                message.alertEnabled = Boolean(object.alertEnabled);
            if (object.bannerEnabled != null)
                message.bannerEnabled = Boolean(object.bannerEnabled);
            if (object.ringToneId != null)
                message.ringToneId = object.ringToneId >>> 0;
            switch (object.language) {
            default:
                if (typeof object.language === "number") {
                    message.language = object.language;
                    break;
                }
                break;
            case "ENGLISH":
            case 0:
                message.language = 0;
                break;
            case "FRENCH":
            case 1:
                message.language = 1;
                break;
            case "GERMAN":
            case 2:
                message.language = 2;
                break;
            case "ITALIAN":
            case 3:
                message.language = 3;
                break;
            case "PORTUGUESE":
            case 4:
                message.language = 4;
                break;
            case "SPANISH":
            case 5:
                message.language = 5;
                break;
            case "SWEDISH":
            case 6:
                message.language = 6;
                break;
            case "FINNISH":
            case 7:
                message.language = 7;
                break;
            case "POLISH":
            case 8:
                message.language = 8;
                break;
            case "TURKISH":
            case 9:
                message.language = 9;
                break;
            case "SERBIAN":
            case 10:
                message.language = 10;
                break;
            case "RUSSIAN":
            case 11:
                message.language = 11;
                break;
            case "DUTCH":
            case 12:
                message.language = 12;
                break;
            case "GREEK":
            case 13:
                message.language = 13;
                break;
            case "NORWEGIAN":
            case 14:
                message.language = 14;
                break;
            case "SLOVENIAN":
            case 15:
                message.language = 15;
                break;
            case "UKRAINIAN":
            case 16:
                message.language = 16;
                break;
            case "BULGARIAN":
            case 17:
                message.language = 17;
                break;
            case "CZECH":
            case 18:
                message.language = 18;
                break;
            case "DANISH":
            case 19:
                message.language = 19;
                break;
            case "SIMPLIFIED_CHINESE":
            case 30:
                message.language = 30;
                break;
            case "TRADITIONAL_CHINESE":
            case 31:
                message.language = 31;
                break;
            }
            if (object.nodeFilter != null) {
                if (typeof object.nodeFilter !== "object")
                    throw TypeError(".meshtastic.DeviceUIConfig.nodeFilter: object expected");
                message.nodeFilter = $root.meshtastic.NodeFilter.fromObject(object.nodeFilter);
            }
            if (object.nodeHighlight != null) {
                if (typeof object.nodeHighlight !== "object")
                    throw TypeError(".meshtastic.DeviceUIConfig.nodeHighlight: object expected");
                message.nodeHighlight = $root.meshtastic.NodeHighlight.fromObject(object.nodeHighlight);
            }
            if (object.calibrationData != null)
                if (typeof object.calibrationData === "string")
                    $util.base64.decode(object.calibrationData, message.calibrationData = $util.newBuffer($util.base64.length(object.calibrationData)), 0);
                else if (object.calibrationData.length >= 0)
                    message.calibrationData = object.calibrationData;
            if (object.mapData != null) {
                if (typeof object.mapData !== "object")
                    throw TypeError(".meshtastic.DeviceUIConfig.mapData: object expected");
                message.mapData = $root.meshtastic.Map.fromObject(object.mapData);
            }
            switch (object.compassMode) {
            default:
                if (typeof object.compassMode === "number") {
                    message.compassMode = object.compassMode;
                    break;
                }
                break;
            case "DYNAMIC":
            case 0:
                message.compassMode = 0;
                break;
            case "FIXED_RING":
            case 1:
                message.compassMode = 1;
                break;
            case "FREEZE_HEADING":
            case 2:
                message.compassMode = 2;
                break;
            }
            if (object.screenRgbColor != null)
                message.screenRgbColor = object.screenRgbColor >>> 0;
            if (object.isClockfaceAnalog != null)
                message.isClockfaceAnalog = Boolean(object.isClockfaceAnalog);
            switch (object.gpsFormat) {
            default:
                if (typeof object.gpsFormat === "number") {
                    message.gpsFormat = object.gpsFormat;
                    break;
                }
                break;
            case "DEC":
            case 0:
                message.gpsFormat = 0;
                break;
            case "DMS":
            case 1:
                message.gpsFormat = 1;
                break;
            case "UTM":
            case 2:
                message.gpsFormat = 2;
                break;
            case "MGRS":
            case 3:
                message.gpsFormat = 3;
                break;
            case "OLC":
            case 4:
                message.gpsFormat = 4;
                break;
            case "OSGR":
            case 5:
                message.gpsFormat = 5;
                break;
            case "MLS":
            case 6:
                message.gpsFormat = 6;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceUIConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {meshtastic.DeviceUIConfig} message DeviceUIConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceUIConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.version = 0;
                object.screenBrightness = 0;
                object.screenTimeout = 0;
                object.screenLock = false;
                object.settingsLock = false;
                object.pinCode = 0;
                object.theme = options.enums === String ? "DARK" : 0;
                object.alertEnabled = false;
                object.bannerEnabled = false;
                object.ringToneId = 0;
                object.language = options.enums === String ? "ENGLISH" : 0;
                object.nodeFilter = null;
                object.nodeHighlight = null;
                if (options.bytes === String)
                    object.calibrationData = "";
                else {
                    object.calibrationData = [];
                    if (options.bytes !== Array)
                        object.calibrationData = $util.newBuffer(object.calibrationData);
                }
                object.mapData = null;
                object.compassMode = options.enums === String ? "DYNAMIC" : 0;
                object.screenRgbColor = 0;
                object.isClockfaceAnalog = false;
                object.gpsFormat = options.enums === String ? "DEC" : 0;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.screenBrightness != null && message.hasOwnProperty("screenBrightness"))
                object.screenBrightness = message.screenBrightness;
            if (message.screenTimeout != null && message.hasOwnProperty("screenTimeout"))
                object.screenTimeout = message.screenTimeout;
            if (message.screenLock != null && message.hasOwnProperty("screenLock"))
                object.screenLock = message.screenLock;
            if (message.settingsLock != null && message.hasOwnProperty("settingsLock"))
                object.settingsLock = message.settingsLock;
            if (message.pinCode != null && message.hasOwnProperty("pinCode"))
                object.pinCode = message.pinCode;
            if (message.theme != null && message.hasOwnProperty("theme"))
                object.theme = options.enums === String ? $root.meshtastic.Theme[message.theme] === undefined ? message.theme : $root.meshtastic.Theme[message.theme] : message.theme;
            if (message.alertEnabled != null && message.hasOwnProperty("alertEnabled"))
                object.alertEnabled = message.alertEnabled;
            if (message.bannerEnabled != null && message.hasOwnProperty("bannerEnabled"))
                object.bannerEnabled = message.bannerEnabled;
            if (message.ringToneId != null && message.hasOwnProperty("ringToneId"))
                object.ringToneId = message.ringToneId;
            if (message.language != null && message.hasOwnProperty("language"))
                object.language = options.enums === String ? $root.meshtastic.Language[message.language] === undefined ? message.language : $root.meshtastic.Language[message.language] : message.language;
            if (message.nodeFilter != null && message.hasOwnProperty("nodeFilter"))
                object.nodeFilter = $root.meshtastic.NodeFilter.toObject(message.nodeFilter, options);
            if (message.nodeHighlight != null && message.hasOwnProperty("nodeHighlight"))
                object.nodeHighlight = $root.meshtastic.NodeHighlight.toObject(message.nodeHighlight, options);
            if (message.calibrationData != null && message.hasOwnProperty("calibrationData"))
                object.calibrationData = options.bytes === String ? $util.base64.encode(message.calibrationData, 0, message.calibrationData.length) : options.bytes === Array ? Array.prototype.slice.call(message.calibrationData) : message.calibrationData;
            if (message.mapData != null && message.hasOwnProperty("mapData"))
                object.mapData = $root.meshtastic.Map.toObject(message.mapData, options);
            if (message.compassMode != null && message.hasOwnProperty("compassMode"))
                object.compassMode = options.enums === String ? $root.meshtastic.CompassMode[message.compassMode] === undefined ? message.compassMode : $root.meshtastic.CompassMode[message.compassMode] : message.compassMode;
            if (message.screenRgbColor != null && message.hasOwnProperty("screenRgbColor"))
                object.screenRgbColor = message.screenRgbColor;
            if (message.isClockfaceAnalog != null && message.hasOwnProperty("isClockfaceAnalog"))
                object.isClockfaceAnalog = message.isClockfaceAnalog;
            if (message.gpsFormat != null && message.hasOwnProperty("gpsFormat"))
                object.gpsFormat = options.enums === String ? $root.meshtastic.DeviceUIConfig.GpsCoordinateFormat[message.gpsFormat] === undefined ? message.gpsFormat : $root.meshtastic.DeviceUIConfig.GpsCoordinateFormat[message.gpsFormat] : message.gpsFormat;
            return object;
        };

        /**
         * Converts this DeviceUIConfig to JSON.
         * @function toJSON
         * @memberof meshtastic.DeviceUIConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceUIConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeviceUIConfig
         * @function getTypeUrl
         * @memberof meshtastic.DeviceUIConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeviceUIConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.DeviceUIConfig";
        };

        /**
         * GpsCoordinateFormat enum.
         * @name meshtastic.DeviceUIConfig.GpsCoordinateFormat
         * @enum {number}
         * @property {number} DEC=0 DEC value
         * @property {number} DMS=1 DMS value
         * @property {number} UTM=2 UTM value
         * @property {number} MGRS=3 MGRS value
         * @property {number} OLC=4 OLC value
         * @property {number} OSGR=5 OSGR value
         * @property {number} MLS=6 MLS value
         */
        DeviceUIConfig.GpsCoordinateFormat = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEC"] = 0;
            values[valuesById[1] = "DMS"] = 1;
            values[valuesById[2] = "UTM"] = 2;
            values[valuesById[3] = "MGRS"] = 3;
            values[valuesById[4] = "OLC"] = 4;
            values[valuesById[5] = "OSGR"] = 5;
            values[valuesById[6] = "MLS"] = 6;
            return values;
        })();

        return DeviceUIConfig;
    })();

    meshtastic.NodeFilter = (function() {

        /**
         * Properties of a NodeFilter.
         * @memberof meshtastic
         * @interface INodeFilter
         * @property {boolean|null} [unknownSwitch] NodeFilter unknownSwitch
         * @property {boolean|null} [offlineSwitch] NodeFilter offlineSwitch
         * @property {boolean|null} [publicKeySwitch] NodeFilter publicKeySwitch
         * @property {number|null} [hopsAway] NodeFilter hopsAway
         * @property {boolean|null} [positionSwitch] NodeFilter positionSwitch
         * @property {string|null} [nodeName] NodeFilter nodeName
         * @property {number|null} [channel] NodeFilter channel
         */

        /**
         * Constructs a new NodeFilter.
         * @memberof meshtastic
         * @classdesc Represents a NodeFilter.
         * @implements INodeFilter
         * @constructor
         * @param {meshtastic.INodeFilter=} [properties] Properties to set
         */
        function NodeFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeFilter unknownSwitch.
         * @member {boolean} unknownSwitch
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.unknownSwitch = false;

        /**
         * NodeFilter offlineSwitch.
         * @member {boolean} offlineSwitch
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.offlineSwitch = false;

        /**
         * NodeFilter publicKeySwitch.
         * @member {boolean} publicKeySwitch
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.publicKeySwitch = false;

        /**
         * NodeFilter hopsAway.
         * @member {number} hopsAway
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.hopsAway = 0;

        /**
         * NodeFilter positionSwitch.
         * @member {boolean} positionSwitch
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.positionSwitch = false;

        /**
         * NodeFilter nodeName.
         * @member {string} nodeName
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.nodeName = "";

        /**
         * NodeFilter channel.
         * @member {number} channel
         * @memberof meshtastic.NodeFilter
         * @instance
         */
        NodeFilter.prototype.channel = 0;

        /**
         * Creates a new NodeFilter instance using the specified properties.
         * @function create
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {meshtastic.INodeFilter=} [properties] Properties to set
         * @returns {meshtastic.NodeFilter} NodeFilter instance
         */
        NodeFilter.create = function create(properties) {
            return new NodeFilter(properties);
        };

        /**
         * Encodes the specified NodeFilter message. Does not implicitly {@link meshtastic.NodeFilter.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {meshtastic.INodeFilter} message NodeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.unknownSwitch != null && Object.hasOwnProperty.call(message, "unknownSwitch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unknownSwitch);
            if (message.offlineSwitch != null && Object.hasOwnProperty.call(message, "offlineSwitch"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.offlineSwitch);
            if (message.publicKeySwitch != null && Object.hasOwnProperty.call(message, "publicKeySwitch"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.publicKeySwitch);
            if (message.hopsAway != null && Object.hasOwnProperty.call(message, "hopsAway"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hopsAway);
            if (message.positionSwitch != null && Object.hasOwnProperty.call(message, "positionSwitch"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.positionSwitch);
            if (message.nodeName != null && Object.hasOwnProperty.call(message, "nodeName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.nodeName);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.channel);
            return writer;
        };

        /**
         * Encodes the specified NodeFilter message, length delimited. Does not implicitly {@link meshtastic.NodeFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {meshtastic.INodeFilter} message NodeFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeFilter message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.NodeFilter} NodeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeFilter.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.NodeFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.unknownSwitch = reader.bool();
                        break;
                    }
                case 2: {
                        message.offlineSwitch = reader.bool();
                        break;
                    }
                case 3: {
                        message.publicKeySwitch = reader.bool();
                        break;
                    }
                case 4: {
                        message.hopsAway = reader.int32();
                        break;
                    }
                case 5: {
                        message.positionSwitch = reader.bool();
                        break;
                    }
                case 6: {
                        message.nodeName = reader.string();
                        break;
                    }
                case 7: {
                        message.channel = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.NodeFilter} NodeFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeFilter message.
         * @function verify
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.unknownSwitch != null && message.hasOwnProperty("unknownSwitch"))
                if (typeof message.unknownSwitch !== "boolean")
                    return "unknownSwitch: boolean expected";
            if (message.offlineSwitch != null && message.hasOwnProperty("offlineSwitch"))
                if (typeof message.offlineSwitch !== "boolean")
                    return "offlineSwitch: boolean expected";
            if (message.publicKeySwitch != null && message.hasOwnProperty("publicKeySwitch"))
                if (typeof message.publicKeySwitch !== "boolean")
                    return "publicKeySwitch: boolean expected";
            if (message.hopsAway != null && message.hasOwnProperty("hopsAway"))
                if (!$util.isInteger(message.hopsAway))
                    return "hopsAway: integer expected";
            if (message.positionSwitch != null && message.hasOwnProperty("positionSwitch"))
                if (typeof message.positionSwitch !== "boolean")
                    return "positionSwitch: boolean expected";
            if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                if (!$util.isString(message.nodeName))
                    return "nodeName: string expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            return null;
        };

        /**
         * Creates a NodeFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.NodeFilter} NodeFilter
         */
        NodeFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.NodeFilter)
                return object;
            var message = new $root.meshtastic.NodeFilter();
            if (object.unknownSwitch != null)
                message.unknownSwitch = Boolean(object.unknownSwitch);
            if (object.offlineSwitch != null)
                message.offlineSwitch = Boolean(object.offlineSwitch);
            if (object.publicKeySwitch != null)
                message.publicKeySwitch = Boolean(object.publicKeySwitch);
            if (object.hopsAway != null)
                message.hopsAway = object.hopsAway | 0;
            if (object.positionSwitch != null)
                message.positionSwitch = Boolean(object.positionSwitch);
            if (object.nodeName != null)
                message.nodeName = String(object.nodeName);
            if (object.channel != null)
                message.channel = object.channel | 0;
            return message;
        };

        /**
         * Creates a plain object from a NodeFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {meshtastic.NodeFilter} message NodeFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.unknownSwitch = false;
                object.offlineSwitch = false;
                object.publicKeySwitch = false;
                object.hopsAway = 0;
                object.positionSwitch = false;
                object.nodeName = "";
                object.channel = 0;
            }
            if (message.unknownSwitch != null && message.hasOwnProperty("unknownSwitch"))
                object.unknownSwitch = message.unknownSwitch;
            if (message.offlineSwitch != null && message.hasOwnProperty("offlineSwitch"))
                object.offlineSwitch = message.offlineSwitch;
            if (message.publicKeySwitch != null && message.hasOwnProperty("publicKeySwitch"))
                object.publicKeySwitch = message.publicKeySwitch;
            if (message.hopsAway != null && message.hasOwnProperty("hopsAway"))
                object.hopsAway = message.hopsAway;
            if (message.positionSwitch != null && message.hasOwnProperty("positionSwitch"))
                object.positionSwitch = message.positionSwitch;
            if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                object.nodeName = message.nodeName;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            return object;
        };

        /**
         * Converts this NodeFilter to JSON.
         * @function toJSON
         * @memberof meshtastic.NodeFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NodeFilter
         * @function getTypeUrl
         * @memberof meshtastic.NodeFilter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.NodeFilter";
        };

        return NodeFilter;
    })();

    meshtastic.NodeHighlight = (function() {

        /**
         * Properties of a NodeHighlight.
         * @memberof meshtastic
         * @interface INodeHighlight
         * @property {boolean|null} [chatSwitch] NodeHighlight chatSwitch
         * @property {boolean|null} [positionSwitch] NodeHighlight positionSwitch
         * @property {boolean|null} [telemetrySwitch] NodeHighlight telemetrySwitch
         * @property {boolean|null} [iaqSwitch] NodeHighlight iaqSwitch
         * @property {string|null} [nodeName] NodeHighlight nodeName
         */

        /**
         * Constructs a new NodeHighlight.
         * @memberof meshtastic
         * @classdesc Represents a NodeHighlight.
         * @implements INodeHighlight
         * @constructor
         * @param {meshtastic.INodeHighlight=} [properties] Properties to set
         */
        function NodeHighlight(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeHighlight chatSwitch.
         * @member {boolean} chatSwitch
         * @memberof meshtastic.NodeHighlight
         * @instance
         */
        NodeHighlight.prototype.chatSwitch = false;

        /**
         * NodeHighlight positionSwitch.
         * @member {boolean} positionSwitch
         * @memberof meshtastic.NodeHighlight
         * @instance
         */
        NodeHighlight.prototype.positionSwitch = false;

        /**
         * NodeHighlight telemetrySwitch.
         * @member {boolean} telemetrySwitch
         * @memberof meshtastic.NodeHighlight
         * @instance
         */
        NodeHighlight.prototype.telemetrySwitch = false;

        /**
         * NodeHighlight iaqSwitch.
         * @member {boolean} iaqSwitch
         * @memberof meshtastic.NodeHighlight
         * @instance
         */
        NodeHighlight.prototype.iaqSwitch = false;

        /**
         * NodeHighlight nodeName.
         * @member {string} nodeName
         * @memberof meshtastic.NodeHighlight
         * @instance
         */
        NodeHighlight.prototype.nodeName = "";

        /**
         * Creates a new NodeHighlight instance using the specified properties.
         * @function create
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {meshtastic.INodeHighlight=} [properties] Properties to set
         * @returns {meshtastic.NodeHighlight} NodeHighlight instance
         */
        NodeHighlight.create = function create(properties) {
            return new NodeHighlight(properties);
        };

        /**
         * Encodes the specified NodeHighlight message. Does not implicitly {@link meshtastic.NodeHighlight.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {meshtastic.INodeHighlight} message NodeHighlight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeHighlight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chatSwitch != null && Object.hasOwnProperty.call(message, "chatSwitch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.chatSwitch);
            if (message.positionSwitch != null && Object.hasOwnProperty.call(message, "positionSwitch"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.positionSwitch);
            if (message.telemetrySwitch != null && Object.hasOwnProperty.call(message, "telemetrySwitch"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.telemetrySwitch);
            if (message.iaqSwitch != null && Object.hasOwnProperty.call(message, "iaqSwitch"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.iaqSwitch);
            if (message.nodeName != null && Object.hasOwnProperty.call(message, "nodeName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.nodeName);
            return writer;
        };

        /**
         * Encodes the specified NodeHighlight message, length delimited. Does not implicitly {@link meshtastic.NodeHighlight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {meshtastic.INodeHighlight} message NodeHighlight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeHighlight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeHighlight message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.NodeHighlight} NodeHighlight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeHighlight.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.NodeHighlight();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.chatSwitch = reader.bool();
                        break;
                    }
                case 2: {
                        message.positionSwitch = reader.bool();
                        break;
                    }
                case 3: {
                        message.telemetrySwitch = reader.bool();
                        break;
                    }
                case 4: {
                        message.iaqSwitch = reader.bool();
                        break;
                    }
                case 5: {
                        message.nodeName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeHighlight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.NodeHighlight} NodeHighlight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeHighlight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeHighlight message.
         * @function verify
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeHighlight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chatSwitch != null && message.hasOwnProperty("chatSwitch"))
                if (typeof message.chatSwitch !== "boolean")
                    return "chatSwitch: boolean expected";
            if (message.positionSwitch != null && message.hasOwnProperty("positionSwitch"))
                if (typeof message.positionSwitch !== "boolean")
                    return "positionSwitch: boolean expected";
            if (message.telemetrySwitch != null && message.hasOwnProperty("telemetrySwitch"))
                if (typeof message.telemetrySwitch !== "boolean")
                    return "telemetrySwitch: boolean expected";
            if (message.iaqSwitch != null && message.hasOwnProperty("iaqSwitch"))
                if (typeof message.iaqSwitch !== "boolean")
                    return "iaqSwitch: boolean expected";
            if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                if (!$util.isString(message.nodeName))
                    return "nodeName: string expected";
            return null;
        };

        /**
         * Creates a NodeHighlight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.NodeHighlight} NodeHighlight
         */
        NodeHighlight.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.NodeHighlight)
                return object;
            var message = new $root.meshtastic.NodeHighlight();
            if (object.chatSwitch != null)
                message.chatSwitch = Boolean(object.chatSwitch);
            if (object.positionSwitch != null)
                message.positionSwitch = Boolean(object.positionSwitch);
            if (object.telemetrySwitch != null)
                message.telemetrySwitch = Boolean(object.telemetrySwitch);
            if (object.iaqSwitch != null)
                message.iaqSwitch = Boolean(object.iaqSwitch);
            if (object.nodeName != null)
                message.nodeName = String(object.nodeName);
            return message;
        };

        /**
         * Creates a plain object from a NodeHighlight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {meshtastic.NodeHighlight} message NodeHighlight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeHighlight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chatSwitch = false;
                object.positionSwitch = false;
                object.telemetrySwitch = false;
                object.iaqSwitch = false;
                object.nodeName = "";
            }
            if (message.chatSwitch != null && message.hasOwnProperty("chatSwitch"))
                object.chatSwitch = message.chatSwitch;
            if (message.positionSwitch != null && message.hasOwnProperty("positionSwitch"))
                object.positionSwitch = message.positionSwitch;
            if (message.telemetrySwitch != null && message.hasOwnProperty("telemetrySwitch"))
                object.telemetrySwitch = message.telemetrySwitch;
            if (message.iaqSwitch != null && message.hasOwnProperty("iaqSwitch"))
                object.iaqSwitch = message.iaqSwitch;
            if (message.nodeName != null && message.hasOwnProperty("nodeName"))
                object.nodeName = message.nodeName;
            return object;
        };

        /**
         * Converts this NodeHighlight to JSON.
         * @function toJSON
         * @memberof meshtastic.NodeHighlight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeHighlight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NodeHighlight
         * @function getTypeUrl
         * @memberof meshtastic.NodeHighlight
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeHighlight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.NodeHighlight";
        };

        return NodeHighlight;
    })();

    meshtastic.GeoPoint = (function() {

        /**
         * Properties of a GeoPoint.
         * @memberof meshtastic
         * @interface IGeoPoint
         * @property {number|null} [zoom] GeoPoint zoom
         * @property {number|null} [latitude] GeoPoint latitude
         * @property {number|null} [longitude] GeoPoint longitude
         */

        /**
         * Constructs a new GeoPoint.
         * @memberof meshtastic
         * @classdesc Represents a GeoPoint.
         * @implements IGeoPoint
         * @constructor
         * @param {meshtastic.IGeoPoint=} [properties] Properties to set
         */
        function GeoPoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GeoPoint zoom.
         * @member {number} zoom
         * @memberof meshtastic.GeoPoint
         * @instance
         */
        GeoPoint.prototype.zoom = 0;

        /**
         * GeoPoint latitude.
         * @member {number} latitude
         * @memberof meshtastic.GeoPoint
         * @instance
         */
        GeoPoint.prototype.latitude = 0;

        /**
         * GeoPoint longitude.
         * @member {number} longitude
         * @memberof meshtastic.GeoPoint
         * @instance
         */
        GeoPoint.prototype.longitude = 0;

        /**
         * Creates a new GeoPoint instance using the specified properties.
         * @function create
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {meshtastic.IGeoPoint=} [properties] Properties to set
         * @returns {meshtastic.GeoPoint} GeoPoint instance
         */
        GeoPoint.create = function create(properties) {
            return new GeoPoint(properties);
        };

        /**
         * Encodes the specified GeoPoint message. Does not implicitly {@link meshtastic.GeoPoint.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {meshtastic.IGeoPoint} message GeoPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeoPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.zoom != null && Object.hasOwnProperty.call(message, "zoom"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.zoom);
            if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.latitude);
            if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.longitude);
            return writer;
        };

        /**
         * Encodes the specified GeoPoint message, length delimited. Does not implicitly {@link meshtastic.GeoPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {meshtastic.IGeoPoint} message GeoPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeoPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GeoPoint message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.GeoPoint} GeoPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeoPoint.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.GeoPoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.zoom = reader.int32();
                        break;
                    }
                case 2: {
                        message.latitude = reader.int32();
                        break;
                    }
                case 3: {
                        message.longitude = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GeoPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.GeoPoint} GeoPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeoPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GeoPoint message.
         * @function verify
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GeoPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.zoom != null && message.hasOwnProperty("zoom"))
                if (!$util.isInteger(message.zoom))
                    return "zoom: integer expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (!$util.isInteger(message.latitude))
                    return "latitude: integer expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (!$util.isInteger(message.longitude))
                    return "longitude: integer expected";
            return null;
        };

        /**
         * Creates a GeoPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.GeoPoint} GeoPoint
         */
        GeoPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.GeoPoint)
                return object;
            var message = new $root.meshtastic.GeoPoint();
            if (object.zoom != null)
                message.zoom = object.zoom | 0;
            if (object.latitude != null)
                message.latitude = object.latitude | 0;
            if (object.longitude != null)
                message.longitude = object.longitude | 0;
            return message;
        };

        /**
         * Creates a plain object from a GeoPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {meshtastic.GeoPoint} message GeoPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GeoPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.zoom = 0;
                object.latitude = 0;
                object.longitude = 0;
            }
            if (message.zoom != null && message.hasOwnProperty("zoom"))
                object.zoom = message.zoom;
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = message.latitude;
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = message.longitude;
            return object;
        };

        /**
         * Converts this GeoPoint to JSON.
         * @function toJSON
         * @memberof meshtastic.GeoPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GeoPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GeoPoint
         * @function getTypeUrl
         * @memberof meshtastic.GeoPoint
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GeoPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.GeoPoint";
        };

        return GeoPoint;
    })();

    meshtastic.Map = (function() {

        /**
         * Properties of a Map.
         * @memberof meshtastic
         * @interface IMap
         * @property {meshtastic.IGeoPoint|null} [home] Map home
         * @property {string|null} [style] Map style
         * @property {boolean|null} [followGps] Map followGps
         */

        /**
         * Constructs a new Map.
         * @memberof meshtastic
         * @classdesc Represents a Map.
         * @implements IMap
         * @constructor
         * @param {meshtastic.IMap=} [properties] Properties to set
         */
        function Map(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Map home.
         * @member {meshtastic.IGeoPoint|null|undefined} home
         * @memberof meshtastic.Map
         * @instance
         */
        Map.prototype.home = null;

        /**
         * Map style.
         * @member {string} style
         * @memberof meshtastic.Map
         * @instance
         */
        Map.prototype.style = "";

        /**
         * Map followGps.
         * @member {boolean} followGps
         * @memberof meshtastic.Map
         * @instance
         */
        Map.prototype.followGps = false;

        /**
         * Creates a new Map instance using the specified properties.
         * @function create
         * @memberof meshtastic.Map
         * @static
         * @param {meshtastic.IMap=} [properties] Properties to set
         * @returns {meshtastic.Map} Map instance
         */
        Map.create = function create(properties) {
            return new Map(properties);
        };

        /**
         * Encodes the specified Map message. Does not implicitly {@link meshtastic.Map.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Map
         * @static
         * @param {meshtastic.IMap} message Map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Map.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.home != null && Object.hasOwnProperty.call(message, "home"))
                $root.meshtastic.GeoPoint.encode(message.home, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.style);
            if (message.followGps != null && Object.hasOwnProperty.call(message, "followGps"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.followGps);
            return writer;
        };

        /**
         * Encodes the specified Map message, length delimited. Does not implicitly {@link meshtastic.Map.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Map
         * @static
         * @param {meshtastic.IMap} message Map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Map.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Map message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Map} Map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Map.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Map();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.home = $root.meshtastic.GeoPoint.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.style = reader.string();
                        break;
                    }
                case 3: {
                        message.followGps = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Map message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Map} Map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Map.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Map message.
         * @function verify
         * @memberof meshtastic.Map
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Map.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.home != null && message.hasOwnProperty("home")) {
                var error = $root.meshtastic.GeoPoint.verify(message.home);
                if (error)
                    return "home." + error;
            }
            if (message.style != null && message.hasOwnProperty("style"))
                if (!$util.isString(message.style))
                    return "style: string expected";
            if (message.followGps != null && message.hasOwnProperty("followGps"))
                if (typeof message.followGps !== "boolean")
                    return "followGps: boolean expected";
            return null;
        };

        /**
         * Creates a Map message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Map
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Map} Map
         */
        Map.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Map)
                return object;
            var message = new $root.meshtastic.Map();
            if (object.home != null) {
                if (typeof object.home !== "object")
                    throw TypeError(".meshtastic.Map.home: object expected");
                message.home = $root.meshtastic.GeoPoint.fromObject(object.home);
            }
            if (object.style != null)
                message.style = String(object.style);
            if (object.followGps != null)
                message.followGps = Boolean(object.followGps);
            return message;
        };

        /**
         * Creates a plain object from a Map message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Map
         * @static
         * @param {meshtastic.Map} message Map
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Map.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.home = null;
                object.style = "";
                object.followGps = false;
            }
            if (message.home != null && message.hasOwnProperty("home"))
                object.home = $root.meshtastic.GeoPoint.toObject(message.home, options);
            if (message.style != null && message.hasOwnProperty("style"))
                object.style = message.style;
            if (message.followGps != null && message.hasOwnProperty("followGps"))
                object.followGps = message.followGps;
            return object;
        };

        /**
         * Converts this Map to JSON.
         * @function toJSON
         * @memberof meshtastic.Map
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Map.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Map
         * @function getTypeUrl
         * @memberof meshtastic.Map
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Map";
        };

        return Map;
    })();

    /**
     * CompassMode enum.
     * @name meshtastic.CompassMode
     * @enum {number}
     * @property {number} DYNAMIC=0 DYNAMIC value
     * @property {number} FIXED_RING=1 FIXED_RING value
     * @property {number} FREEZE_HEADING=2 FREEZE_HEADING value
     */
    meshtastic.CompassMode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DYNAMIC"] = 0;
        values[valuesById[1] = "FIXED_RING"] = 1;
        values[valuesById[2] = "FREEZE_HEADING"] = 2;
        return values;
    })();

    /**
     * Theme enum.
     * @name meshtastic.Theme
     * @enum {number}
     * @property {number} DARK=0 DARK value
     * @property {number} LIGHT=1 LIGHT value
     * @property {number} RED=2 RED value
     */
    meshtastic.Theme = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DARK"] = 0;
        values[valuesById[1] = "LIGHT"] = 1;
        values[valuesById[2] = "RED"] = 2;
        return values;
    })();

    /**
     * Language enum.
     * @name meshtastic.Language
     * @enum {number}
     * @property {number} ENGLISH=0 ENGLISH value
     * @property {number} FRENCH=1 FRENCH value
     * @property {number} GERMAN=2 GERMAN value
     * @property {number} ITALIAN=3 ITALIAN value
     * @property {number} PORTUGUESE=4 PORTUGUESE value
     * @property {number} SPANISH=5 SPANISH value
     * @property {number} SWEDISH=6 SWEDISH value
     * @property {number} FINNISH=7 FINNISH value
     * @property {number} POLISH=8 POLISH value
     * @property {number} TURKISH=9 TURKISH value
     * @property {number} SERBIAN=10 SERBIAN value
     * @property {number} RUSSIAN=11 RUSSIAN value
     * @property {number} DUTCH=12 DUTCH value
     * @property {number} GREEK=13 GREEK value
     * @property {number} NORWEGIAN=14 NORWEGIAN value
     * @property {number} SLOVENIAN=15 SLOVENIAN value
     * @property {number} UKRAINIAN=16 UKRAINIAN value
     * @property {number} BULGARIAN=17 BULGARIAN value
     * @property {number} CZECH=18 CZECH value
     * @property {number} DANISH=19 DANISH value
     * @property {number} SIMPLIFIED_CHINESE=30 SIMPLIFIED_CHINESE value
     * @property {number} TRADITIONAL_CHINESE=31 TRADITIONAL_CHINESE value
     */
    meshtastic.Language = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENGLISH"] = 0;
        values[valuesById[1] = "FRENCH"] = 1;
        values[valuesById[2] = "GERMAN"] = 2;
        values[valuesById[3] = "ITALIAN"] = 3;
        values[valuesById[4] = "PORTUGUESE"] = 4;
        values[valuesById[5] = "SPANISH"] = 5;
        values[valuesById[6] = "SWEDISH"] = 6;
        values[valuesById[7] = "FINNISH"] = 7;
        values[valuesById[8] = "POLISH"] = 8;
        values[valuesById[9] = "TURKISH"] = 9;
        values[valuesById[10] = "SERBIAN"] = 10;
        values[valuesById[11] = "RUSSIAN"] = 11;
        values[valuesById[12] = "DUTCH"] = 12;
        values[valuesById[13] = "GREEK"] = 13;
        values[valuesById[14] = "NORWEGIAN"] = 14;
        values[valuesById[15] = "SLOVENIAN"] = 15;
        values[valuesById[16] = "UKRAINIAN"] = 16;
        values[valuesById[17] = "BULGARIAN"] = 17;
        values[valuesById[18] = "CZECH"] = 18;
        values[valuesById[19] = "DANISH"] = 19;
        values[valuesById[30] = "SIMPLIFIED_CHINESE"] = 30;
        values[valuesById[31] = "TRADITIONAL_CHINESE"] = 31;
        return values;
    })();

    meshtastic.Position = (function() {

        /**
         * Properties of a Position.
         * @memberof meshtastic
         * @interface IPosition
         * @property {number|null} [latitudeI] Position latitudeI
         * @property {number|null} [longitudeI] Position longitudeI
         * @property {number|null} [altitude] Position altitude
         * @property {number|null} [time] Position time
         * @property {meshtastic.Position.LocSource|null} [locationSource] Position locationSource
         * @property {meshtastic.Position.AltSource|null} [altitudeSource] Position altitudeSource
         * @property {number|null} [timestamp] Position timestamp
         * @property {number|null} [timestampMillisAdjust] Position timestampMillisAdjust
         * @property {number|null} [altitudeHae] Position altitudeHae
         * @property {number|null} [altitudeGeoidalSeparation] Position altitudeGeoidalSeparation
         * @property {number|null} [PDOP] Position PDOP
         * @property {number|null} [HDOP] Position HDOP
         * @property {number|null} [VDOP] Position VDOP
         * @property {number|null} [gpsAccuracy] Position gpsAccuracy
         * @property {number|null} [groundSpeed] Position groundSpeed
         * @property {number|null} [groundTrack] Position groundTrack
         * @property {number|null} [fixQuality] Position fixQuality
         * @property {number|null} [fixType] Position fixType
         * @property {number|null} [satsInView] Position satsInView
         * @property {number|null} [sensorId] Position sensorId
         * @property {number|null} [nextUpdate] Position nextUpdate
         * @property {number|null} [seqNumber] Position seqNumber
         * @property {number|null} [precisionBits] Position precisionBits
         */

        /**
         * Constructs a new Position.
         * @memberof meshtastic
         * @classdesc Represents a Position.
         * @implements IPosition
         * @constructor
         * @param {meshtastic.IPosition=} [properties] Properties to set
         */
        function Position(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Position latitudeI.
         * @member {number|null|undefined} latitudeI
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.latitudeI = null;

        /**
         * Position longitudeI.
         * @member {number|null|undefined} longitudeI
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.longitudeI = null;

        /**
         * Position altitude.
         * @member {number|null|undefined} altitude
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.altitude = null;

        /**
         * Position time.
         * @member {number} time
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.time = 0;

        /**
         * Position locationSource.
         * @member {meshtastic.Position.LocSource} locationSource
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.locationSource = 0;

        /**
         * Position altitudeSource.
         * @member {meshtastic.Position.AltSource} altitudeSource
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.altitudeSource = 0;

        /**
         * Position timestamp.
         * @member {number} timestamp
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.timestamp = 0;

        /**
         * Position timestampMillisAdjust.
         * @member {number} timestampMillisAdjust
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.timestampMillisAdjust = 0;

        /**
         * Position altitudeHae.
         * @member {number|null|undefined} altitudeHae
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.altitudeHae = null;

        /**
         * Position altitudeGeoidalSeparation.
         * @member {number|null|undefined} altitudeGeoidalSeparation
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.altitudeGeoidalSeparation = null;

        /**
         * Position PDOP.
         * @member {number} PDOP
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.PDOP = 0;

        /**
         * Position HDOP.
         * @member {number} HDOP
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.HDOP = 0;

        /**
         * Position VDOP.
         * @member {number} VDOP
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.VDOP = 0;

        /**
         * Position gpsAccuracy.
         * @member {number} gpsAccuracy
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.gpsAccuracy = 0;

        /**
         * Position groundSpeed.
         * @member {number|null|undefined} groundSpeed
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.groundSpeed = null;

        /**
         * Position groundTrack.
         * @member {number|null|undefined} groundTrack
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.groundTrack = null;

        /**
         * Position fixQuality.
         * @member {number} fixQuality
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.fixQuality = 0;

        /**
         * Position fixType.
         * @member {number} fixType
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.fixType = 0;

        /**
         * Position satsInView.
         * @member {number} satsInView
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.satsInView = 0;

        /**
         * Position sensorId.
         * @member {number} sensorId
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.sensorId = 0;

        /**
         * Position nextUpdate.
         * @member {number} nextUpdate
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.nextUpdate = 0;

        /**
         * Position seqNumber.
         * @member {number} seqNumber
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.seqNumber = 0;

        /**
         * Position precisionBits.
         * @member {number} precisionBits
         * @memberof meshtastic.Position
         * @instance
         */
        Position.prototype.precisionBits = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Position _latitudeI.
         * @member {"latitudeI"|undefined} _latitudeI
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_latitudeI", {
            get: $util.oneOfGetter($oneOfFields = ["latitudeI"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _longitudeI.
         * @member {"longitudeI"|undefined} _longitudeI
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_longitudeI", {
            get: $util.oneOfGetter($oneOfFields = ["longitudeI"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _altitude.
         * @member {"altitude"|undefined} _altitude
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_altitude", {
            get: $util.oneOfGetter($oneOfFields = ["altitude"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _altitudeHae.
         * @member {"altitudeHae"|undefined} _altitudeHae
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_altitudeHae", {
            get: $util.oneOfGetter($oneOfFields = ["altitudeHae"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _altitudeGeoidalSeparation.
         * @member {"altitudeGeoidalSeparation"|undefined} _altitudeGeoidalSeparation
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_altitudeGeoidalSeparation", {
            get: $util.oneOfGetter($oneOfFields = ["altitudeGeoidalSeparation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _groundSpeed.
         * @member {"groundSpeed"|undefined} _groundSpeed
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_groundSpeed", {
            get: $util.oneOfGetter($oneOfFields = ["groundSpeed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Position _groundTrack.
         * @member {"groundTrack"|undefined} _groundTrack
         * @memberof meshtastic.Position
         * @instance
         */
        Object.defineProperty(Position.prototype, "_groundTrack", {
            get: $util.oneOfGetter($oneOfFields = ["groundTrack"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Position instance using the specified properties.
         * @function create
         * @memberof meshtastic.Position
         * @static
         * @param {meshtastic.IPosition=} [properties] Properties to set
         * @returns {meshtastic.Position} Position instance
         */
        Position.create = function create(properties) {
            return new Position(properties);
        };

        /**
         * Encodes the specified Position message. Does not implicitly {@link meshtastic.Position.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Position
         * @static
         * @param {meshtastic.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.latitudeI != null && Object.hasOwnProperty.call(message, "latitudeI"))
                writer.uint32(/* id 1, wireType 5 =*/13).sfixed32(message.latitudeI);
            if (message.longitudeI != null && Object.hasOwnProperty.call(message, "longitudeI"))
                writer.uint32(/* id 2, wireType 5 =*/21).sfixed32(message.longitudeI);
            if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.altitude);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.time);
            if (message.locationSource != null && Object.hasOwnProperty.call(message, "locationSource"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.locationSource);
            if (message.altitudeSource != null && Object.hasOwnProperty.call(message, "altitudeSource"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.altitudeSource);
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.timestamp);
            if (message.timestampMillisAdjust != null && Object.hasOwnProperty.call(message, "timestampMillisAdjust"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.timestampMillisAdjust);
            if (message.altitudeHae != null && Object.hasOwnProperty.call(message, "altitudeHae"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.altitudeHae);
            if (message.altitudeGeoidalSeparation != null && Object.hasOwnProperty.call(message, "altitudeGeoidalSeparation"))
                writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.altitudeGeoidalSeparation);
            if (message.PDOP != null && Object.hasOwnProperty.call(message, "PDOP"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.PDOP);
            if (message.HDOP != null && Object.hasOwnProperty.call(message, "HDOP"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.HDOP);
            if (message.VDOP != null && Object.hasOwnProperty.call(message, "VDOP"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.VDOP);
            if (message.gpsAccuracy != null && Object.hasOwnProperty.call(message, "gpsAccuracy"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.gpsAccuracy);
            if (message.groundSpeed != null && Object.hasOwnProperty.call(message, "groundSpeed"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.groundSpeed);
            if (message.groundTrack != null && Object.hasOwnProperty.call(message, "groundTrack"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.groundTrack);
            if (message.fixQuality != null && Object.hasOwnProperty.call(message, "fixQuality"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.fixQuality);
            if (message.fixType != null && Object.hasOwnProperty.call(message, "fixType"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.fixType);
            if (message.satsInView != null && Object.hasOwnProperty.call(message, "satsInView"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.satsInView);
            if (message.sensorId != null && Object.hasOwnProperty.call(message, "sensorId"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.sensorId);
            if (message.nextUpdate != null && Object.hasOwnProperty.call(message, "nextUpdate"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.nextUpdate);
            if (message.seqNumber != null && Object.hasOwnProperty.call(message, "seqNumber"))
                writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.seqNumber);
            if (message.precisionBits != null && Object.hasOwnProperty.call(message, "precisionBits"))
                writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.precisionBits);
            return writer;
        };

        /**
         * Encodes the specified Position message, length delimited. Does not implicitly {@link meshtastic.Position.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Position
         * @static
         * @param {meshtastic.IPosition} message Position message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Position.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Position message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Position();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.latitudeI = reader.sfixed32();
                        break;
                    }
                case 2: {
                        message.longitudeI = reader.sfixed32();
                        break;
                    }
                case 3: {
                        message.altitude = reader.int32();
                        break;
                    }
                case 4: {
                        message.time = reader.fixed32();
                        break;
                    }
                case 5: {
                        message.locationSource = reader.int32();
                        break;
                    }
                case 6: {
                        message.altitudeSource = reader.int32();
                        break;
                    }
                case 7: {
                        message.timestamp = reader.fixed32();
                        break;
                    }
                case 8: {
                        message.timestampMillisAdjust = reader.int32();
                        break;
                    }
                case 9: {
                        message.altitudeHae = reader.sint32();
                        break;
                    }
                case 10: {
                        message.altitudeGeoidalSeparation = reader.sint32();
                        break;
                    }
                case 11: {
                        message.PDOP = reader.uint32();
                        break;
                    }
                case 12: {
                        message.HDOP = reader.uint32();
                        break;
                    }
                case 13: {
                        message.VDOP = reader.uint32();
                        break;
                    }
                case 14: {
                        message.gpsAccuracy = reader.uint32();
                        break;
                    }
                case 15: {
                        message.groundSpeed = reader.uint32();
                        break;
                    }
                case 16: {
                        message.groundTrack = reader.uint32();
                        break;
                    }
                case 17: {
                        message.fixQuality = reader.uint32();
                        break;
                    }
                case 18: {
                        message.fixType = reader.uint32();
                        break;
                    }
                case 19: {
                        message.satsInView = reader.uint32();
                        break;
                    }
                case 20: {
                        message.sensorId = reader.uint32();
                        break;
                    }
                case 21: {
                        message.nextUpdate = reader.uint32();
                        break;
                    }
                case 22: {
                        message.seqNumber = reader.uint32();
                        break;
                    }
                case 23: {
                        message.precisionBits = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Position message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Position
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Position} Position
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Position.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Position message.
         * @function verify
         * @memberof meshtastic.Position
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Position.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI")) {
                properties._latitudeI = 1;
                if (!$util.isInteger(message.latitudeI))
                    return "latitudeI: integer expected";
            }
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI")) {
                properties._longitudeI = 1;
                if (!$util.isInteger(message.longitudeI))
                    return "longitudeI: integer expected";
            }
            if (message.altitude != null && message.hasOwnProperty("altitude")) {
                properties._altitude = 1;
                if (!$util.isInteger(message.altitude))
                    return "altitude: integer expected";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.locationSource != null && message.hasOwnProperty("locationSource"))
                switch (message.locationSource) {
                default:
                    return "locationSource: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.altitudeSource != null && message.hasOwnProperty("altitudeSource"))
                switch (message.altitudeSource) {
                default:
                    return "altitudeSource: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp))
                    return "timestamp: integer expected";
            if (message.timestampMillisAdjust != null && message.hasOwnProperty("timestampMillisAdjust"))
                if (!$util.isInteger(message.timestampMillisAdjust))
                    return "timestampMillisAdjust: integer expected";
            if (message.altitudeHae != null && message.hasOwnProperty("altitudeHae")) {
                properties._altitudeHae = 1;
                if (!$util.isInteger(message.altitudeHae))
                    return "altitudeHae: integer expected";
            }
            if (message.altitudeGeoidalSeparation != null && message.hasOwnProperty("altitudeGeoidalSeparation")) {
                properties._altitudeGeoidalSeparation = 1;
                if (!$util.isInteger(message.altitudeGeoidalSeparation))
                    return "altitudeGeoidalSeparation: integer expected";
            }
            if (message.PDOP != null && message.hasOwnProperty("PDOP"))
                if (!$util.isInteger(message.PDOP))
                    return "PDOP: integer expected";
            if (message.HDOP != null && message.hasOwnProperty("HDOP"))
                if (!$util.isInteger(message.HDOP))
                    return "HDOP: integer expected";
            if (message.VDOP != null && message.hasOwnProperty("VDOP"))
                if (!$util.isInteger(message.VDOP))
                    return "VDOP: integer expected";
            if (message.gpsAccuracy != null && message.hasOwnProperty("gpsAccuracy"))
                if (!$util.isInteger(message.gpsAccuracy))
                    return "gpsAccuracy: integer expected";
            if (message.groundSpeed != null && message.hasOwnProperty("groundSpeed")) {
                properties._groundSpeed = 1;
                if (!$util.isInteger(message.groundSpeed))
                    return "groundSpeed: integer expected";
            }
            if (message.groundTrack != null && message.hasOwnProperty("groundTrack")) {
                properties._groundTrack = 1;
                if (!$util.isInteger(message.groundTrack))
                    return "groundTrack: integer expected";
            }
            if (message.fixQuality != null && message.hasOwnProperty("fixQuality"))
                if (!$util.isInteger(message.fixQuality))
                    return "fixQuality: integer expected";
            if (message.fixType != null && message.hasOwnProperty("fixType"))
                if (!$util.isInteger(message.fixType))
                    return "fixType: integer expected";
            if (message.satsInView != null && message.hasOwnProperty("satsInView"))
                if (!$util.isInteger(message.satsInView))
                    return "satsInView: integer expected";
            if (message.sensorId != null && message.hasOwnProperty("sensorId"))
                if (!$util.isInteger(message.sensorId))
                    return "sensorId: integer expected";
            if (message.nextUpdate != null && message.hasOwnProperty("nextUpdate"))
                if (!$util.isInteger(message.nextUpdate))
                    return "nextUpdate: integer expected";
            if (message.seqNumber != null && message.hasOwnProperty("seqNumber"))
                if (!$util.isInteger(message.seqNumber))
                    return "seqNumber: integer expected";
            if (message.precisionBits != null && message.hasOwnProperty("precisionBits"))
                if (!$util.isInteger(message.precisionBits))
                    return "precisionBits: integer expected";
            return null;
        };

        /**
         * Creates a Position message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Position
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Position} Position
         */
        Position.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Position)
                return object;
            var message = new $root.meshtastic.Position();
            if (object.latitudeI != null)
                message.latitudeI = object.latitudeI | 0;
            if (object.longitudeI != null)
                message.longitudeI = object.longitudeI | 0;
            if (object.altitude != null)
                message.altitude = object.altitude | 0;
            if (object.time != null)
                message.time = object.time >>> 0;
            switch (object.locationSource) {
            default:
                if (typeof object.locationSource === "number") {
                    message.locationSource = object.locationSource;
                    break;
                }
                break;
            case "LOC_UNSET":
            case 0:
                message.locationSource = 0;
                break;
            case "LOC_MANUAL":
            case 1:
                message.locationSource = 1;
                break;
            case "LOC_INTERNAL":
            case 2:
                message.locationSource = 2;
                break;
            case "LOC_EXTERNAL":
            case 3:
                message.locationSource = 3;
                break;
            }
            switch (object.altitudeSource) {
            default:
                if (typeof object.altitudeSource === "number") {
                    message.altitudeSource = object.altitudeSource;
                    break;
                }
                break;
            case "ALT_UNSET":
            case 0:
                message.altitudeSource = 0;
                break;
            case "ALT_MANUAL":
            case 1:
                message.altitudeSource = 1;
                break;
            case "ALT_INTERNAL":
            case 2:
                message.altitudeSource = 2;
                break;
            case "ALT_EXTERNAL":
            case 3:
                message.altitudeSource = 3;
                break;
            case "ALT_BAROMETRIC":
            case 4:
                message.altitudeSource = 4;
                break;
            }
            if (object.timestamp != null)
                message.timestamp = object.timestamp >>> 0;
            if (object.timestampMillisAdjust != null)
                message.timestampMillisAdjust = object.timestampMillisAdjust | 0;
            if (object.altitudeHae != null)
                message.altitudeHae = object.altitudeHae | 0;
            if (object.altitudeGeoidalSeparation != null)
                message.altitudeGeoidalSeparation = object.altitudeGeoidalSeparation | 0;
            if (object.PDOP != null)
                message.PDOP = object.PDOP >>> 0;
            if (object.HDOP != null)
                message.HDOP = object.HDOP >>> 0;
            if (object.VDOP != null)
                message.VDOP = object.VDOP >>> 0;
            if (object.gpsAccuracy != null)
                message.gpsAccuracy = object.gpsAccuracy >>> 0;
            if (object.groundSpeed != null)
                message.groundSpeed = object.groundSpeed >>> 0;
            if (object.groundTrack != null)
                message.groundTrack = object.groundTrack >>> 0;
            if (object.fixQuality != null)
                message.fixQuality = object.fixQuality >>> 0;
            if (object.fixType != null)
                message.fixType = object.fixType >>> 0;
            if (object.satsInView != null)
                message.satsInView = object.satsInView >>> 0;
            if (object.sensorId != null)
                message.sensorId = object.sensorId >>> 0;
            if (object.nextUpdate != null)
                message.nextUpdate = object.nextUpdate >>> 0;
            if (object.seqNumber != null)
                message.seqNumber = object.seqNumber >>> 0;
            if (object.precisionBits != null)
                message.precisionBits = object.precisionBits >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Position message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Position
         * @static
         * @param {meshtastic.Position} message Position
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Position.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = 0;
                object.locationSource = options.enums === String ? "LOC_UNSET" : 0;
                object.altitudeSource = options.enums === String ? "ALT_UNSET" : 0;
                object.timestamp = 0;
                object.timestampMillisAdjust = 0;
                object.PDOP = 0;
                object.HDOP = 0;
                object.VDOP = 0;
                object.gpsAccuracy = 0;
                object.fixQuality = 0;
                object.fixType = 0;
                object.satsInView = 0;
                object.sensorId = 0;
                object.nextUpdate = 0;
                object.seqNumber = 0;
                object.precisionBits = 0;
            }
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI")) {
                object.latitudeI = message.latitudeI;
                if (options.oneofs)
                    object._latitudeI = "latitudeI";
            }
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI")) {
                object.longitudeI = message.longitudeI;
                if (options.oneofs)
                    object._longitudeI = "longitudeI";
            }
            if (message.altitude != null && message.hasOwnProperty("altitude")) {
                object.altitude = message.altitude;
                if (options.oneofs)
                    object._altitude = "altitude";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.locationSource != null && message.hasOwnProperty("locationSource"))
                object.locationSource = options.enums === String ? $root.meshtastic.Position.LocSource[message.locationSource] === undefined ? message.locationSource : $root.meshtastic.Position.LocSource[message.locationSource] : message.locationSource;
            if (message.altitudeSource != null && message.hasOwnProperty("altitudeSource"))
                object.altitudeSource = options.enums === String ? $root.meshtastic.Position.AltSource[message.altitudeSource] === undefined ? message.altitudeSource : $root.meshtastic.Position.AltSource[message.altitudeSource] : message.altitudeSource;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = message.timestamp;
            if (message.timestampMillisAdjust != null && message.hasOwnProperty("timestampMillisAdjust"))
                object.timestampMillisAdjust = message.timestampMillisAdjust;
            if (message.altitudeHae != null && message.hasOwnProperty("altitudeHae")) {
                object.altitudeHae = message.altitudeHae;
                if (options.oneofs)
                    object._altitudeHae = "altitudeHae";
            }
            if (message.altitudeGeoidalSeparation != null && message.hasOwnProperty("altitudeGeoidalSeparation")) {
                object.altitudeGeoidalSeparation = message.altitudeGeoidalSeparation;
                if (options.oneofs)
                    object._altitudeGeoidalSeparation = "altitudeGeoidalSeparation";
            }
            if (message.PDOP != null && message.hasOwnProperty("PDOP"))
                object.PDOP = message.PDOP;
            if (message.HDOP != null && message.hasOwnProperty("HDOP"))
                object.HDOP = message.HDOP;
            if (message.VDOP != null && message.hasOwnProperty("VDOP"))
                object.VDOP = message.VDOP;
            if (message.gpsAccuracy != null && message.hasOwnProperty("gpsAccuracy"))
                object.gpsAccuracy = message.gpsAccuracy;
            if (message.groundSpeed != null && message.hasOwnProperty("groundSpeed")) {
                object.groundSpeed = message.groundSpeed;
                if (options.oneofs)
                    object._groundSpeed = "groundSpeed";
            }
            if (message.groundTrack != null && message.hasOwnProperty("groundTrack")) {
                object.groundTrack = message.groundTrack;
                if (options.oneofs)
                    object._groundTrack = "groundTrack";
            }
            if (message.fixQuality != null && message.hasOwnProperty("fixQuality"))
                object.fixQuality = message.fixQuality;
            if (message.fixType != null && message.hasOwnProperty("fixType"))
                object.fixType = message.fixType;
            if (message.satsInView != null && message.hasOwnProperty("satsInView"))
                object.satsInView = message.satsInView;
            if (message.sensorId != null && message.hasOwnProperty("sensorId"))
                object.sensorId = message.sensorId;
            if (message.nextUpdate != null && message.hasOwnProperty("nextUpdate"))
                object.nextUpdate = message.nextUpdate;
            if (message.seqNumber != null && message.hasOwnProperty("seqNumber"))
                object.seqNumber = message.seqNumber;
            if (message.precisionBits != null && message.hasOwnProperty("precisionBits"))
                object.precisionBits = message.precisionBits;
            return object;
        };

        /**
         * Converts this Position to JSON.
         * @function toJSON
         * @memberof meshtastic.Position
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Position.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Position
         * @function getTypeUrl
         * @memberof meshtastic.Position
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Position";
        };

        /**
         * LocSource enum.
         * @name meshtastic.Position.LocSource
         * @enum {number}
         * @property {number} LOC_UNSET=0 LOC_UNSET value
         * @property {number} LOC_MANUAL=1 LOC_MANUAL value
         * @property {number} LOC_INTERNAL=2 LOC_INTERNAL value
         * @property {number} LOC_EXTERNAL=3 LOC_EXTERNAL value
         */
        Position.LocSource = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LOC_UNSET"] = 0;
            values[valuesById[1] = "LOC_MANUAL"] = 1;
            values[valuesById[2] = "LOC_INTERNAL"] = 2;
            values[valuesById[3] = "LOC_EXTERNAL"] = 3;
            return values;
        })();

        /**
         * AltSource enum.
         * @name meshtastic.Position.AltSource
         * @enum {number}
         * @property {number} ALT_UNSET=0 ALT_UNSET value
         * @property {number} ALT_MANUAL=1 ALT_MANUAL value
         * @property {number} ALT_INTERNAL=2 ALT_INTERNAL value
         * @property {number} ALT_EXTERNAL=3 ALT_EXTERNAL value
         * @property {number} ALT_BAROMETRIC=4 ALT_BAROMETRIC value
         */
        Position.AltSource = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ALT_UNSET"] = 0;
            values[valuesById[1] = "ALT_MANUAL"] = 1;
            values[valuesById[2] = "ALT_INTERNAL"] = 2;
            values[valuesById[3] = "ALT_EXTERNAL"] = 3;
            values[valuesById[4] = "ALT_BAROMETRIC"] = 4;
            return values;
        })();

        return Position;
    })();

    /**
     * HardwareModel enum.
     * @name meshtastic.HardwareModel
     * @enum {number}
     * @property {number} UNSET=0 UNSET value
     * @property {number} TLORA_V2=1 TLORA_V2 value
     * @property {number} TLORA_V1=2 TLORA_V1 value
     * @property {number} TLORA_V2_1_1P6=3 TLORA_V2_1_1P6 value
     * @property {number} TBEAM=4 TBEAM value
     * @property {number} HELTEC_V2_0=5 HELTEC_V2_0 value
     * @property {number} TBEAM_V0P7=6 TBEAM_V0P7 value
     * @property {number} T_ECHO=7 T_ECHO value
     * @property {number} TLORA_V1_1P3=8 TLORA_V1_1P3 value
     * @property {number} RAK4631=9 RAK4631 value
     * @property {number} HELTEC_V2_1=10 HELTEC_V2_1 value
     * @property {number} HELTEC_V1=11 HELTEC_V1 value
     * @property {number} LILYGO_TBEAM_S3_CORE=12 LILYGO_TBEAM_S3_CORE value
     * @property {number} RAK11200=13 RAK11200 value
     * @property {number} NANO_G1=14 NANO_G1 value
     * @property {number} TLORA_V2_1_1P8=15 TLORA_V2_1_1P8 value
     * @property {number} TLORA_T3_S3=16 TLORA_T3_S3 value
     * @property {number} NANO_G1_EXPLORER=17 NANO_G1_EXPLORER value
     * @property {number} NANO_G2_ULTRA=18 NANO_G2_ULTRA value
     * @property {number} LORA_TYPE=19 LORA_TYPE value
     * @property {number} WIPHONE=20 WIPHONE value
     * @property {number} WIO_WM1110=21 WIO_WM1110 value
     * @property {number} RAK2560=22 RAK2560 value
     * @property {number} HELTEC_HRU_3601=23 HELTEC_HRU_3601 value
     * @property {number} HELTEC_WIRELESS_BRIDGE=24 HELTEC_WIRELESS_BRIDGE value
     * @property {number} STATION_G1=25 STATION_G1 value
     * @property {number} RAK11310=26 RAK11310 value
     * @property {number} SENSELORA_RP2040=27 SENSELORA_RP2040 value
     * @property {number} SENSELORA_S3=28 SENSELORA_S3 value
     * @property {number} CANARYONE=29 CANARYONE value
     * @property {number} RP2040_LORA=30 RP2040_LORA value
     * @property {number} STATION_G2=31 STATION_G2 value
     * @property {number} LORA_RELAY_V1=32 LORA_RELAY_V1 value
     * @property {number} NRF52840DK=33 NRF52840DK value
     * @property {number} PPR=34 PPR value
     * @property {number} GENIEBLOCKS=35 GENIEBLOCKS value
     * @property {number} NRF52_UNKNOWN=36 NRF52_UNKNOWN value
     * @property {number} PORTDUINO=37 PORTDUINO value
     * @property {number} ANDROID_SIM=38 ANDROID_SIM value
     * @property {number} DIY_V1=39 DIY_V1 value
     * @property {number} NRF52840_PCA10059=40 NRF52840_PCA10059 value
     * @property {number} DR_DEV=41 DR_DEV value
     * @property {number} M5STACK=42 M5STACK value
     * @property {number} HELTEC_V3=43 HELTEC_V3 value
     * @property {number} HELTEC_WSL_V3=44 HELTEC_WSL_V3 value
     * @property {number} BETAFPV_2400_TX=45 BETAFPV_2400_TX value
     * @property {number} BETAFPV_900_NANO_TX=46 BETAFPV_900_NANO_TX value
     * @property {number} RPI_PICO=47 RPI_PICO value
     * @property {number} HELTEC_WIRELESS_TRACKER=48 HELTEC_WIRELESS_TRACKER value
     * @property {number} HELTEC_WIRELESS_PAPER=49 HELTEC_WIRELESS_PAPER value
     * @property {number} T_DECK=50 T_DECK value
     * @property {number} T_WATCH_S3=51 T_WATCH_S3 value
     * @property {number} PICOMPUTER_S3=52 PICOMPUTER_S3 value
     * @property {number} HELTEC_HT62=53 HELTEC_HT62 value
     * @property {number} EBYTE_ESP32_S3=54 EBYTE_ESP32_S3 value
     * @property {number} ESP32_S3_PICO=55 ESP32_S3_PICO value
     * @property {number} CHATTER_2=56 CHATTER_2 value
     * @property {number} HELTEC_WIRELESS_PAPER_V1_0=57 HELTEC_WIRELESS_PAPER_V1_0 value
     * @property {number} HELTEC_WIRELESS_TRACKER_V1_0=58 HELTEC_WIRELESS_TRACKER_V1_0 value
     * @property {number} UNPHONE=59 UNPHONE value
     * @property {number} TD_LORAC=60 TD_LORAC value
     * @property {number} CDEBYTE_EORA_S3=61 CDEBYTE_EORA_S3 value
     * @property {number} TWC_MESH_V4=62 TWC_MESH_V4 value
     * @property {number} NRF52_PROMICRO_DIY=63 NRF52_PROMICRO_DIY value
     * @property {number} RADIOMASTER_900_BANDIT_NANO=64 RADIOMASTER_900_BANDIT_NANO value
     * @property {number} HELTEC_CAPSULE_SENSOR_V3=65 HELTEC_CAPSULE_SENSOR_V3 value
     * @property {number} HELTEC_VISION_MASTER_T190=66 HELTEC_VISION_MASTER_T190 value
     * @property {number} HELTEC_VISION_MASTER_E213=67 HELTEC_VISION_MASTER_E213 value
     * @property {number} HELTEC_VISION_MASTER_E290=68 HELTEC_VISION_MASTER_E290 value
     * @property {number} HELTEC_MESH_NODE_T114=69 HELTEC_MESH_NODE_T114 value
     * @property {number} SENSECAP_INDICATOR=70 SENSECAP_INDICATOR value
     * @property {number} TRACKER_T1000_E=71 TRACKER_T1000_E value
     * @property {number} RAK3172=72 RAK3172 value
     * @property {number} WIO_E5=73 WIO_E5 value
     * @property {number} RADIOMASTER_900_BANDIT=74 RADIOMASTER_900_BANDIT value
     * @property {number} ME25LS01_4Y10TD=75 ME25LS01_4Y10TD value
     * @property {number} RP2040_FEATHER_RFM95=76 RP2040_FEATHER_RFM95 value
     * @property {number} M5STACK_COREBASIC=77 M5STACK_COREBASIC value
     * @property {number} M5STACK_CORE2=78 M5STACK_CORE2 value
     * @property {number} RPI_PICO2=79 RPI_PICO2 value
     * @property {number} M5STACK_CORES3=80 M5STACK_CORES3 value
     * @property {number} SEEED_XIAO_S3=81 SEEED_XIAO_S3 value
     * @property {number} MS24SF1=82 MS24SF1 value
     * @property {number} TLORA_C6=83 TLORA_C6 value
     * @property {number} WISMESH_TAP=84 WISMESH_TAP value
     * @property {number} ROUTASTIC=85 ROUTASTIC value
     * @property {number} MESH_TAB=86 MESH_TAB value
     * @property {number} MESHLINK=87 MESHLINK value
     * @property {number} XIAO_NRF52_KIT=88 XIAO_NRF52_KIT value
     * @property {number} THINKNODE_M1=89 THINKNODE_M1 value
     * @property {number} THINKNODE_M2=90 THINKNODE_M2 value
     * @property {number} T_ETH_ELITE=91 T_ETH_ELITE value
     * @property {number} HELTEC_SENSOR_HUB=92 HELTEC_SENSOR_HUB value
     * @property {number} RESERVED_FRIED_CHICKEN=93 RESERVED_FRIED_CHICKEN value
     * @property {number} HELTEC_MESH_POCKET=94 HELTEC_MESH_POCKET value
     * @property {number} SEEED_SOLAR_NODE=95 SEEED_SOLAR_NODE value
     * @property {number} NOMADSTAR_METEOR_PRO=96 NOMADSTAR_METEOR_PRO value
     * @property {number} CROWPANEL=97 CROWPANEL value
     * @property {number} LINK_32=98 LINK_32 value
     * @property {number} SEEED_WIO_TRACKER_L1=99 SEEED_WIO_TRACKER_L1 value
     * @property {number} SEEED_WIO_TRACKER_L1_EINK=100 SEEED_WIO_TRACKER_L1_EINK value
     * @property {number} MUZI_R1_NEO=101 MUZI_R1_NEO value
     * @property {number} T_DECK_PRO=102 T_DECK_PRO value
     * @property {number} T_LORA_PAGER=103 T_LORA_PAGER value
     * @property {number} M5STACK_RESERVED=104 M5STACK_RESERVED value
     * @property {number} WISMESH_TAG=105 WISMESH_TAG value
     * @property {number} RAK3312=106 RAK3312 value
     * @property {number} THINKNODE_M5=107 THINKNODE_M5 value
     * @property {number} HELTEC_MESH_SOLAR=108 HELTEC_MESH_SOLAR value
     * @property {number} T_ECHO_LITE=109 T_ECHO_LITE value
     * @property {number} HELTEC_V4=110 HELTEC_V4 value
     * @property {number} M5STACK_C6L=111 M5STACK_C6L value
     * @property {number} M5STACK_CARDPUTER_ADV=112 M5STACK_CARDPUTER_ADV value
     * @property {number} HELTEC_WIRELESS_TRACKER_V2=113 HELTEC_WIRELESS_TRACKER_V2 value
     * @property {number} T_WATCH_ULTRA=114 T_WATCH_ULTRA value
     * @property {number} THINKNODE_M3=115 THINKNODE_M3 value
     * @property {number} WISMESH_TAP_V2=116 WISMESH_TAP_V2 value
     * @property {number} RAK3401=117 RAK3401 value
     * @property {number} RAK6421=118 RAK6421 value
     * @property {number} THINKNODE_M4=119 THINKNODE_M4 value
     * @property {number} THINKNODE_M6=120 THINKNODE_M6 value
     * @property {number} PRIVATE_HW=255 PRIVATE_HW value
     */
    meshtastic.HardwareModel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNSET"] = 0;
        values[valuesById[1] = "TLORA_V2"] = 1;
        values[valuesById[2] = "TLORA_V1"] = 2;
        values[valuesById[3] = "TLORA_V2_1_1P6"] = 3;
        values[valuesById[4] = "TBEAM"] = 4;
        values[valuesById[5] = "HELTEC_V2_0"] = 5;
        values[valuesById[6] = "TBEAM_V0P7"] = 6;
        values[valuesById[7] = "T_ECHO"] = 7;
        values[valuesById[8] = "TLORA_V1_1P3"] = 8;
        values[valuesById[9] = "RAK4631"] = 9;
        values[valuesById[10] = "HELTEC_V2_1"] = 10;
        values[valuesById[11] = "HELTEC_V1"] = 11;
        values[valuesById[12] = "LILYGO_TBEAM_S3_CORE"] = 12;
        values[valuesById[13] = "RAK11200"] = 13;
        values[valuesById[14] = "NANO_G1"] = 14;
        values[valuesById[15] = "TLORA_V2_1_1P8"] = 15;
        values[valuesById[16] = "TLORA_T3_S3"] = 16;
        values[valuesById[17] = "NANO_G1_EXPLORER"] = 17;
        values[valuesById[18] = "NANO_G2_ULTRA"] = 18;
        values[valuesById[19] = "LORA_TYPE"] = 19;
        values[valuesById[20] = "WIPHONE"] = 20;
        values[valuesById[21] = "WIO_WM1110"] = 21;
        values[valuesById[22] = "RAK2560"] = 22;
        values[valuesById[23] = "HELTEC_HRU_3601"] = 23;
        values[valuesById[24] = "HELTEC_WIRELESS_BRIDGE"] = 24;
        values[valuesById[25] = "STATION_G1"] = 25;
        values[valuesById[26] = "RAK11310"] = 26;
        values[valuesById[27] = "SENSELORA_RP2040"] = 27;
        values[valuesById[28] = "SENSELORA_S3"] = 28;
        values[valuesById[29] = "CANARYONE"] = 29;
        values[valuesById[30] = "RP2040_LORA"] = 30;
        values[valuesById[31] = "STATION_G2"] = 31;
        values[valuesById[32] = "LORA_RELAY_V1"] = 32;
        values[valuesById[33] = "NRF52840DK"] = 33;
        values[valuesById[34] = "PPR"] = 34;
        values[valuesById[35] = "GENIEBLOCKS"] = 35;
        values[valuesById[36] = "NRF52_UNKNOWN"] = 36;
        values[valuesById[37] = "PORTDUINO"] = 37;
        values[valuesById[38] = "ANDROID_SIM"] = 38;
        values[valuesById[39] = "DIY_V1"] = 39;
        values[valuesById[40] = "NRF52840_PCA10059"] = 40;
        values[valuesById[41] = "DR_DEV"] = 41;
        values[valuesById[42] = "M5STACK"] = 42;
        values[valuesById[43] = "HELTEC_V3"] = 43;
        values[valuesById[44] = "HELTEC_WSL_V3"] = 44;
        values[valuesById[45] = "BETAFPV_2400_TX"] = 45;
        values[valuesById[46] = "BETAFPV_900_NANO_TX"] = 46;
        values[valuesById[47] = "RPI_PICO"] = 47;
        values[valuesById[48] = "HELTEC_WIRELESS_TRACKER"] = 48;
        values[valuesById[49] = "HELTEC_WIRELESS_PAPER"] = 49;
        values[valuesById[50] = "T_DECK"] = 50;
        values[valuesById[51] = "T_WATCH_S3"] = 51;
        values[valuesById[52] = "PICOMPUTER_S3"] = 52;
        values[valuesById[53] = "HELTEC_HT62"] = 53;
        values[valuesById[54] = "EBYTE_ESP32_S3"] = 54;
        values[valuesById[55] = "ESP32_S3_PICO"] = 55;
        values[valuesById[56] = "CHATTER_2"] = 56;
        values[valuesById[57] = "HELTEC_WIRELESS_PAPER_V1_0"] = 57;
        values[valuesById[58] = "HELTEC_WIRELESS_TRACKER_V1_0"] = 58;
        values[valuesById[59] = "UNPHONE"] = 59;
        values[valuesById[60] = "TD_LORAC"] = 60;
        values[valuesById[61] = "CDEBYTE_EORA_S3"] = 61;
        values[valuesById[62] = "TWC_MESH_V4"] = 62;
        values[valuesById[63] = "NRF52_PROMICRO_DIY"] = 63;
        values[valuesById[64] = "RADIOMASTER_900_BANDIT_NANO"] = 64;
        values[valuesById[65] = "HELTEC_CAPSULE_SENSOR_V3"] = 65;
        values[valuesById[66] = "HELTEC_VISION_MASTER_T190"] = 66;
        values[valuesById[67] = "HELTEC_VISION_MASTER_E213"] = 67;
        values[valuesById[68] = "HELTEC_VISION_MASTER_E290"] = 68;
        values[valuesById[69] = "HELTEC_MESH_NODE_T114"] = 69;
        values[valuesById[70] = "SENSECAP_INDICATOR"] = 70;
        values[valuesById[71] = "TRACKER_T1000_E"] = 71;
        values[valuesById[72] = "RAK3172"] = 72;
        values[valuesById[73] = "WIO_E5"] = 73;
        values[valuesById[74] = "RADIOMASTER_900_BANDIT"] = 74;
        values[valuesById[75] = "ME25LS01_4Y10TD"] = 75;
        values[valuesById[76] = "RP2040_FEATHER_RFM95"] = 76;
        values[valuesById[77] = "M5STACK_COREBASIC"] = 77;
        values[valuesById[78] = "M5STACK_CORE2"] = 78;
        values[valuesById[79] = "RPI_PICO2"] = 79;
        values[valuesById[80] = "M5STACK_CORES3"] = 80;
        values[valuesById[81] = "SEEED_XIAO_S3"] = 81;
        values[valuesById[82] = "MS24SF1"] = 82;
        values[valuesById[83] = "TLORA_C6"] = 83;
        values[valuesById[84] = "WISMESH_TAP"] = 84;
        values[valuesById[85] = "ROUTASTIC"] = 85;
        values[valuesById[86] = "MESH_TAB"] = 86;
        values[valuesById[87] = "MESHLINK"] = 87;
        values[valuesById[88] = "XIAO_NRF52_KIT"] = 88;
        values[valuesById[89] = "THINKNODE_M1"] = 89;
        values[valuesById[90] = "THINKNODE_M2"] = 90;
        values[valuesById[91] = "T_ETH_ELITE"] = 91;
        values[valuesById[92] = "HELTEC_SENSOR_HUB"] = 92;
        values[valuesById[93] = "RESERVED_FRIED_CHICKEN"] = 93;
        values[valuesById[94] = "HELTEC_MESH_POCKET"] = 94;
        values[valuesById[95] = "SEEED_SOLAR_NODE"] = 95;
        values[valuesById[96] = "NOMADSTAR_METEOR_PRO"] = 96;
        values[valuesById[97] = "CROWPANEL"] = 97;
        values[valuesById[98] = "LINK_32"] = 98;
        values[valuesById[99] = "SEEED_WIO_TRACKER_L1"] = 99;
        values[valuesById[100] = "SEEED_WIO_TRACKER_L1_EINK"] = 100;
        values[valuesById[101] = "MUZI_R1_NEO"] = 101;
        values[valuesById[102] = "T_DECK_PRO"] = 102;
        values[valuesById[103] = "T_LORA_PAGER"] = 103;
        values[valuesById[104] = "M5STACK_RESERVED"] = 104;
        values[valuesById[105] = "WISMESH_TAG"] = 105;
        values[valuesById[106] = "RAK3312"] = 106;
        values[valuesById[107] = "THINKNODE_M5"] = 107;
        values[valuesById[108] = "HELTEC_MESH_SOLAR"] = 108;
        values[valuesById[109] = "T_ECHO_LITE"] = 109;
        values[valuesById[110] = "HELTEC_V4"] = 110;
        values[valuesById[111] = "M5STACK_C6L"] = 111;
        values[valuesById[112] = "M5STACK_CARDPUTER_ADV"] = 112;
        values[valuesById[113] = "HELTEC_WIRELESS_TRACKER_V2"] = 113;
        values[valuesById[114] = "T_WATCH_ULTRA"] = 114;
        values[valuesById[115] = "THINKNODE_M3"] = 115;
        values[valuesById[116] = "WISMESH_TAP_V2"] = 116;
        values[valuesById[117] = "RAK3401"] = 117;
        values[valuesById[118] = "RAK6421"] = 118;
        values[valuesById[119] = "THINKNODE_M4"] = 119;
        values[valuesById[120] = "THINKNODE_M6"] = 120;
        values[valuesById[255] = "PRIVATE_HW"] = 255;
        return values;
    })();

    meshtastic.User = (function() {

        /**
         * Properties of a User.
         * @memberof meshtastic
         * @interface IUser
         * @property {string|null} [id] User id
         * @property {string|null} [longName] User longName
         * @property {string|null} [shortName] User shortName
         * @property {Uint8Array|null} [macaddr] User macaddr
         * @property {meshtastic.HardwareModel|null} [hwModel] User hwModel
         * @property {boolean|null} [isLicensed] User isLicensed
         * @property {meshtastic.Config.DeviceConfig.Role|null} [role] User role
         * @property {Uint8Array|null} [publicKey] User publicKey
         * @property {boolean|null} [isUnmessagable] User isUnmessagable
         */

        /**
         * Constructs a new User.
         * @memberof meshtastic
         * @classdesc Represents a User.
         * @implements IUser
         * @constructor
         * @param {meshtastic.IUser=} [properties] Properties to set
         */
        function User(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * User id.
         * @member {string} id
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.id = "";

        /**
         * User longName.
         * @member {string} longName
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.longName = "";

        /**
         * User shortName.
         * @member {string} shortName
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.shortName = "";

        /**
         * User macaddr.
         * @member {Uint8Array} macaddr
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.macaddr = $util.newBuffer([]);

        /**
         * User hwModel.
         * @member {meshtastic.HardwareModel} hwModel
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.hwModel = 0;

        /**
         * User isLicensed.
         * @member {boolean} isLicensed
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.isLicensed = false;

        /**
         * User role.
         * @member {meshtastic.Config.DeviceConfig.Role} role
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.role = 0;

        /**
         * User publicKey.
         * @member {Uint8Array} publicKey
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.publicKey = $util.newBuffer([]);

        /**
         * User isUnmessagable.
         * @member {boolean|null|undefined} isUnmessagable
         * @memberof meshtastic.User
         * @instance
         */
        User.prototype.isUnmessagable = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * User _isUnmessagable.
         * @member {"isUnmessagable"|undefined} _isUnmessagable
         * @memberof meshtastic.User
         * @instance
         */
        Object.defineProperty(User.prototype, "_isUnmessagable", {
            get: $util.oneOfGetter($oneOfFields = ["isUnmessagable"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new User instance using the specified properties.
         * @function create
         * @memberof meshtastic.User
         * @static
         * @param {meshtastic.IUser=} [properties] Properties to set
         * @returns {meshtastic.User} User instance
         */
        User.create = function create(properties) {
            return new User(properties);
        };

        /**
         * Encodes the specified User message. Does not implicitly {@link meshtastic.User.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.User
         * @static
         * @param {meshtastic.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.longName != null && Object.hasOwnProperty.call(message, "longName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.longName);
            if (message.shortName != null && Object.hasOwnProperty.call(message, "shortName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.shortName);
            if (message.macaddr != null && Object.hasOwnProperty.call(message, "macaddr"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.macaddr);
            if (message.hwModel != null && Object.hasOwnProperty.call(message, "hwModel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.hwModel);
            if (message.isLicensed != null && Object.hasOwnProperty.call(message, "isLicensed"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isLicensed);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.role);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.publicKey);
            if (message.isUnmessagable != null && Object.hasOwnProperty.call(message, "isUnmessagable"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isUnmessagable);
            return writer;
        };

        /**
         * Encodes the specified User message, length delimited. Does not implicitly {@link meshtastic.User.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.User
         * @static
         * @param {meshtastic.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a User message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.User();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.longName = reader.string();
                        break;
                    }
                case 3: {
                        message.shortName = reader.string();
                        break;
                    }
                case 4: {
                        message.macaddr = reader.bytes();
                        break;
                    }
                case 5: {
                        message.hwModel = reader.int32();
                        break;
                    }
                case 6: {
                        message.isLicensed = reader.bool();
                        break;
                    }
                case 7: {
                        message.role = reader.int32();
                        break;
                    }
                case 8: {
                        message.publicKey = reader.bytes();
                        break;
                    }
                case 9: {
                        message.isUnmessagable = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a User message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a User message.
         * @function verify
         * @memberof meshtastic.User
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        User.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.longName != null && message.hasOwnProperty("longName"))
                if (!$util.isString(message.longName))
                    return "longName: string expected";
            if (message.shortName != null && message.hasOwnProperty("shortName"))
                if (!$util.isString(message.shortName))
                    return "shortName: string expected";
            if (message.macaddr != null && message.hasOwnProperty("macaddr"))
                if (!(message.macaddr && typeof message.macaddr.length === "number" || $util.isString(message.macaddr)))
                    return "macaddr: buffer expected";
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                switch (message.hwModel) {
                default:
                    return "hwModel: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 255:
                    break;
                }
            if (message.isLicensed != null && message.hasOwnProperty("isLicensed"))
                if (typeof message.isLicensed !== "boolean")
                    return "isLicensed: boolean expected";
            if (message.role != null && message.hasOwnProperty("role"))
                switch (message.role) {
                default:
                    return "role: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.isUnmessagable != null && message.hasOwnProperty("isUnmessagable")) {
                properties._isUnmessagable = 1;
                if (typeof message.isUnmessagable !== "boolean")
                    return "isUnmessagable: boolean expected";
            }
            return null;
        };

        /**
         * Creates a User message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.User
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.User} User
         */
        User.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.User)
                return object;
            var message = new $root.meshtastic.User();
            if (object.id != null)
                message.id = String(object.id);
            if (object.longName != null)
                message.longName = String(object.longName);
            if (object.shortName != null)
                message.shortName = String(object.shortName);
            if (object.macaddr != null)
                if (typeof object.macaddr === "string")
                    $util.base64.decode(object.macaddr, message.macaddr = $util.newBuffer($util.base64.length(object.macaddr)), 0);
                else if (object.macaddr.length >= 0)
                    message.macaddr = object.macaddr;
            switch (object.hwModel) {
            default:
                if (typeof object.hwModel === "number") {
                    message.hwModel = object.hwModel;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.hwModel = 0;
                break;
            case "TLORA_V2":
            case 1:
                message.hwModel = 1;
                break;
            case "TLORA_V1":
            case 2:
                message.hwModel = 2;
                break;
            case "TLORA_V2_1_1P6":
            case 3:
                message.hwModel = 3;
                break;
            case "TBEAM":
            case 4:
                message.hwModel = 4;
                break;
            case "HELTEC_V2_0":
            case 5:
                message.hwModel = 5;
                break;
            case "TBEAM_V0P7":
            case 6:
                message.hwModel = 6;
                break;
            case "T_ECHO":
            case 7:
                message.hwModel = 7;
                break;
            case "TLORA_V1_1P3":
            case 8:
                message.hwModel = 8;
                break;
            case "RAK4631":
            case 9:
                message.hwModel = 9;
                break;
            case "HELTEC_V2_1":
            case 10:
                message.hwModel = 10;
                break;
            case "HELTEC_V1":
            case 11:
                message.hwModel = 11;
                break;
            case "LILYGO_TBEAM_S3_CORE":
            case 12:
                message.hwModel = 12;
                break;
            case "RAK11200":
            case 13:
                message.hwModel = 13;
                break;
            case "NANO_G1":
            case 14:
                message.hwModel = 14;
                break;
            case "TLORA_V2_1_1P8":
            case 15:
                message.hwModel = 15;
                break;
            case "TLORA_T3_S3":
            case 16:
                message.hwModel = 16;
                break;
            case "NANO_G1_EXPLORER":
            case 17:
                message.hwModel = 17;
                break;
            case "NANO_G2_ULTRA":
            case 18:
                message.hwModel = 18;
                break;
            case "LORA_TYPE":
            case 19:
                message.hwModel = 19;
                break;
            case "WIPHONE":
            case 20:
                message.hwModel = 20;
                break;
            case "WIO_WM1110":
            case 21:
                message.hwModel = 21;
                break;
            case "RAK2560":
            case 22:
                message.hwModel = 22;
                break;
            case "HELTEC_HRU_3601":
            case 23:
                message.hwModel = 23;
                break;
            case "HELTEC_WIRELESS_BRIDGE":
            case 24:
                message.hwModel = 24;
                break;
            case "STATION_G1":
            case 25:
                message.hwModel = 25;
                break;
            case "RAK11310":
            case 26:
                message.hwModel = 26;
                break;
            case "SENSELORA_RP2040":
            case 27:
                message.hwModel = 27;
                break;
            case "SENSELORA_S3":
            case 28:
                message.hwModel = 28;
                break;
            case "CANARYONE":
            case 29:
                message.hwModel = 29;
                break;
            case "RP2040_LORA":
            case 30:
                message.hwModel = 30;
                break;
            case "STATION_G2":
            case 31:
                message.hwModel = 31;
                break;
            case "LORA_RELAY_V1":
            case 32:
                message.hwModel = 32;
                break;
            case "NRF52840DK":
            case 33:
                message.hwModel = 33;
                break;
            case "PPR":
            case 34:
                message.hwModel = 34;
                break;
            case "GENIEBLOCKS":
            case 35:
                message.hwModel = 35;
                break;
            case "NRF52_UNKNOWN":
            case 36:
                message.hwModel = 36;
                break;
            case "PORTDUINO":
            case 37:
                message.hwModel = 37;
                break;
            case "ANDROID_SIM":
            case 38:
                message.hwModel = 38;
                break;
            case "DIY_V1":
            case 39:
                message.hwModel = 39;
                break;
            case "NRF52840_PCA10059":
            case 40:
                message.hwModel = 40;
                break;
            case "DR_DEV":
            case 41:
                message.hwModel = 41;
                break;
            case "M5STACK":
            case 42:
                message.hwModel = 42;
                break;
            case "HELTEC_V3":
            case 43:
                message.hwModel = 43;
                break;
            case "HELTEC_WSL_V3":
            case 44:
                message.hwModel = 44;
                break;
            case "BETAFPV_2400_TX":
            case 45:
                message.hwModel = 45;
                break;
            case "BETAFPV_900_NANO_TX":
            case 46:
                message.hwModel = 46;
                break;
            case "RPI_PICO":
            case 47:
                message.hwModel = 47;
                break;
            case "HELTEC_WIRELESS_TRACKER":
            case 48:
                message.hwModel = 48;
                break;
            case "HELTEC_WIRELESS_PAPER":
            case 49:
                message.hwModel = 49;
                break;
            case "T_DECK":
            case 50:
                message.hwModel = 50;
                break;
            case "T_WATCH_S3":
            case 51:
                message.hwModel = 51;
                break;
            case "PICOMPUTER_S3":
            case 52:
                message.hwModel = 52;
                break;
            case "HELTEC_HT62":
            case 53:
                message.hwModel = 53;
                break;
            case "EBYTE_ESP32_S3":
            case 54:
                message.hwModel = 54;
                break;
            case "ESP32_S3_PICO":
            case 55:
                message.hwModel = 55;
                break;
            case "CHATTER_2":
            case 56:
                message.hwModel = 56;
                break;
            case "HELTEC_WIRELESS_PAPER_V1_0":
            case 57:
                message.hwModel = 57;
                break;
            case "HELTEC_WIRELESS_TRACKER_V1_0":
            case 58:
                message.hwModel = 58;
                break;
            case "UNPHONE":
            case 59:
                message.hwModel = 59;
                break;
            case "TD_LORAC":
            case 60:
                message.hwModel = 60;
                break;
            case "CDEBYTE_EORA_S3":
            case 61:
                message.hwModel = 61;
                break;
            case "TWC_MESH_V4":
            case 62:
                message.hwModel = 62;
                break;
            case "NRF52_PROMICRO_DIY":
            case 63:
                message.hwModel = 63;
                break;
            case "RADIOMASTER_900_BANDIT_NANO":
            case 64:
                message.hwModel = 64;
                break;
            case "HELTEC_CAPSULE_SENSOR_V3":
            case 65:
                message.hwModel = 65;
                break;
            case "HELTEC_VISION_MASTER_T190":
            case 66:
                message.hwModel = 66;
                break;
            case "HELTEC_VISION_MASTER_E213":
            case 67:
                message.hwModel = 67;
                break;
            case "HELTEC_VISION_MASTER_E290":
            case 68:
                message.hwModel = 68;
                break;
            case "HELTEC_MESH_NODE_T114":
            case 69:
                message.hwModel = 69;
                break;
            case "SENSECAP_INDICATOR":
            case 70:
                message.hwModel = 70;
                break;
            case "TRACKER_T1000_E":
            case 71:
                message.hwModel = 71;
                break;
            case "RAK3172":
            case 72:
                message.hwModel = 72;
                break;
            case "WIO_E5":
            case 73:
                message.hwModel = 73;
                break;
            case "RADIOMASTER_900_BANDIT":
            case 74:
                message.hwModel = 74;
                break;
            case "ME25LS01_4Y10TD":
            case 75:
                message.hwModel = 75;
                break;
            case "RP2040_FEATHER_RFM95":
            case 76:
                message.hwModel = 76;
                break;
            case "M5STACK_COREBASIC":
            case 77:
                message.hwModel = 77;
                break;
            case "M5STACK_CORE2":
            case 78:
                message.hwModel = 78;
                break;
            case "RPI_PICO2":
            case 79:
                message.hwModel = 79;
                break;
            case "M5STACK_CORES3":
            case 80:
                message.hwModel = 80;
                break;
            case "SEEED_XIAO_S3":
            case 81:
                message.hwModel = 81;
                break;
            case "MS24SF1":
            case 82:
                message.hwModel = 82;
                break;
            case "TLORA_C6":
            case 83:
                message.hwModel = 83;
                break;
            case "WISMESH_TAP":
            case 84:
                message.hwModel = 84;
                break;
            case "ROUTASTIC":
            case 85:
                message.hwModel = 85;
                break;
            case "MESH_TAB":
            case 86:
                message.hwModel = 86;
                break;
            case "MESHLINK":
            case 87:
                message.hwModel = 87;
                break;
            case "XIAO_NRF52_KIT":
            case 88:
                message.hwModel = 88;
                break;
            case "THINKNODE_M1":
            case 89:
                message.hwModel = 89;
                break;
            case "THINKNODE_M2":
            case 90:
                message.hwModel = 90;
                break;
            case "T_ETH_ELITE":
            case 91:
                message.hwModel = 91;
                break;
            case "HELTEC_SENSOR_HUB":
            case 92:
                message.hwModel = 92;
                break;
            case "RESERVED_FRIED_CHICKEN":
            case 93:
                message.hwModel = 93;
                break;
            case "HELTEC_MESH_POCKET":
            case 94:
                message.hwModel = 94;
                break;
            case "SEEED_SOLAR_NODE":
            case 95:
                message.hwModel = 95;
                break;
            case "NOMADSTAR_METEOR_PRO":
            case 96:
                message.hwModel = 96;
                break;
            case "CROWPANEL":
            case 97:
                message.hwModel = 97;
                break;
            case "LINK_32":
            case 98:
                message.hwModel = 98;
                break;
            case "SEEED_WIO_TRACKER_L1":
            case 99:
                message.hwModel = 99;
                break;
            case "SEEED_WIO_TRACKER_L1_EINK":
            case 100:
                message.hwModel = 100;
                break;
            case "MUZI_R1_NEO":
            case 101:
                message.hwModel = 101;
                break;
            case "T_DECK_PRO":
            case 102:
                message.hwModel = 102;
                break;
            case "T_LORA_PAGER":
            case 103:
                message.hwModel = 103;
                break;
            case "M5STACK_RESERVED":
            case 104:
                message.hwModel = 104;
                break;
            case "WISMESH_TAG":
            case 105:
                message.hwModel = 105;
                break;
            case "RAK3312":
            case 106:
                message.hwModel = 106;
                break;
            case "THINKNODE_M5":
            case 107:
                message.hwModel = 107;
                break;
            case "HELTEC_MESH_SOLAR":
            case 108:
                message.hwModel = 108;
                break;
            case "T_ECHO_LITE":
            case 109:
                message.hwModel = 109;
                break;
            case "HELTEC_V4":
            case 110:
                message.hwModel = 110;
                break;
            case "M5STACK_C6L":
            case 111:
                message.hwModel = 111;
                break;
            case "M5STACK_CARDPUTER_ADV":
            case 112:
                message.hwModel = 112;
                break;
            case "HELTEC_WIRELESS_TRACKER_V2":
            case 113:
                message.hwModel = 113;
                break;
            case "T_WATCH_ULTRA":
            case 114:
                message.hwModel = 114;
                break;
            case "THINKNODE_M3":
            case 115:
                message.hwModel = 115;
                break;
            case "WISMESH_TAP_V2":
            case 116:
                message.hwModel = 116;
                break;
            case "RAK3401":
            case 117:
                message.hwModel = 117;
                break;
            case "RAK6421":
            case 118:
                message.hwModel = 118;
                break;
            case "THINKNODE_M4":
            case 119:
                message.hwModel = 119;
                break;
            case "THINKNODE_M6":
            case 120:
                message.hwModel = 120;
                break;
            case "PRIVATE_HW":
            case 255:
                message.hwModel = 255;
                break;
            }
            if (object.isLicensed != null)
                message.isLicensed = Boolean(object.isLicensed);
            switch (object.role) {
            default:
                if (typeof object.role === "number") {
                    message.role = object.role;
                    break;
                }
                break;
            case "CLIENT":
            case 0:
                message.role = 0;
                break;
            case "CLIENT_MUTE":
            case 1:
                message.role = 1;
                break;
            case "ROUTER":
            case 2:
                message.role = 2;
                break;
            case "ROUTER_CLIENT":
            case 3:
                message.role = 3;
                break;
            case "REPEATER":
            case 4:
                message.role = 4;
                break;
            case "TRACKER":
            case 5:
                message.role = 5;
                break;
            case "SENSOR":
            case 6:
                message.role = 6;
                break;
            case "TAK":
            case 7:
                message.role = 7;
                break;
            case "CLIENT_HIDDEN":
            case 8:
                message.role = 8;
                break;
            case "LOST_AND_FOUND":
            case 9:
                message.role = 9;
                break;
            case "TAK_TRACKER":
            case 10:
                message.role = 10;
                break;
            case "ROUTER_LATE":
            case 11:
                message.role = 11;
                break;
            case "CLIENT_BASE":
            case 12:
                message.role = 12;
                break;
            }
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length >= 0)
                    message.publicKey = object.publicKey;
            if (object.isUnmessagable != null)
                message.isUnmessagable = Boolean(object.isUnmessagable);
            return message;
        };

        /**
         * Creates a plain object from a User message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.User
         * @static
         * @param {meshtastic.User} message User
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        User.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.longName = "";
                object.shortName = "";
                if (options.bytes === String)
                    object.macaddr = "";
                else {
                    object.macaddr = [];
                    if (options.bytes !== Array)
                        object.macaddr = $util.newBuffer(object.macaddr);
                }
                object.hwModel = options.enums === String ? "UNSET" : 0;
                object.isLicensed = false;
                object.role = options.enums === String ? "CLIENT" : 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.longName != null && message.hasOwnProperty("longName"))
                object.longName = message.longName;
            if (message.shortName != null && message.hasOwnProperty("shortName"))
                object.shortName = message.shortName;
            if (message.macaddr != null && message.hasOwnProperty("macaddr"))
                object.macaddr = options.bytes === String ? $util.base64.encode(message.macaddr, 0, message.macaddr.length) : options.bytes === Array ? Array.prototype.slice.call(message.macaddr) : message.macaddr;
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                object.hwModel = options.enums === String ? $root.meshtastic.HardwareModel[message.hwModel] === undefined ? message.hwModel : $root.meshtastic.HardwareModel[message.hwModel] : message.hwModel;
            if (message.isLicensed != null && message.hasOwnProperty("isLicensed"))
                object.isLicensed = message.isLicensed;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = options.enums === String ? $root.meshtastic.Config.DeviceConfig.Role[message.role] === undefined ? message.role : $root.meshtastic.Config.DeviceConfig.Role[message.role] : message.role;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.isUnmessagable != null && message.hasOwnProperty("isUnmessagable")) {
                object.isUnmessagable = message.isUnmessagable;
                if (options.oneofs)
                    object._isUnmessagable = "isUnmessagable";
            }
            return object;
        };

        /**
         * Converts this User to JSON.
         * @function toJSON
         * @memberof meshtastic.User
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        User.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for User
         * @function getTypeUrl
         * @memberof meshtastic.User
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.User";
        };

        return User;
    })();

    meshtastic.RouteDiscovery = (function() {

        /**
         * Properties of a RouteDiscovery.
         * @memberof meshtastic
         * @interface IRouteDiscovery
         * @property {Array.<number>|null} [route] RouteDiscovery route
         * @property {Array.<number>|null} [snrTowards] RouteDiscovery snrTowards
         * @property {Array.<number>|null} [routeBack] RouteDiscovery routeBack
         * @property {Array.<number>|null} [snrBack] RouteDiscovery snrBack
         */

        /**
         * Constructs a new RouteDiscovery.
         * @memberof meshtastic
         * @classdesc Represents a RouteDiscovery.
         * @implements IRouteDiscovery
         * @constructor
         * @param {meshtastic.IRouteDiscovery=} [properties] Properties to set
         */
        function RouteDiscovery(properties) {
            this.route = [];
            this.snrTowards = [];
            this.routeBack = [];
            this.snrBack = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RouteDiscovery route.
         * @member {Array.<number>} route
         * @memberof meshtastic.RouteDiscovery
         * @instance
         */
        RouteDiscovery.prototype.route = $util.emptyArray;

        /**
         * RouteDiscovery snrTowards.
         * @member {Array.<number>} snrTowards
         * @memberof meshtastic.RouteDiscovery
         * @instance
         */
        RouteDiscovery.prototype.snrTowards = $util.emptyArray;

        /**
         * RouteDiscovery routeBack.
         * @member {Array.<number>} routeBack
         * @memberof meshtastic.RouteDiscovery
         * @instance
         */
        RouteDiscovery.prototype.routeBack = $util.emptyArray;

        /**
         * RouteDiscovery snrBack.
         * @member {Array.<number>} snrBack
         * @memberof meshtastic.RouteDiscovery
         * @instance
         */
        RouteDiscovery.prototype.snrBack = $util.emptyArray;

        /**
         * Creates a new RouteDiscovery instance using the specified properties.
         * @function create
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {meshtastic.IRouteDiscovery=} [properties] Properties to set
         * @returns {meshtastic.RouteDiscovery} RouteDiscovery instance
         */
        RouteDiscovery.create = function create(properties) {
            return new RouteDiscovery(properties);
        };

        /**
         * Encodes the specified RouteDiscovery message. Does not implicitly {@link meshtastic.RouteDiscovery.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {meshtastic.IRouteDiscovery} message RouteDiscovery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteDiscovery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.route != null && message.route.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.route.length; ++i)
                    writer.fixed32(message.route[i]);
                writer.ldelim();
            }
            if (message.snrTowards != null && message.snrTowards.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.snrTowards.length; ++i)
                    writer.int32(message.snrTowards[i]);
                writer.ldelim();
            }
            if (message.routeBack != null && message.routeBack.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.routeBack.length; ++i)
                    writer.fixed32(message.routeBack[i]);
                writer.ldelim();
            }
            if (message.snrBack != null && message.snrBack.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.snrBack.length; ++i)
                    writer.int32(message.snrBack[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RouteDiscovery message, length delimited. Does not implicitly {@link meshtastic.RouteDiscovery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {meshtastic.IRouteDiscovery} message RouteDiscovery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteDiscovery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RouteDiscovery message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.RouteDiscovery} RouteDiscovery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteDiscovery.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.RouteDiscovery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.route && message.route.length))
                            message.route = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.route.push(reader.fixed32());
                        } else
                            message.route.push(reader.fixed32());
                        break;
                    }
                case 2: {
                        if (!(message.snrTowards && message.snrTowards.length))
                            message.snrTowards = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.snrTowards.push(reader.int32());
                        } else
                            message.snrTowards.push(reader.int32());
                        break;
                    }
                case 3: {
                        if (!(message.routeBack && message.routeBack.length))
                            message.routeBack = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.routeBack.push(reader.fixed32());
                        } else
                            message.routeBack.push(reader.fixed32());
                        break;
                    }
                case 4: {
                        if (!(message.snrBack && message.snrBack.length))
                            message.snrBack = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.snrBack.push(reader.int32());
                        } else
                            message.snrBack.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RouteDiscovery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.RouteDiscovery} RouteDiscovery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteDiscovery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RouteDiscovery message.
         * @function verify
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RouteDiscovery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.route != null && message.hasOwnProperty("route")) {
                if (!Array.isArray(message.route))
                    return "route: array expected";
                for (var i = 0; i < message.route.length; ++i)
                    if (!$util.isInteger(message.route[i]))
                        return "route: integer[] expected";
            }
            if (message.snrTowards != null && message.hasOwnProperty("snrTowards")) {
                if (!Array.isArray(message.snrTowards))
                    return "snrTowards: array expected";
                for (var i = 0; i < message.snrTowards.length; ++i)
                    if (!$util.isInteger(message.snrTowards[i]))
                        return "snrTowards: integer[] expected";
            }
            if (message.routeBack != null && message.hasOwnProperty("routeBack")) {
                if (!Array.isArray(message.routeBack))
                    return "routeBack: array expected";
                for (var i = 0; i < message.routeBack.length; ++i)
                    if (!$util.isInteger(message.routeBack[i]))
                        return "routeBack: integer[] expected";
            }
            if (message.snrBack != null && message.hasOwnProperty("snrBack")) {
                if (!Array.isArray(message.snrBack))
                    return "snrBack: array expected";
                for (var i = 0; i < message.snrBack.length; ++i)
                    if (!$util.isInteger(message.snrBack[i]))
                        return "snrBack: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a RouteDiscovery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.RouteDiscovery} RouteDiscovery
         */
        RouteDiscovery.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.RouteDiscovery)
                return object;
            var message = new $root.meshtastic.RouteDiscovery();
            if (object.route) {
                if (!Array.isArray(object.route))
                    throw TypeError(".meshtastic.RouteDiscovery.route: array expected");
                message.route = [];
                for (var i = 0; i < object.route.length; ++i)
                    message.route[i] = object.route[i] >>> 0;
            }
            if (object.snrTowards) {
                if (!Array.isArray(object.snrTowards))
                    throw TypeError(".meshtastic.RouteDiscovery.snrTowards: array expected");
                message.snrTowards = [];
                for (var i = 0; i < object.snrTowards.length; ++i)
                    message.snrTowards[i] = object.snrTowards[i] | 0;
            }
            if (object.routeBack) {
                if (!Array.isArray(object.routeBack))
                    throw TypeError(".meshtastic.RouteDiscovery.routeBack: array expected");
                message.routeBack = [];
                for (var i = 0; i < object.routeBack.length; ++i)
                    message.routeBack[i] = object.routeBack[i] >>> 0;
            }
            if (object.snrBack) {
                if (!Array.isArray(object.snrBack))
                    throw TypeError(".meshtastic.RouteDiscovery.snrBack: array expected");
                message.snrBack = [];
                for (var i = 0; i < object.snrBack.length; ++i)
                    message.snrBack[i] = object.snrBack[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a RouteDiscovery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {meshtastic.RouteDiscovery} message RouteDiscovery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RouteDiscovery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.route = [];
                object.snrTowards = [];
                object.routeBack = [];
                object.snrBack = [];
            }
            if (message.route && message.route.length) {
                object.route = [];
                for (var j = 0; j < message.route.length; ++j)
                    object.route[j] = message.route[j];
            }
            if (message.snrTowards && message.snrTowards.length) {
                object.snrTowards = [];
                for (var j = 0; j < message.snrTowards.length; ++j)
                    object.snrTowards[j] = message.snrTowards[j];
            }
            if (message.routeBack && message.routeBack.length) {
                object.routeBack = [];
                for (var j = 0; j < message.routeBack.length; ++j)
                    object.routeBack[j] = message.routeBack[j];
            }
            if (message.snrBack && message.snrBack.length) {
                object.snrBack = [];
                for (var j = 0; j < message.snrBack.length; ++j)
                    object.snrBack[j] = message.snrBack[j];
            }
            return object;
        };

        /**
         * Converts this RouteDiscovery to JSON.
         * @function toJSON
         * @memberof meshtastic.RouteDiscovery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RouteDiscovery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RouteDiscovery
         * @function getTypeUrl
         * @memberof meshtastic.RouteDiscovery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RouteDiscovery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.RouteDiscovery";
        };

        return RouteDiscovery;
    })();

    meshtastic.Routing = (function() {

        /**
         * Properties of a Routing.
         * @memberof meshtastic
         * @interface IRouting
         * @property {meshtastic.IRouteDiscovery|null} [routeRequest] Routing routeRequest
         * @property {meshtastic.IRouteDiscovery|null} [routeReply] Routing routeReply
         * @property {meshtastic.Routing.Error|null} [errorReason] Routing errorReason
         */

        /**
         * Constructs a new Routing.
         * @memberof meshtastic
         * @classdesc Represents a Routing.
         * @implements IRouting
         * @constructor
         * @param {meshtastic.IRouting=} [properties] Properties to set
         */
        function Routing(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Routing routeRequest.
         * @member {meshtastic.IRouteDiscovery|null|undefined} routeRequest
         * @memberof meshtastic.Routing
         * @instance
         */
        Routing.prototype.routeRequest = null;

        /**
         * Routing routeReply.
         * @member {meshtastic.IRouteDiscovery|null|undefined} routeReply
         * @memberof meshtastic.Routing
         * @instance
         */
        Routing.prototype.routeReply = null;

        /**
         * Routing errorReason.
         * @member {meshtastic.Routing.Error|null|undefined} errorReason
         * @memberof meshtastic.Routing
         * @instance
         */
        Routing.prototype.errorReason = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Routing variant.
         * @member {"routeRequest"|"routeReply"|"errorReason"|undefined} variant
         * @memberof meshtastic.Routing
         * @instance
         */
        Object.defineProperty(Routing.prototype, "variant", {
            get: $util.oneOfGetter($oneOfFields = ["routeRequest", "routeReply", "errorReason"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Routing instance using the specified properties.
         * @function create
         * @memberof meshtastic.Routing
         * @static
         * @param {meshtastic.IRouting=} [properties] Properties to set
         * @returns {meshtastic.Routing} Routing instance
         */
        Routing.create = function create(properties) {
            return new Routing(properties);
        };

        /**
         * Encodes the specified Routing message. Does not implicitly {@link meshtastic.Routing.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Routing
         * @static
         * @param {meshtastic.IRouting} message Routing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Routing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.routeRequest != null && Object.hasOwnProperty.call(message, "routeRequest"))
                $root.meshtastic.RouteDiscovery.encode(message.routeRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.routeReply != null && Object.hasOwnProperty.call(message, "routeReply"))
                $root.meshtastic.RouteDiscovery.encode(message.routeReply, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.errorReason != null && Object.hasOwnProperty.call(message, "errorReason"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errorReason);
            return writer;
        };

        /**
         * Encodes the specified Routing message, length delimited. Does not implicitly {@link meshtastic.Routing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Routing
         * @static
         * @param {meshtastic.IRouting} message Routing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Routing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Routing message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Routing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Routing} Routing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Routing.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Routing();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.routeRequest = $root.meshtastic.RouteDiscovery.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.routeReply = $root.meshtastic.RouteDiscovery.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.errorReason = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Routing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Routing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Routing} Routing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Routing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Routing message.
         * @function verify
         * @memberof meshtastic.Routing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Routing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.routeRequest != null && message.hasOwnProperty("routeRequest")) {
                properties.variant = 1;
                {
                    var error = $root.meshtastic.RouteDiscovery.verify(message.routeRequest);
                    if (error)
                        return "routeRequest." + error;
                }
            }
            if (message.routeReply != null && message.hasOwnProperty("routeReply")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.RouteDiscovery.verify(message.routeReply);
                    if (error)
                        return "routeReply." + error;
                }
            }
            if (message.errorReason != null && message.hasOwnProperty("errorReason")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                switch (message.errorReason) {
                default:
                    return "errorReason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a Routing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Routing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Routing} Routing
         */
        Routing.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Routing)
                return object;
            var message = new $root.meshtastic.Routing();
            if (object.routeRequest != null) {
                if (typeof object.routeRequest !== "object")
                    throw TypeError(".meshtastic.Routing.routeRequest: object expected");
                message.routeRequest = $root.meshtastic.RouteDiscovery.fromObject(object.routeRequest);
            }
            if (object.routeReply != null) {
                if (typeof object.routeReply !== "object")
                    throw TypeError(".meshtastic.Routing.routeReply: object expected");
                message.routeReply = $root.meshtastic.RouteDiscovery.fromObject(object.routeReply);
            }
            switch (object.errorReason) {
            default:
                if (typeof object.errorReason === "number") {
                    message.errorReason = object.errorReason;
                    break;
                }
                break;
            case "NONE":
            case 0:
                message.errorReason = 0;
                break;
            case "NO_ROUTE":
            case 1:
                message.errorReason = 1;
                break;
            case "GOT_NAK":
            case 2:
                message.errorReason = 2;
                break;
            case "TIMEOUT":
            case 3:
                message.errorReason = 3;
                break;
            case "NO_INTERFACE":
            case 4:
                message.errorReason = 4;
                break;
            case "MAX_RETRANSMIT":
            case 5:
                message.errorReason = 5;
                break;
            case "NO_CHANNEL":
            case 6:
                message.errorReason = 6;
                break;
            case "TOO_LARGE":
            case 7:
                message.errorReason = 7;
                break;
            case "NO_RESPONSE":
            case 8:
                message.errorReason = 8;
                break;
            case "DUTY_CYCLE_LIMIT":
            case 9:
                message.errorReason = 9;
                break;
            case "BAD_REQUEST":
            case 32:
                message.errorReason = 32;
                break;
            case "NOT_AUTHORIZED":
            case 33:
                message.errorReason = 33;
                break;
            case "PKI_FAILED":
            case 34:
                message.errorReason = 34;
                break;
            case "PKI_UNKNOWN_PUBKEY":
            case 35:
                message.errorReason = 35;
                break;
            case "ADMIN_BAD_SESSION_KEY":
            case 36:
                message.errorReason = 36;
                break;
            case "ADMIN_PUBLIC_KEY_UNAUTHORIZED":
            case 37:
                message.errorReason = 37;
                break;
            case "RATE_LIMIT_EXCEEDED":
            case 38:
                message.errorReason = 38;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Routing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Routing
         * @static
         * @param {meshtastic.Routing} message Routing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Routing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.routeRequest != null && message.hasOwnProperty("routeRequest")) {
                object.routeRequest = $root.meshtastic.RouteDiscovery.toObject(message.routeRequest, options);
                if (options.oneofs)
                    object.variant = "routeRequest";
            }
            if (message.routeReply != null && message.hasOwnProperty("routeReply")) {
                object.routeReply = $root.meshtastic.RouteDiscovery.toObject(message.routeReply, options);
                if (options.oneofs)
                    object.variant = "routeReply";
            }
            if (message.errorReason != null && message.hasOwnProperty("errorReason")) {
                object.errorReason = options.enums === String ? $root.meshtastic.Routing.Error[message.errorReason] === undefined ? message.errorReason : $root.meshtastic.Routing.Error[message.errorReason] : message.errorReason;
                if (options.oneofs)
                    object.variant = "errorReason";
            }
            return object;
        };

        /**
         * Converts this Routing to JSON.
         * @function toJSON
         * @memberof meshtastic.Routing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Routing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Routing
         * @function getTypeUrl
         * @memberof meshtastic.Routing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Routing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Routing";
        };

        /**
         * Error enum.
         * @name meshtastic.Routing.Error
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} NO_ROUTE=1 NO_ROUTE value
         * @property {number} GOT_NAK=2 GOT_NAK value
         * @property {number} TIMEOUT=3 TIMEOUT value
         * @property {number} NO_INTERFACE=4 NO_INTERFACE value
         * @property {number} MAX_RETRANSMIT=5 MAX_RETRANSMIT value
         * @property {number} NO_CHANNEL=6 NO_CHANNEL value
         * @property {number} TOO_LARGE=7 TOO_LARGE value
         * @property {number} NO_RESPONSE=8 NO_RESPONSE value
         * @property {number} DUTY_CYCLE_LIMIT=9 DUTY_CYCLE_LIMIT value
         * @property {number} BAD_REQUEST=32 BAD_REQUEST value
         * @property {number} NOT_AUTHORIZED=33 NOT_AUTHORIZED value
         * @property {number} PKI_FAILED=34 PKI_FAILED value
         * @property {number} PKI_UNKNOWN_PUBKEY=35 PKI_UNKNOWN_PUBKEY value
         * @property {number} ADMIN_BAD_SESSION_KEY=36 ADMIN_BAD_SESSION_KEY value
         * @property {number} ADMIN_PUBLIC_KEY_UNAUTHORIZED=37 ADMIN_PUBLIC_KEY_UNAUTHORIZED value
         * @property {number} RATE_LIMIT_EXCEEDED=38 RATE_LIMIT_EXCEEDED value
         */
        Routing.Error = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "NO_ROUTE"] = 1;
            values[valuesById[2] = "GOT_NAK"] = 2;
            values[valuesById[3] = "TIMEOUT"] = 3;
            values[valuesById[4] = "NO_INTERFACE"] = 4;
            values[valuesById[5] = "MAX_RETRANSMIT"] = 5;
            values[valuesById[6] = "NO_CHANNEL"] = 6;
            values[valuesById[7] = "TOO_LARGE"] = 7;
            values[valuesById[8] = "NO_RESPONSE"] = 8;
            values[valuesById[9] = "DUTY_CYCLE_LIMIT"] = 9;
            values[valuesById[32] = "BAD_REQUEST"] = 32;
            values[valuesById[33] = "NOT_AUTHORIZED"] = 33;
            values[valuesById[34] = "PKI_FAILED"] = 34;
            values[valuesById[35] = "PKI_UNKNOWN_PUBKEY"] = 35;
            values[valuesById[36] = "ADMIN_BAD_SESSION_KEY"] = 36;
            values[valuesById[37] = "ADMIN_PUBLIC_KEY_UNAUTHORIZED"] = 37;
            values[valuesById[38] = "RATE_LIMIT_EXCEEDED"] = 38;
            return values;
        })();

        return Routing;
    })();

    meshtastic.Data = (function() {

        /**
         * Properties of a Data.
         * @memberof meshtastic
         * @interface IData
         * @property {meshtastic.PortNum|null} [portnum] Data portnum
         * @property {Uint8Array|null} [payload] Data payload
         * @property {boolean|null} [wantResponse] Data wantResponse
         * @property {number|null} [dest] Data dest
         * @property {number|null} [source] Data source
         * @property {number|null} [requestId] Data requestId
         * @property {number|null} [replyId] Data replyId
         * @property {number|null} [emoji] Data emoji
         * @property {number|null} [bitfield] Data bitfield
         */

        /**
         * Constructs a new Data.
         * @memberof meshtastic
         * @classdesc Represents a Data.
         * @implements IData
         * @constructor
         * @param {meshtastic.IData=} [properties] Properties to set
         */
        function Data(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Data portnum.
         * @member {meshtastic.PortNum} portnum
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.portnum = 0;

        /**
         * Data payload.
         * @member {Uint8Array} payload
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.payload = $util.newBuffer([]);

        /**
         * Data wantResponse.
         * @member {boolean} wantResponse
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.wantResponse = false;

        /**
         * Data dest.
         * @member {number} dest
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.dest = 0;

        /**
         * Data source.
         * @member {number} source
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.source = 0;

        /**
         * Data requestId.
         * @member {number} requestId
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.requestId = 0;

        /**
         * Data replyId.
         * @member {number} replyId
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.replyId = 0;

        /**
         * Data emoji.
         * @member {number} emoji
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.emoji = 0;

        /**
         * Data bitfield.
         * @member {number|null|undefined} bitfield
         * @memberof meshtastic.Data
         * @instance
         */
        Data.prototype.bitfield = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Data _bitfield.
         * @member {"bitfield"|undefined} _bitfield
         * @memberof meshtastic.Data
         * @instance
         */
        Object.defineProperty(Data.prototype, "_bitfield", {
            get: $util.oneOfGetter($oneOfFields = ["bitfield"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Data instance using the specified properties.
         * @function create
         * @memberof meshtastic.Data
         * @static
         * @param {meshtastic.IData=} [properties] Properties to set
         * @returns {meshtastic.Data} Data instance
         */
        Data.create = function create(properties) {
            return new Data(properties);
        };

        /**
         * Encodes the specified Data message. Does not implicitly {@link meshtastic.Data.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Data
         * @static
         * @param {meshtastic.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.portnum != null && Object.hasOwnProperty.call(message, "portnum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.portnum);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.wantResponse != null && Object.hasOwnProperty.call(message, "wantResponse"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.wantResponse);
            if (message.dest != null && Object.hasOwnProperty.call(message, "dest"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.dest);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.source);
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.requestId);
            if (message.replyId != null && Object.hasOwnProperty.call(message, "replyId"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.replyId);
            if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.emoji);
            if (message.bitfield != null && Object.hasOwnProperty.call(message, "bitfield"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.bitfield);
            return writer;
        };

        /**
         * Encodes the specified Data message, length delimited. Does not implicitly {@link meshtastic.Data.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Data
         * @static
         * @param {meshtastic.IData} message Data message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Data.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Data message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Data();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.portnum = reader.int32();
                        break;
                    }
                case 2: {
                        message.payload = reader.bytes();
                        break;
                    }
                case 3: {
                        message.wantResponse = reader.bool();
                        break;
                    }
                case 4: {
                        message.dest = reader.fixed32();
                        break;
                    }
                case 5: {
                        message.source = reader.fixed32();
                        break;
                    }
                case 6: {
                        message.requestId = reader.fixed32();
                        break;
                    }
                case 7: {
                        message.replyId = reader.fixed32();
                        break;
                    }
                case 8: {
                        message.emoji = reader.fixed32();
                        break;
                    }
                case 9: {
                        message.bitfield = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Data message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Data
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Data} Data
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Data.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Data message.
         * @function verify
         * @memberof meshtastic.Data
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Data.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.portnum != null && message.hasOwnProperty("portnum"))
                switch (message.portnum) {
                default:
                    return "portnum: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 32:
                case 33:
                case 34:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 76:
                case 77:
                case 256:
                case 257:
                case 511:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.wantResponse != null && message.hasOwnProperty("wantResponse"))
                if (typeof message.wantResponse !== "boolean")
                    return "wantResponse: boolean expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!$util.isInteger(message.dest))
                    return "dest: integer expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isInteger(message.source))
                    return "source: integer expected";
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                if (!$util.isInteger(message.requestId))
                    return "requestId: integer expected";
            if (message.replyId != null && message.hasOwnProperty("replyId"))
                if (!$util.isInteger(message.replyId))
                    return "replyId: integer expected";
            if (message.emoji != null && message.hasOwnProperty("emoji"))
                if (!$util.isInteger(message.emoji))
                    return "emoji: integer expected";
            if (message.bitfield != null && message.hasOwnProperty("bitfield")) {
                properties._bitfield = 1;
                if (!$util.isInteger(message.bitfield))
                    return "bitfield: integer expected";
            }
            return null;
        };

        /**
         * Creates a Data message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Data
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Data} Data
         */
        Data.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Data)
                return object;
            var message = new $root.meshtastic.Data();
            switch (object.portnum) {
            default:
                if (typeof object.portnum === "number") {
                    message.portnum = object.portnum;
                    break;
                }
                break;
            case "UNKNOWN_APP":
            case 0:
                message.portnum = 0;
                break;
            case "TEXT_MESSAGE_APP":
            case 1:
                message.portnum = 1;
                break;
            case "REMOTE_HARDWARE_APP":
            case 2:
                message.portnum = 2;
                break;
            case "POSITION_APP":
            case 3:
                message.portnum = 3;
                break;
            case "NODEINFO_APP":
            case 4:
                message.portnum = 4;
                break;
            case "ROUTING_APP":
            case 5:
                message.portnum = 5;
                break;
            case "ADMIN_APP":
            case 6:
                message.portnum = 6;
                break;
            case "TEXT_MESSAGE_COMPRESSED_APP":
            case 7:
                message.portnum = 7;
                break;
            case "WAYPOINT_APP":
            case 8:
                message.portnum = 8;
                break;
            case "AUDIO_APP":
            case 9:
                message.portnum = 9;
                break;
            case "DETECTION_SENSOR_APP":
            case 10:
                message.portnum = 10;
                break;
            case "ALERT_APP":
            case 11:
                message.portnum = 11;
                break;
            case "KEY_VERIFICATION_APP":
            case 12:
                message.portnum = 12;
                break;
            case "REPLY_APP":
            case 32:
                message.portnum = 32;
                break;
            case "IP_TUNNEL_APP":
            case 33:
                message.portnum = 33;
                break;
            case "PAXCOUNTER_APP":
            case 34:
                message.portnum = 34;
                break;
            case "SERIAL_APP":
            case 64:
                message.portnum = 64;
                break;
            case "STORE_FORWARD_APP":
            case 65:
                message.portnum = 65;
                break;
            case "RANGE_TEST_APP":
            case 66:
                message.portnum = 66;
                break;
            case "TELEMETRY_APP":
            case 67:
                message.portnum = 67;
                break;
            case "ZPS_APP":
            case 68:
                message.portnum = 68;
                break;
            case "SIMULATOR_APP":
            case 69:
                message.portnum = 69;
                break;
            case "TRACEROUTE_APP":
            case 70:
                message.portnum = 70;
                break;
            case "NEIGHBORINFO_APP":
            case 71:
                message.portnum = 71;
                break;
            case "ATAK_PLUGIN":
            case 72:
                message.portnum = 72;
                break;
            case "MAP_REPORT_APP":
            case 73:
                message.portnum = 73;
                break;
            case "POWERSTRESS_APP":
            case 74:
                message.portnum = 74;
                break;
            case "RETICULUM_TUNNEL_APP":
            case 76:
                message.portnum = 76;
                break;
            case "CAYENNE_APP":
            case 77:
                message.portnum = 77;
                break;
            case "PRIVATE_APP":
            case 256:
                message.portnum = 256;
                break;
            case "ATAK_FORWARDER":
            case 257:
                message.portnum = 257;
                break;
            case "MAX":
            case 511:
                message.portnum = 511;
                break;
            }
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length >= 0)
                    message.payload = object.payload;
            if (object.wantResponse != null)
                message.wantResponse = Boolean(object.wantResponse);
            if (object.dest != null)
                message.dest = object.dest >>> 0;
            if (object.source != null)
                message.source = object.source >>> 0;
            if (object.requestId != null)
                message.requestId = object.requestId >>> 0;
            if (object.replyId != null)
                message.replyId = object.replyId >>> 0;
            if (object.emoji != null)
                message.emoji = object.emoji >>> 0;
            if (object.bitfield != null)
                message.bitfield = object.bitfield >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Data message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Data
         * @static
         * @param {meshtastic.Data} message Data
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Data.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.portnum = options.enums === String ? "UNKNOWN_APP" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.wantResponse = false;
                object.dest = 0;
                object.source = 0;
                object.requestId = 0;
                object.replyId = 0;
                object.emoji = 0;
            }
            if (message.portnum != null && message.hasOwnProperty("portnum"))
                object.portnum = options.enums === String ? $root.meshtastic.PortNum[message.portnum] === undefined ? message.portnum : $root.meshtastic.PortNum[message.portnum] : message.portnum;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.wantResponse != null && message.hasOwnProperty("wantResponse"))
                object.wantResponse = message.wantResponse;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = message.dest;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                object.requestId = message.requestId;
            if (message.replyId != null && message.hasOwnProperty("replyId"))
                object.replyId = message.replyId;
            if (message.emoji != null && message.hasOwnProperty("emoji"))
                object.emoji = message.emoji;
            if (message.bitfield != null && message.hasOwnProperty("bitfield")) {
                object.bitfield = message.bitfield;
                if (options.oneofs)
                    object._bitfield = "bitfield";
            }
            return object;
        };

        /**
         * Converts this Data to JSON.
         * @function toJSON
         * @memberof meshtastic.Data
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Data.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Data
         * @function getTypeUrl
         * @memberof meshtastic.Data
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Data.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Data";
        };

        return Data;
    })();

    meshtastic.KeyVerification = (function() {

        /**
         * Properties of a KeyVerification.
         * @memberof meshtastic
         * @interface IKeyVerification
         * @property {number|Long|null} [nonce] KeyVerification nonce
         * @property {Uint8Array|null} [hash1] KeyVerification hash1
         * @property {Uint8Array|null} [hash2] KeyVerification hash2
         */

        /**
         * Constructs a new KeyVerification.
         * @memberof meshtastic
         * @classdesc Represents a KeyVerification.
         * @implements IKeyVerification
         * @constructor
         * @param {meshtastic.IKeyVerification=} [properties] Properties to set
         */
        function KeyVerification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyVerification nonce.
         * @member {number|Long} nonce
         * @memberof meshtastic.KeyVerification
         * @instance
         */
        KeyVerification.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * KeyVerification hash1.
         * @member {Uint8Array} hash1
         * @memberof meshtastic.KeyVerification
         * @instance
         */
        KeyVerification.prototype.hash1 = $util.newBuffer([]);

        /**
         * KeyVerification hash2.
         * @member {Uint8Array} hash2
         * @memberof meshtastic.KeyVerification
         * @instance
         */
        KeyVerification.prototype.hash2 = $util.newBuffer([]);

        /**
         * Creates a new KeyVerification instance using the specified properties.
         * @function create
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {meshtastic.IKeyVerification=} [properties] Properties to set
         * @returns {meshtastic.KeyVerification} KeyVerification instance
         */
        KeyVerification.create = function create(properties) {
            return new KeyVerification(properties);
        };

        /**
         * Encodes the specified KeyVerification message. Does not implicitly {@link meshtastic.KeyVerification.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {meshtastic.IKeyVerification} message KeyVerification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
            if (message.hash1 != null && Object.hasOwnProperty.call(message, "hash1"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash1);
            if (message.hash2 != null && Object.hasOwnProperty.call(message, "hash2"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hash2);
            return writer;
        };

        /**
         * Encodes the specified KeyVerification message, length delimited. Does not implicitly {@link meshtastic.KeyVerification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {meshtastic.IKeyVerification} message KeyVerification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyVerification message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.KeyVerification} KeyVerification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerification.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.KeyVerification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nonce = reader.uint64();
                        break;
                    }
                case 2: {
                        message.hash1 = reader.bytes();
                        break;
                    }
                case 3: {
                        message.hash2 = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyVerification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.KeyVerification} KeyVerification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyVerification message.
         * @function verify
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyVerification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                    return "nonce: integer|Long expected";
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                if (!(message.hash1 && typeof message.hash1.length === "number" || $util.isString(message.hash1)))
                    return "hash1: buffer expected";
            if (message.hash2 != null && message.hasOwnProperty("hash2"))
                if (!(message.hash2 && typeof message.hash2.length === "number" || $util.isString(message.hash2)))
                    return "hash2: buffer expected";
            return null;
        };

        /**
         * Creates a KeyVerification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.KeyVerification} KeyVerification
         */
        KeyVerification.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.KeyVerification)
                return object;
            var message = new $root.meshtastic.KeyVerification();
            if (object.nonce != null)
                if ($util.Long)
                    (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                else if (typeof object.nonce === "string")
                    message.nonce = parseInt(object.nonce, 10);
                else if (typeof object.nonce === "number")
                    message.nonce = object.nonce;
                else if (typeof object.nonce === "object")
                    message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
            if (object.hash1 != null)
                if (typeof object.hash1 === "string")
                    $util.base64.decode(object.hash1, message.hash1 = $util.newBuffer($util.base64.length(object.hash1)), 0);
                else if (object.hash1.length >= 0)
                    message.hash1 = object.hash1;
            if (object.hash2 != null)
                if (typeof object.hash2 === "string")
                    $util.base64.decode(object.hash2, message.hash2 = $util.newBuffer($util.base64.length(object.hash2)), 0);
                else if (object.hash2.length >= 0)
                    message.hash2 = object.hash2;
            return message;
        };

        /**
         * Creates a plain object from a KeyVerification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {meshtastic.KeyVerification} message KeyVerification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyVerification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nonce = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hash1 = "";
                else {
                    object.hash1 = [];
                    if (options.bytes !== Array)
                        object.hash1 = $util.newBuffer(object.hash1);
                }
                if (options.bytes === String)
                    object.hash2 = "";
                else {
                    object.hash2 = [];
                    if (options.bytes !== Array)
                        object.hash2 = $util.newBuffer(object.hash2);
                }
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (typeof message.nonce === "number")
                    object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                else
                    object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                object.hash1 = options.bytes === String ? $util.base64.encode(message.hash1, 0, message.hash1.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash1) : message.hash1;
            if (message.hash2 != null && message.hasOwnProperty("hash2"))
                object.hash2 = options.bytes === String ? $util.base64.encode(message.hash2, 0, message.hash2.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash2) : message.hash2;
            return object;
        };

        /**
         * Converts this KeyVerification to JSON.
         * @function toJSON
         * @memberof meshtastic.KeyVerification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyVerification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KeyVerification
         * @function getTypeUrl
         * @memberof meshtastic.KeyVerification
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyVerification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.KeyVerification";
        };

        return KeyVerification;
    })();

    meshtastic.Waypoint = (function() {

        /**
         * Properties of a Waypoint.
         * @memberof meshtastic
         * @interface IWaypoint
         * @property {number|null} [id] Waypoint id
         * @property {number|null} [latitudeI] Waypoint latitudeI
         * @property {number|null} [longitudeI] Waypoint longitudeI
         * @property {number|null} [expire] Waypoint expire
         * @property {number|null} [lockedTo] Waypoint lockedTo
         * @property {string|null} [name] Waypoint name
         * @property {string|null} [description] Waypoint description
         * @property {number|null} [icon] Waypoint icon
         */

        /**
         * Constructs a new Waypoint.
         * @memberof meshtastic
         * @classdesc Represents a Waypoint.
         * @implements IWaypoint
         * @constructor
         * @param {meshtastic.IWaypoint=} [properties] Properties to set
         */
        function Waypoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Waypoint id.
         * @member {number} id
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.id = 0;

        /**
         * Waypoint latitudeI.
         * @member {number|null|undefined} latitudeI
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.latitudeI = null;

        /**
         * Waypoint longitudeI.
         * @member {number|null|undefined} longitudeI
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.longitudeI = null;

        /**
         * Waypoint expire.
         * @member {number} expire
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.expire = 0;

        /**
         * Waypoint lockedTo.
         * @member {number} lockedTo
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.lockedTo = 0;

        /**
         * Waypoint name.
         * @member {string} name
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.name = "";

        /**
         * Waypoint description.
         * @member {string} description
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.description = "";

        /**
         * Waypoint icon.
         * @member {number} icon
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Waypoint.prototype.icon = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Waypoint _latitudeI.
         * @member {"latitudeI"|undefined} _latitudeI
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Object.defineProperty(Waypoint.prototype, "_latitudeI", {
            get: $util.oneOfGetter($oneOfFields = ["latitudeI"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Waypoint _longitudeI.
         * @member {"longitudeI"|undefined} _longitudeI
         * @memberof meshtastic.Waypoint
         * @instance
         */
        Object.defineProperty(Waypoint.prototype, "_longitudeI", {
            get: $util.oneOfGetter($oneOfFields = ["longitudeI"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Waypoint instance using the specified properties.
         * @function create
         * @memberof meshtastic.Waypoint
         * @static
         * @param {meshtastic.IWaypoint=} [properties] Properties to set
         * @returns {meshtastic.Waypoint} Waypoint instance
         */
        Waypoint.create = function create(properties) {
            return new Waypoint(properties);
        };

        /**
         * Encodes the specified Waypoint message. Does not implicitly {@link meshtastic.Waypoint.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Waypoint
         * @static
         * @param {meshtastic.IWaypoint} message Waypoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Waypoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.latitudeI != null && Object.hasOwnProperty.call(message, "latitudeI"))
                writer.uint32(/* id 2, wireType 5 =*/21).sfixed32(message.latitudeI);
            if (message.longitudeI != null && Object.hasOwnProperty.call(message, "longitudeI"))
                writer.uint32(/* id 3, wireType 5 =*/29).sfixed32(message.longitudeI);
            if (message.expire != null && Object.hasOwnProperty.call(message, "expire"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expire);
            if (message.lockedTo != null && Object.hasOwnProperty.call(message, "lockedTo"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.lockedTo);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
            if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
                writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.icon);
            return writer;
        };

        /**
         * Encodes the specified Waypoint message, length delimited. Does not implicitly {@link meshtastic.Waypoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Waypoint
         * @static
         * @param {meshtastic.IWaypoint} message Waypoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Waypoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Waypoint message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Waypoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Waypoint} Waypoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Waypoint.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Waypoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.latitudeI = reader.sfixed32();
                        break;
                    }
                case 3: {
                        message.longitudeI = reader.sfixed32();
                        break;
                    }
                case 4: {
                        message.expire = reader.uint32();
                        break;
                    }
                case 5: {
                        message.lockedTo = reader.uint32();
                        break;
                    }
                case 6: {
                        message.name = reader.string();
                        break;
                    }
                case 7: {
                        message.description = reader.string();
                        break;
                    }
                case 8: {
                        message.icon = reader.fixed32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Waypoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Waypoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Waypoint} Waypoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Waypoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Waypoint message.
         * @function verify
         * @memberof meshtastic.Waypoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Waypoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI")) {
                properties._latitudeI = 1;
                if (!$util.isInteger(message.latitudeI))
                    return "latitudeI: integer expected";
            }
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI")) {
                properties._longitudeI = 1;
                if (!$util.isInteger(message.longitudeI))
                    return "longitudeI: integer expected";
            }
            if (message.expire != null && message.hasOwnProperty("expire"))
                if (!$util.isInteger(message.expire))
                    return "expire: integer expected";
            if (message.lockedTo != null && message.hasOwnProperty("lockedTo"))
                if (!$util.isInteger(message.lockedTo))
                    return "lockedTo: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.icon != null && message.hasOwnProperty("icon"))
                if (!$util.isInteger(message.icon))
                    return "icon: integer expected";
            return null;
        };

        /**
         * Creates a Waypoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Waypoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Waypoint} Waypoint
         */
        Waypoint.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Waypoint)
                return object;
            var message = new $root.meshtastic.Waypoint();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.latitudeI != null)
                message.latitudeI = object.latitudeI | 0;
            if (object.longitudeI != null)
                message.longitudeI = object.longitudeI | 0;
            if (object.expire != null)
                message.expire = object.expire >>> 0;
            if (object.lockedTo != null)
                message.lockedTo = object.lockedTo >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.description != null)
                message.description = String(object.description);
            if (object.icon != null)
                message.icon = object.icon >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Waypoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Waypoint
         * @static
         * @param {meshtastic.Waypoint} message Waypoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Waypoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.expire = 0;
                object.lockedTo = 0;
                object.name = "";
                object.description = "";
                object.icon = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.latitudeI != null && message.hasOwnProperty("latitudeI")) {
                object.latitudeI = message.latitudeI;
                if (options.oneofs)
                    object._latitudeI = "latitudeI";
            }
            if (message.longitudeI != null && message.hasOwnProperty("longitudeI")) {
                object.longitudeI = message.longitudeI;
                if (options.oneofs)
                    object._longitudeI = "longitudeI";
            }
            if (message.expire != null && message.hasOwnProperty("expire"))
                object.expire = message.expire;
            if (message.lockedTo != null && message.hasOwnProperty("lockedTo"))
                object.lockedTo = message.lockedTo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.icon != null && message.hasOwnProperty("icon"))
                object.icon = message.icon;
            return object;
        };

        /**
         * Converts this Waypoint to JSON.
         * @function toJSON
         * @memberof meshtastic.Waypoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Waypoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Waypoint
         * @function getTypeUrl
         * @memberof meshtastic.Waypoint
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Waypoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Waypoint";
        };

        return Waypoint;
    })();

    meshtastic.MqttClientProxyMessage = (function() {

        /**
         * Properties of a MqttClientProxyMessage.
         * @memberof meshtastic
         * @interface IMqttClientProxyMessage
         * @property {string|null} [topic] MqttClientProxyMessage topic
         * @property {Uint8Array|null} [data] MqttClientProxyMessage data
         * @property {string|null} [text] MqttClientProxyMessage text
         * @property {boolean|null} [retained] MqttClientProxyMessage retained
         */

        /**
         * Constructs a new MqttClientProxyMessage.
         * @memberof meshtastic
         * @classdesc Represents a MqttClientProxyMessage.
         * @implements IMqttClientProxyMessage
         * @constructor
         * @param {meshtastic.IMqttClientProxyMessage=} [properties] Properties to set
         */
        function MqttClientProxyMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MqttClientProxyMessage topic.
         * @member {string} topic
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         */
        MqttClientProxyMessage.prototype.topic = "";

        /**
         * MqttClientProxyMessage data.
         * @member {Uint8Array|null|undefined} data
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         */
        MqttClientProxyMessage.prototype.data = null;

        /**
         * MqttClientProxyMessage text.
         * @member {string|null|undefined} text
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         */
        MqttClientProxyMessage.prototype.text = null;

        /**
         * MqttClientProxyMessage retained.
         * @member {boolean} retained
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         */
        MqttClientProxyMessage.prototype.retained = false;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * MqttClientProxyMessage payloadVariant.
         * @member {"data"|"text"|undefined} payloadVariant
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         */
        Object.defineProperty(MqttClientProxyMessage.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["data", "text"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new MqttClientProxyMessage instance using the specified properties.
         * @function create
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {meshtastic.IMqttClientProxyMessage=} [properties] Properties to set
         * @returns {meshtastic.MqttClientProxyMessage} MqttClientProxyMessage instance
         */
        MqttClientProxyMessage.create = function create(properties) {
            return new MqttClientProxyMessage(properties);
        };

        /**
         * Encodes the specified MqttClientProxyMessage message. Does not implicitly {@link meshtastic.MqttClientProxyMessage.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {meshtastic.IMqttClientProxyMessage} message MqttClientProxyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MqttClientProxyMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.topic != null && Object.hasOwnProperty.call(message, "topic"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.topic);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            if (message.retained != null && Object.hasOwnProperty.call(message, "retained"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.retained);
            return writer;
        };

        /**
         * Encodes the specified MqttClientProxyMessage message, length delimited. Does not implicitly {@link meshtastic.MqttClientProxyMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {meshtastic.IMqttClientProxyMessage} message MqttClientProxyMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MqttClientProxyMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MqttClientProxyMessage message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.MqttClientProxyMessage} MqttClientProxyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MqttClientProxyMessage.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.MqttClientProxyMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.topic = reader.string();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                case 3: {
                        message.text = reader.string();
                        break;
                    }
                case 4: {
                        message.retained = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MqttClientProxyMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.MqttClientProxyMessage} MqttClientProxyMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MqttClientProxyMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MqttClientProxyMessage message.
         * @function verify
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MqttClientProxyMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.topic != null && message.hasOwnProperty("topic"))
                if (!$util.isString(message.topic))
                    return "topic: string expected";
            if (message.data != null && message.hasOwnProperty("data")) {
                properties.payloadVariant = 1;
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (!$util.isString(message.text))
                    return "text: string expected";
            }
            if (message.retained != null && message.hasOwnProperty("retained"))
                if (typeof message.retained !== "boolean")
                    return "retained: boolean expected";
            return null;
        };

        /**
         * Creates a MqttClientProxyMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.MqttClientProxyMessage} MqttClientProxyMessage
         */
        MqttClientProxyMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.MqttClientProxyMessage)
                return object;
            var message = new $root.meshtastic.MqttClientProxyMessage();
            if (object.topic != null)
                message.topic = String(object.topic);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            if (object.text != null)
                message.text = String(object.text);
            if (object.retained != null)
                message.retained = Boolean(object.retained);
            return message;
        };

        /**
         * Creates a plain object from a MqttClientProxyMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {meshtastic.MqttClientProxyMessage} message MqttClientProxyMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MqttClientProxyMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.topic = "";
                object.retained = false;
            }
            if (message.topic != null && message.hasOwnProperty("topic"))
                object.topic = message.topic;
            if (message.data != null && message.hasOwnProperty("data")) {
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (options.oneofs)
                    object.payloadVariant = "data";
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                object.text = message.text;
                if (options.oneofs)
                    object.payloadVariant = "text";
            }
            if (message.retained != null && message.hasOwnProperty("retained"))
                object.retained = message.retained;
            return object;
        };

        /**
         * Converts this MqttClientProxyMessage to JSON.
         * @function toJSON
         * @memberof meshtastic.MqttClientProxyMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MqttClientProxyMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MqttClientProxyMessage
         * @function getTypeUrl
         * @memberof meshtastic.MqttClientProxyMessage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MqttClientProxyMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.MqttClientProxyMessage";
        };

        return MqttClientProxyMessage;
    })();

    meshtastic.MeshPacket = (function() {

        /**
         * Properties of a MeshPacket.
         * @memberof meshtastic
         * @interface IMeshPacket
         * @property {number|null} [from] MeshPacket from
         * @property {number|null} [to] MeshPacket to
         * @property {number|null} [channel] MeshPacket channel
         * @property {meshtastic.IData|null} [decoded] MeshPacket decoded
         * @property {Uint8Array|null} [encrypted] MeshPacket encrypted
         * @property {number|null} [id] MeshPacket id
         * @property {number|null} [rxTime] MeshPacket rxTime
         * @property {number|null} [rxSnr] MeshPacket rxSnr
         * @property {number|null} [hopLimit] MeshPacket hopLimit
         * @property {boolean|null} [wantAck] MeshPacket wantAck
         * @property {meshtastic.MeshPacket.Priority|null} [priority] MeshPacket priority
         * @property {number|null} [rxRssi] MeshPacket rxRssi
         * @property {meshtastic.MeshPacket.Delayed|null} [delayed] MeshPacket delayed
         * @property {boolean|null} [viaMqtt] MeshPacket viaMqtt
         * @property {number|null} [hopStart] MeshPacket hopStart
         * @property {Uint8Array|null} [publicKey] MeshPacket publicKey
         * @property {boolean|null} [pkiEncrypted] MeshPacket pkiEncrypted
         * @property {number|null} [nextHop] MeshPacket nextHop
         * @property {number|null} [relayNode] MeshPacket relayNode
         * @property {number|null} [txAfter] MeshPacket txAfter
         * @property {meshtastic.MeshPacket.TransportMechanism|null} [transportMechanism] MeshPacket transportMechanism
         */

        /**
         * Constructs a new MeshPacket.
         * @memberof meshtastic
         * @classdesc Represents a MeshPacket.
         * @implements IMeshPacket
         * @constructor
         * @param {meshtastic.IMeshPacket=} [properties] Properties to set
         */
        function MeshPacket(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MeshPacket from.
         * @member {number} from
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.from = 0;

        /**
         * MeshPacket to.
         * @member {number} to
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.to = 0;

        /**
         * MeshPacket channel.
         * @member {number} channel
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.channel = 0;

        /**
         * MeshPacket decoded.
         * @member {meshtastic.IData|null|undefined} decoded
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.decoded = null;

        /**
         * MeshPacket encrypted.
         * @member {Uint8Array|null|undefined} encrypted
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.encrypted = null;

        /**
         * MeshPacket id.
         * @member {number} id
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.id = 0;

        /**
         * MeshPacket rxTime.
         * @member {number} rxTime
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.rxTime = 0;

        /**
         * MeshPacket rxSnr.
         * @member {number} rxSnr
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.rxSnr = 0;

        /**
         * MeshPacket hopLimit.
         * @member {number} hopLimit
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.hopLimit = 0;

        /**
         * MeshPacket wantAck.
         * @member {boolean} wantAck
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.wantAck = false;

        /**
         * MeshPacket priority.
         * @member {meshtastic.MeshPacket.Priority} priority
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.priority = 0;

        /**
         * MeshPacket rxRssi.
         * @member {number} rxRssi
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.rxRssi = 0;

        /**
         * MeshPacket delayed.
         * @member {meshtastic.MeshPacket.Delayed} delayed
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.delayed = 0;

        /**
         * MeshPacket viaMqtt.
         * @member {boolean} viaMqtt
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.viaMqtt = false;

        /**
         * MeshPacket hopStart.
         * @member {number} hopStart
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.hopStart = 0;

        /**
         * MeshPacket publicKey.
         * @member {Uint8Array} publicKey
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.publicKey = $util.newBuffer([]);

        /**
         * MeshPacket pkiEncrypted.
         * @member {boolean} pkiEncrypted
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.pkiEncrypted = false;

        /**
         * MeshPacket nextHop.
         * @member {number} nextHop
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.nextHop = 0;

        /**
         * MeshPacket relayNode.
         * @member {number} relayNode
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.relayNode = 0;

        /**
         * MeshPacket txAfter.
         * @member {number} txAfter
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.txAfter = 0;

        /**
         * MeshPacket transportMechanism.
         * @member {meshtastic.MeshPacket.TransportMechanism} transportMechanism
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        MeshPacket.prototype.transportMechanism = 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * MeshPacket payloadVariant.
         * @member {"decoded"|"encrypted"|undefined} payloadVariant
         * @memberof meshtastic.MeshPacket
         * @instance
         */
        Object.defineProperty(MeshPacket.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["decoded", "encrypted"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new MeshPacket instance using the specified properties.
         * @function create
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {meshtastic.IMeshPacket=} [properties] Properties to set
         * @returns {meshtastic.MeshPacket} MeshPacket instance
         */
        MeshPacket.create = function create(properties) {
            return new MeshPacket(properties);
        };

        /**
         * Encodes the specified MeshPacket message. Does not implicitly {@link meshtastic.MeshPacket.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {meshtastic.IMeshPacket} message MeshPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MeshPacket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.to);
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.channel);
            if (message.decoded != null && Object.hasOwnProperty.call(message, "decoded"))
                $root.meshtastic.Data.encode(message.decoded, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.encrypted != null && Object.hasOwnProperty.call(message, "encrypted"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encrypted);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.id);
            if (message.rxTime != null && Object.hasOwnProperty.call(message, "rxTime"))
                writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.rxTime);
            if (message.rxSnr != null && Object.hasOwnProperty.call(message, "rxSnr"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.rxSnr);
            if (message.hopLimit != null && Object.hasOwnProperty.call(message, "hopLimit"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.hopLimit);
            if (message.wantAck != null && Object.hasOwnProperty.call(message, "wantAck"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.wantAck);
            if (message.priority != null && Object.hasOwnProperty.call(message, "priority"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.priority);
            if (message.rxRssi != null && Object.hasOwnProperty.call(message, "rxRssi"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.rxRssi);
            if (message.delayed != null && Object.hasOwnProperty.call(message, "delayed"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.delayed);
            if (message.viaMqtt != null && Object.hasOwnProperty.call(message, "viaMqtt"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.viaMqtt);
            if (message.hopStart != null && Object.hasOwnProperty.call(message, "hopStart"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.hopStart);
            if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.publicKey);
            if (message.pkiEncrypted != null && Object.hasOwnProperty.call(message, "pkiEncrypted"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.pkiEncrypted);
            if (message.nextHop != null && Object.hasOwnProperty.call(message, "nextHop"))
                writer.uint32(/* id 18, wireType 0 =*/144).uint32(message.nextHop);
            if (message.relayNode != null && Object.hasOwnProperty.call(message, "relayNode"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.relayNode);
            if (message.txAfter != null && Object.hasOwnProperty.call(message, "txAfter"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.txAfter);
            if (message.transportMechanism != null && Object.hasOwnProperty.call(message, "transportMechanism"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.transportMechanism);
            return writer;
        };

        /**
         * Encodes the specified MeshPacket message, length delimited. Does not implicitly {@link meshtastic.MeshPacket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {meshtastic.IMeshPacket} message MeshPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MeshPacket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MeshPacket message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.MeshPacket} MeshPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MeshPacket.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.MeshPacket();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.from = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.to = reader.fixed32();
                        break;
                    }
                case 3: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 4: {
                        message.decoded = $root.meshtastic.Data.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.encrypted = reader.bytes();
                        break;
                    }
                case 6: {
                        message.id = reader.fixed32();
                        break;
                    }
                case 7: {
                        message.rxTime = reader.fixed32();
                        break;
                    }
                case 8: {
                        message.rxSnr = reader.float();
                        break;
                    }
                case 9: {
                        message.hopLimit = reader.uint32();
                        break;
                    }
                case 10: {
                        message.wantAck = reader.bool();
                        break;
                    }
                case 11: {
                        message.priority = reader.int32();
                        break;
                    }
                case 12: {
                        message.rxRssi = reader.int32();
                        break;
                    }
                case 13: {
                        message.delayed = reader.int32();
                        break;
                    }
                case 14: {
                        message.viaMqtt = reader.bool();
                        break;
                    }
                case 15: {
                        message.hopStart = reader.uint32();
                        break;
                    }
                case 16: {
                        message.publicKey = reader.bytes();
                        break;
                    }
                case 17: {
                        message.pkiEncrypted = reader.bool();
                        break;
                    }
                case 18: {
                        message.nextHop = reader.uint32();
                        break;
                    }
                case 19: {
                        message.relayNode = reader.uint32();
                        break;
                    }
                case 20: {
                        message.txAfter = reader.uint32();
                        break;
                    }
                case 21: {
                        message.transportMechanism = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MeshPacket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.MeshPacket} MeshPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MeshPacket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MeshPacket message.
         * @function verify
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MeshPacket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from))
                    return "from: integer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to))
                    return "to: integer expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.decoded != null && message.hasOwnProperty("decoded")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Data.verify(message.decoded);
                    if (error)
                        return "decoded." + error;
                }
            }
            if (message.encrypted != null && message.hasOwnProperty("encrypted")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (!(message.encrypted && typeof message.encrypted.length === "number" || $util.isString(message.encrypted)))
                    return "encrypted: buffer expected";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.rxTime != null && message.hasOwnProperty("rxTime"))
                if (!$util.isInteger(message.rxTime))
                    return "rxTime: integer expected";
            if (message.rxSnr != null && message.hasOwnProperty("rxSnr"))
                if (typeof message.rxSnr !== "number")
                    return "rxSnr: number expected";
            if (message.hopLimit != null && message.hasOwnProperty("hopLimit"))
                if (!$util.isInteger(message.hopLimit))
                    return "hopLimit: integer expected";
            if (message.wantAck != null && message.hasOwnProperty("wantAck"))
                if (typeof message.wantAck !== "boolean")
                    return "wantAck: boolean expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                switch (message.priority) {
                default:
                    return "priority: enum value expected";
                case 0:
                case 1:
                case 10:
                case 64:
                case 70:
                case 80:
                case 100:
                case 110:
                case 120:
                case 127:
                    break;
                }
            if (message.rxRssi != null && message.hasOwnProperty("rxRssi"))
                if (!$util.isInteger(message.rxRssi))
                    return "rxRssi: integer expected";
            if (message.delayed != null && message.hasOwnProperty("delayed"))
                switch (message.delayed) {
                default:
                    return "delayed: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.viaMqtt != null && message.hasOwnProperty("viaMqtt"))
                if (typeof message.viaMqtt !== "boolean")
                    return "viaMqtt: boolean expected";
            if (message.hopStart != null && message.hasOwnProperty("hopStart"))
                if (!$util.isInteger(message.hopStart))
                    return "hopStart: integer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.pkiEncrypted != null && message.hasOwnProperty("pkiEncrypted"))
                if (typeof message.pkiEncrypted !== "boolean")
                    return "pkiEncrypted: boolean expected";
            if (message.nextHop != null && message.hasOwnProperty("nextHop"))
                if (!$util.isInteger(message.nextHop))
                    return "nextHop: integer expected";
            if (message.relayNode != null && message.hasOwnProperty("relayNode"))
                if (!$util.isInteger(message.relayNode))
                    return "relayNode: integer expected";
            if (message.txAfter != null && message.hasOwnProperty("txAfter"))
                if (!$util.isInteger(message.txAfter))
                    return "txAfter: integer expected";
            if (message.transportMechanism != null && message.hasOwnProperty("transportMechanism"))
                switch (message.transportMechanism) {
                default:
                    return "transportMechanism: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            return null;
        };

        /**
         * Creates a MeshPacket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.MeshPacket} MeshPacket
         */
        MeshPacket.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.MeshPacket)
                return object;
            var message = new $root.meshtastic.MeshPacket();
            if (object.from != null)
                message.from = object.from >>> 0;
            if (object.to != null)
                message.to = object.to >>> 0;
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.decoded != null) {
                if (typeof object.decoded !== "object")
                    throw TypeError(".meshtastic.MeshPacket.decoded: object expected");
                message.decoded = $root.meshtastic.Data.fromObject(object.decoded);
            }
            if (object.encrypted != null)
                if (typeof object.encrypted === "string")
                    $util.base64.decode(object.encrypted, message.encrypted = $util.newBuffer($util.base64.length(object.encrypted)), 0);
                else if (object.encrypted.length >= 0)
                    message.encrypted = object.encrypted;
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.rxTime != null)
                message.rxTime = object.rxTime >>> 0;
            if (object.rxSnr != null)
                message.rxSnr = Number(object.rxSnr);
            if (object.hopLimit != null)
                message.hopLimit = object.hopLimit >>> 0;
            if (object.wantAck != null)
                message.wantAck = Boolean(object.wantAck);
            switch (object.priority) {
            default:
                if (typeof object.priority === "number") {
                    message.priority = object.priority;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.priority = 0;
                break;
            case "MIN":
            case 1:
                message.priority = 1;
                break;
            case "BACKGROUND":
            case 10:
                message.priority = 10;
                break;
            case "DEFAULT":
            case 64:
                message.priority = 64;
                break;
            case "RELIABLE":
            case 70:
                message.priority = 70;
                break;
            case "RESPONSE":
            case 80:
                message.priority = 80;
                break;
            case "HIGH":
            case 100:
                message.priority = 100;
                break;
            case "ALERT":
            case 110:
                message.priority = 110;
                break;
            case "ACK":
            case 120:
                message.priority = 120;
                break;
            case "MAX":
            case 127:
                message.priority = 127;
                break;
            }
            if (object.rxRssi != null)
                message.rxRssi = object.rxRssi | 0;
            switch (object.delayed) {
            default:
                if (typeof object.delayed === "number") {
                    message.delayed = object.delayed;
                    break;
                }
                break;
            case "NO_DELAY":
            case 0:
                message.delayed = 0;
                break;
            case "DELAYED_BROADCAST":
            case 1:
                message.delayed = 1;
                break;
            case "DELAYED_DIRECT":
            case 2:
                message.delayed = 2;
                break;
            }
            if (object.viaMqtt != null)
                message.viaMqtt = Boolean(object.viaMqtt);
            if (object.hopStart != null)
                message.hopStart = object.hopStart >>> 0;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length >= 0)
                    message.publicKey = object.publicKey;
            if (object.pkiEncrypted != null)
                message.pkiEncrypted = Boolean(object.pkiEncrypted);
            if (object.nextHop != null)
                message.nextHop = object.nextHop >>> 0;
            if (object.relayNode != null)
                message.relayNode = object.relayNode >>> 0;
            if (object.txAfter != null)
                message.txAfter = object.txAfter >>> 0;
            switch (object.transportMechanism) {
            default:
                if (typeof object.transportMechanism === "number") {
                    message.transportMechanism = object.transportMechanism;
                    break;
                }
                break;
            case "TRANSPORT_INTERNAL":
            case 0:
                message.transportMechanism = 0;
                break;
            case "TRANSPORT_LORA":
            case 1:
                message.transportMechanism = 1;
                break;
            case "TRANSPORT_LORA_ALT1":
            case 2:
                message.transportMechanism = 2;
                break;
            case "TRANSPORT_LORA_ALT2":
            case 3:
                message.transportMechanism = 3;
                break;
            case "TRANSPORT_LORA_ALT3":
            case 4:
                message.transportMechanism = 4;
                break;
            case "TRANSPORT_MQTT":
            case 5:
                message.transportMechanism = 5;
                break;
            case "TRANSPORT_MULTICAST_UDP":
            case 6:
                message.transportMechanism = 6;
                break;
            case "TRANSPORT_API":
            case 7:
                message.transportMechanism = 7;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MeshPacket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {meshtastic.MeshPacket} message MeshPacket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MeshPacket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = 0;
                object.to = 0;
                object.channel = 0;
                object.id = 0;
                object.rxTime = 0;
                object.rxSnr = 0;
                object.hopLimit = 0;
                object.wantAck = false;
                object.priority = options.enums === String ? "UNSET" : 0;
                object.rxRssi = 0;
                object.delayed = options.enums === String ? "NO_DELAY" : 0;
                object.viaMqtt = false;
                object.hopStart = 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.pkiEncrypted = false;
                object.nextHop = 0;
                object.relayNode = 0;
                object.txAfter = 0;
                object.transportMechanism = options.enums === String ? "TRANSPORT_INTERNAL" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = message.to;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.decoded != null && message.hasOwnProperty("decoded")) {
                object.decoded = $root.meshtastic.Data.toObject(message.decoded, options);
                if (options.oneofs)
                    object.payloadVariant = "decoded";
            }
            if (message.encrypted != null && message.hasOwnProperty("encrypted")) {
                object.encrypted = options.bytes === String ? $util.base64.encode(message.encrypted, 0, message.encrypted.length) : options.bytes === Array ? Array.prototype.slice.call(message.encrypted) : message.encrypted;
                if (options.oneofs)
                    object.payloadVariant = "encrypted";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rxTime != null && message.hasOwnProperty("rxTime"))
                object.rxTime = message.rxTime;
            if (message.rxSnr != null && message.hasOwnProperty("rxSnr"))
                object.rxSnr = options.json && !isFinite(message.rxSnr) ? String(message.rxSnr) : message.rxSnr;
            if (message.hopLimit != null && message.hasOwnProperty("hopLimit"))
                object.hopLimit = message.hopLimit;
            if (message.wantAck != null && message.hasOwnProperty("wantAck"))
                object.wantAck = message.wantAck;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = options.enums === String ? $root.meshtastic.MeshPacket.Priority[message.priority] === undefined ? message.priority : $root.meshtastic.MeshPacket.Priority[message.priority] : message.priority;
            if (message.rxRssi != null && message.hasOwnProperty("rxRssi"))
                object.rxRssi = message.rxRssi;
            if (message.delayed != null && message.hasOwnProperty("delayed"))
                object.delayed = options.enums === String ? $root.meshtastic.MeshPacket.Delayed[message.delayed] === undefined ? message.delayed : $root.meshtastic.MeshPacket.Delayed[message.delayed] : message.delayed;
            if (message.viaMqtt != null && message.hasOwnProperty("viaMqtt"))
                object.viaMqtt = message.viaMqtt;
            if (message.hopStart != null && message.hasOwnProperty("hopStart"))
                object.hopStart = message.hopStart;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.pkiEncrypted != null && message.hasOwnProperty("pkiEncrypted"))
                object.pkiEncrypted = message.pkiEncrypted;
            if (message.nextHop != null && message.hasOwnProperty("nextHop"))
                object.nextHop = message.nextHop;
            if (message.relayNode != null && message.hasOwnProperty("relayNode"))
                object.relayNode = message.relayNode;
            if (message.txAfter != null && message.hasOwnProperty("txAfter"))
                object.txAfter = message.txAfter;
            if (message.transportMechanism != null && message.hasOwnProperty("transportMechanism"))
                object.transportMechanism = options.enums === String ? $root.meshtastic.MeshPacket.TransportMechanism[message.transportMechanism] === undefined ? message.transportMechanism : $root.meshtastic.MeshPacket.TransportMechanism[message.transportMechanism] : message.transportMechanism;
            return object;
        };

        /**
         * Converts this MeshPacket to JSON.
         * @function toJSON
         * @memberof meshtastic.MeshPacket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MeshPacket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MeshPacket
         * @function getTypeUrl
         * @memberof meshtastic.MeshPacket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MeshPacket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.MeshPacket";
        };

        /**
         * Priority enum.
         * @name meshtastic.MeshPacket.Priority
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} MIN=1 MIN value
         * @property {number} BACKGROUND=10 BACKGROUND value
         * @property {number} DEFAULT=64 DEFAULT value
         * @property {number} RELIABLE=70 RELIABLE value
         * @property {number} RESPONSE=80 RESPONSE value
         * @property {number} HIGH=100 HIGH value
         * @property {number} ALERT=110 ALERT value
         * @property {number} ACK=120 ACK value
         * @property {number} MAX=127 MAX value
         */
        MeshPacket.Priority = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[1] = "MIN"] = 1;
            values[valuesById[10] = "BACKGROUND"] = 10;
            values[valuesById[64] = "DEFAULT"] = 64;
            values[valuesById[70] = "RELIABLE"] = 70;
            values[valuesById[80] = "RESPONSE"] = 80;
            values[valuesById[100] = "HIGH"] = 100;
            values[valuesById[110] = "ALERT"] = 110;
            values[valuesById[120] = "ACK"] = 120;
            values[valuesById[127] = "MAX"] = 127;
            return values;
        })();

        /**
         * Delayed enum.
         * @name meshtastic.MeshPacket.Delayed
         * @enum {number}
         * @property {number} NO_DELAY=0 NO_DELAY value
         * @property {number} DELAYED_BROADCAST=1 DELAYED_BROADCAST value
         * @property {number} DELAYED_DIRECT=2 DELAYED_DIRECT value
         */
        MeshPacket.Delayed = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NO_DELAY"] = 0;
            values[valuesById[1] = "DELAYED_BROADCAST"] = 1;
            values[valuesById[2] = "DELAYED_DIRECT"] = 2;
            return values;
        })();

        /**
         * TransportMechanism enum.
         * @name meshtastic.MeshPacket.TransportMechanism
         * @enum {number}
         * @property {number} TRANSPORT_INTERNAL=0 TRANSPORT_INTERNAL value
         * @property {number} TRANSPORT_LORA=1 TRANSPORT_LORA value
         * @property {number} TRANSPORT_LORA_ALT1=2 TRANSPORT_LORA_ALT1 value
         * @property {number} TRANSPORT_LORA_ALT2=3 TRANSPORT_LORA_ALT2 value
         * @property {number} TRANSPORT_LORA_ALT3=4 TRANSPORT_LORA_ALT3 value
         * @property {number} TRANSPORT_MQTT=5 TRANSPORT_MQTT value
         * @property {number} TRANSPORT_MULTICAST_UDP=6 TRANSPORT_MULTICAST_UDP value
         * @property {number} TRANSPORT_API=7 TRANSPORT_API value
         */
        MeshPacket.TransportMechanism = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TRANSPORT_INTERNAL"] = 0;
            values[valuesById[1] = "TRANSPORT_LORA"] = 1;
            values[valuesById[2] = "TRANSPORT_LORA_ALT1"] = 2;
            values[valuesById[3] = "TRANSPORT_LORA_ALT2"] = 3;
            values[valuesById[4] = "TRANSPORT_LORA_ALT3"] = 4;
            values[valuesById[5] = "TRANSPORT_MQTT"] = 5;
            values[valuesById[6] = "TRANSPORT_MULTICAST_UDP"] = 6;
            values[valuesById[7] = "TRANSPORT_API"] = 7;
            return values;
        })();

        return MeshPacket;
    })();

    /**
     * Constants enum.
     * @name meshtastic.Constants
     * @enum {number}
     * @property {number} ZERO=0 ZERO value
     * @property {number} DATA_PAYLOAD_LEN=233 DATA_PAYLOAD_LEN value
     */
    meshtastic.Constants = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ZERO"] = 0;
        values[valuesById[233] = "DATA_PAYLOAD_LEN"] = 233;
        return values;
    })();

    meshtastic.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof meshtastic
         * @interface INodeInfo
         * @property {number|null} [num] NodeInfo num
         * @property {meshtastic.IUser|null} [user] NodeInfo user
         * @property {meshtastic.IPosition|null} [position] NodeInfo position
         * @property {number|null} [snr] NodeInfo snr
         * @property {number|null} [lastHeard] NodeInfo lastHeard
         * @property {meshtastic.IDeviceMetrics|null} [deviceMetrics] NodeInfo deviceMetrics
         * @property {number|null} [channel] NodeInfo channel
         * @property {boolean|null} [viaMqtt] NodeInfo viaMqtt
         * @property {number|null} [hopsAway] NodeInfo hopsAway
         * @property {boolean|null} [isFavorite] NodeInfo isFavorite
         * @property {boolean|null} [isIgnored] NodeInfo isIgnored
         * @property {boolean|null} [isKeyManuallyVerified] NodeInfo isKeyManuallyVerified
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof meshtastic
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {meshtastic.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeInfo num.
         * @member {number} num
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.num = 0;

        /**
         * NodeInfo user.
         * @member {meshtastic.IUser|null|undefined} user
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.user = null;

        /**
         * NodeInfo position.
         * @member {meshtastic.IPosition|null|undefined} position
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.position = null;

        /**
         * NodeInfo snr.
         * @member {number} snr
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.snr = 0;

        /**
         * NodeInfo lastHeard.
         * @member {number} lastHeard
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.lastHeard = 0;

        /**
         * NodeInfo deviceMetrics.
         * @member {meshtastic.IDeviceMetrics|null|undefined} deviceMetrics
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.deviceMetrics = null;

        /**
         * NodeInfo channel.
         * @member {number} channel
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.channel = 0;

        /**
         * NodeInfo viaMqtt.
         * @member {boolean} viaMqtt
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.viaMqtt = false;

        /**
         * NodeInfo hopsAway.
         * @member {number|null|undefined} hopsAway
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.hopsAway = null;

        /**
         * NodeInfo isFavorite.
         * @member {boolean} isFavorite
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.isFavorite = false;

        /**
         * NodeInfo isIgnored.
         * @member {boolean} isIgnored
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.isIgnored = false;

        /**
         * NodeInfo isKeyManuallyVerified.
         * @member {boolean} isKeyManuallyVerified
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        NodeInfo.prototype.isKeyManuallyVerified = false;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * NodeInfo _hopsAway.
         * @member {"hopsAway"|undefined} _hopsAway
         * @memberof meshtastic.NodeInfo
         * @instance
         */
        Object.defineProperty(NodeInfo.prototype, "_hopsAway", {
            get: $util.oneOfGetter($oneOfFields = ["hopsAway"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {meshtastic.INodeInfo=} [properties] Properties to set
         * @returns {meshtastic.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link meshtastic.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {meshtastic.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.num);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.meshtastic.User.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.meshtastic.Position.encode(message.position, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.snr != null && Object.hasOwnProperty.call(message, "snr"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.snr);
            if (message.lastHeard != null && Object.hasOwnProperty.call(message, "lastHeard"))
                writer.uint32(/* id 5, wireType 5 =*/45).fixed32(message.lastHeard);
            if (message.deviceMetrics != null && Object.hasOwnProperty.call(message, "deviceMetrics"))
                $root.meshtastic.DeviceMetrics.encode(message.deviceMetrics, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.channel);
            if (message.viaMqtt != null && Object.hasOwnProperty.call(message, "viaMqtt"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.viaMqtt);
            if (message.hopsAway != null && Object.hasOwnProperty.call(message, "hopsAway"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.hopsAway);
            if (message.isFavorite != null && Object.hasOwnProperty.call(message, "isFavorite"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isFavorite);
            if (message.isIgnored != null && Object.hasOwnProperty.call(message, "isIgnored"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.isIgnored);
            if (message.isKeyManuallyVerified != null && Object.hasOwnProperty.call(message, "isKeyManuallyVerified"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.isKeyManuallyVerified);
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link meshtastic.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {meshtastic.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.NodeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.num = reader.uint32();
                        break;
                    }
                case 2: {
                        message.user = $root.meshtastic.User.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.position = $root.meshtastic.Position.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.snr = reader.float();
                        break;
                    }
                case 5: {
                        message.lastHeard = reader.fixed32();
                        break;
                    }
                case 6: {
                        message.deviceMetrics = $root.meshtastic.DeviceMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.channel = reader.uint32();
                        break;
                    }
                case 8: {
                        message.viaMqtt = reader.bool();
                        break;
                    }
                case 9: {
                        message.hopsAway = reader.uint32();
                        break;
                    }
                case 10: {
                        message.isFavorite = reader.bool();
                        break;
                    }
                case 11: {
                        message.isIgnored = reader.bool();
                        break;
                    }
                case 12: {
                        message.isKeyManuallyVerified = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                var error = $root.meshtastic.User.verify(message.user);
                if (error)
                    return "user." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                var error = $root.meshtastic.Position.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.snr != null && message.hasOwnProperty("snr"))
                if (typeof message.snr !== "number")
                    return "snr: number expected";
            if (message.lastHeard != null && message.hasOwnProperty("lastHeard"))
                if (!$util.isInteger(message.lastHeard))
                    return "lastHeard: integer expected";
            if (message.deviceMetrics != null && message.hasOwnProperty("deviceMetrics")) {
                var error = $root.meshtastic.DeviceMetrics.verify(message.deviceMetrics);
                if (error)
                    return "deviceMetrics." + error;
            }
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isInteger(message.channel))
                    return "channel: integer expected";
            if (message.viaMqtt != null && message.hasOwnProperty("viaMqtt"))
                if (typeof message.viaMqtt !== "boolean")
                    return "viaMqtt: boolean expected";
            if (message.hopsAway != null && message.hasOwnProperty("hopsAway")) {
                properties._hopsAway = 1;
                if (!$util.isInteger(message.hopsAway))
                    return "hopsAway: integer expected";
            }
            if (message.isFavorite != null && message.hasOwnProperty("isFavorite"))
                if (typeof message.isFavorite !== "boolean")
                    return "isFavorite: boolean expected";
            if (message.isIgnored != null && message.hasOwnProperty("isIgnored"))
                if (typeof message.isIgnored !== "boolean")
                    return "isIgnored: boolean expected";
            if (message.isKeyManuallyVerified != null && message.hasOwnProperty("isKeyManuallyVerified"))
                if (typeof message.isKeyManuallyVerified !== "boolean")
                    return "isKeyManuallyVerified: boolean expected";
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.NodeInfo)
                return object;
            var message = new $root.meshtastic.NodeInfo();
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".meshtastic.NodeInfo.user: object expected");
                message.user = $root.meshtastic.User.fromObject(object.user);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".meshtastic.NodeInfo.position: object expected");
                message.position = $root.meshtastic.Position.fromObject(object.position);
            }
            if (object.snr != null)
                message.snr = Number(object.snr);
            if (object.lastHeard != null)
                message.lastHeard = object.lastHeard >>> 0;
            if (object.deviceMetrics != null) {
                if (typeof object.deviceMetrics !== "object")
                    throw TypeError(".meshtastic.NodeInfo.deviceMetrics: object expected");
                message.deviceMetrics = $root.meshtastic.DeviceMetrics.fromObject(object.deviceMetrics);
            }
            if (object.channel != null)
                message.channel = object.channel >>> 0;
            if (object.viaMqtt != null)
                message.viaMqtt = Boolean(object.viaMqtt);
            if (object.hopsAway != null)
                message.hopsAway = object.hopsAway >>> 0;
            if (object.isFavorite != null)
                message.isFavorite = Boolean(object.isFavorite);
            if (object.isIgnored != null)
                message.isIgnored = Boolean(object.isIgnored);
            if (object.isKeyManuallyVerified != null)
                message.isKeyManuallyVerified = Boolean(object.isKeyManuallyVerified);
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {meshtastic.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.num = 0;
                object.user = null;
                object.position = null;
                object.snr = 0;
                object.lastHeard = 0;
                object.deviceMetrics = null;
                object.channel = 0;
                object.viaMqtt = false;
                object.isFavorite = false;
                object.isIgnored = false;
                object.isKeyManuallyVerified = false;
            }
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.meshtastic.User.toObject(message.user, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.meshtastic.Position.toObject(message.position, options);
            if (message.snr != null && message.hasOwnProperty("snr"))
                object.snr = options.json && !isFinite(message.snr) ? String(message.snr) : message.snr;
            if (message.lastHeard != null && message.hasOwnProperty("lastHeard"))
                object.lastHeard = message.lastHeard;
            if (message.deviceMetrics != null && message.hasOwnProperty("deviceMetrics"))
                object.deviceMetrics = $root.meshtastic.DeviceMetrics.toObject(message.deviceMetrics, options);
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.viaMqtt != null && message.hasOwnProperty("viaMqtt"))
                object.viaMqtt = message.viaMqtt;
            if (message.hopsAway != null && message.hasOwnProperty("hopsAway")) {
                object.hopsAway = message.hopsAway;
                if (options.oneofs)
                    object._hopsAway = "hopsAway";
            }
            if (message.isFavorite != null && message.hasOwnProperty("isFavorite"))
                object.isFavorite = message.isFavorite;
            if (message.isIgnored != null && message.hasOwnProperty("isIgnored"))
                object.isIgnored = message.isIgnored;
            if (message.isKeyManuallyVerified != null && message.hasOwnProperty("isKeyManuallyVerified"))
                object.isKeyManuallyVerified = message.isKeyManuallyVerified;
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof meshtastic.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NodeInfo
         * @function getTypeUrl
         * @memberof meshtastic.NodeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.NodeInfo";
        };

        return NodeInfo;
    })();

    /**
     * CriticalErrorCode enum.
     * @name meshtastic.CriticalErrorCode
     * @enum {number}
     * @property {number} NONE=0 NONE value
     * @property {number} TX_WATCHDOG=1 TX_WATCHDOG value
     * @property {number} SLEEP_ENTER_WAIT=2 SLEEP_ENTER_WAIT value
     * @property {number} NO_RADIO=3 NO_RADIO value
     * @property {number} UNSPECIFIED=4 UNSPECIFIED value
     * @property {number} UBLOX_UNIT_FAILED=5 UBLOX_UNIT_FAILED value
     * @property {number} NO_AXP192=6 NO_AXP192 value
     * @property {number} INVALID_RADIO_SETTING=7 INVALID_RADIO_SETTING value
     * @property {number} TRANSMIT_FAILED=8 TRANSMIT_FAILED value
     * @property {number} BROWNOUT=9 BROWNOUT value
     * @property {number} SX1262_FAILURE=10 SX1262_FAILURE value
     * @property {number} RADIO_SPI_BUG=11 RADIO_SPI_BUG value
     * @property {number} FLASH_CORRUPTION_RECOVERABLE=12 FLASH_CORRUPTION_RECOVERABLE value
     * @property {number} FLASH_CORRUPTION_UNRECOVERABLE=13 FLASH_CORRUPTION_UNRECOVERABLE value
     */
    meshtastic.CriticalErrorCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "TX_WATCHDOG"] = 1;
        values[valuesById[2] = "SLEEP_ENTER_WAIT"] = 2;
        values[valuesById[3] = "NO_RADIO"] = 3;
        values[valuesById[4] = "UNSPECIFIED"] = 4;
        values[valuesById[5] = "UBLOX_UNIT_FAILED"] = 5;
        values[valuesById[6] = "NO_AXP192"] = 6;
        values[valuesById[7] = "INVALID_RADIO_SETTING"] = 7;
        values[valuesById[8] = "TRANSMIT_FAILED"] = 8;
        values[valuesById[9] = "BROWNOUT"] = 9;
        values[valuesById[10] = "SX1262_FAILURE"] = 10;
        values[valuesById[11] = "RADIO_SPI_BUG"] = 11;
        values[valuesById[12] = "FLASH_CORRUPTION_RECOVERABLE"] = 12;
        values[valuesById[13] = "FLASH_CORRUPTION_UNRECOVERABLE"] = 13;
        return values;
    })();

    /**
     * FirmwareEdition enum.
     * @name meshtastic.FirmwareEdition
     * @enum {number}
     * @property {number} VANILLA=0 VANILLA value
     * @property {number} SMART_CITIZEN=1 SMART_CITIZEN value
     * @property {number} OPEN_SAUCE=16 OPEN_SAUCE value
     * @property {number} DEFCON=17 DEFCON value
     * @property {number} BURNING_MAN=18 BURNING_MAN value
     * @property {number} HAMVENTION=19 HAMVENTION value
     * @property {number} DIY_EDITION=127 DIY_EDITION value
     */
    meshtastic.FirmwareEdition = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VANILLA"] = 0;
        values[valuesById[1] = "SMART_CITIZEN"] = 1;
        values[valuesById[16] = "OPEN_SAUCE"] = 16;
        values[valuesById[17] = "DEFCON"] = 17;
        values[valuesById[18] = "BURNING_MAN"] = 18;
        values[valuesById[19] = "HAMVENTION"] = 19;
        values[valuesById[127] = "DIY_EDITION"] = 127;
        return values;
    })();

    meshtastic.MyNodeInfo = (function() {

        /**
         * Properties of a MyNodeInfo.
         * @memberof meshtastic
         * @interface IMyNodeInfo
         * @property {number|null} [myNodeNum] MyNodeInfo myNodeNum
         * @property {number|null} [rebootCount] MyNodeInfo rebootCount
         * @property {number|null} [minAppVersion] MyNodeInfo minAppVersion
         * @property {Uint8Array|null} [deviceId] MyNodeInfo deviceId
         * @property {string|null} [pioEnv] MyNodeInfo pioEnv
         * @property {meshtastic.FirmwareEdition|null} [firmwareEdition] MyNodeInfo firmwareEdition
         * @property {number|null} [nodedbCount] MyNodeInfo nodedbCount
         */

        /**
         * Constructs a new MyNodeInfo.
         * @memberof meshtastic
         * @classdesc Represents a MyNodeInfo.
         * @implements IMyNodeInfo
         * @constructor
         * @param {meshtastic.IMyNodeInfo=} [properties] Properties to set
         */
        function MyNodeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyNodeInfo myNodeNum.
         * @member {number} myNodeNum
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.myNodeNum = 0;

        /**
         * MyNodeInfo rebootCount.
         * @member {number} rebootCount
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.rebootCount = 0;

        /**
         * MyNodeInfo minAppVersion.
         * @member {number} minAppVersion
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.minAppVersion = 0;

        /**
         * MyNodeInfo deviceId.
         * @member {Uint8Array} deviceId
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.deviceId = $util.newBuffer([]);

        /**
         * MyNodeInfo pioEnv.
         * @member {string} pioEnv
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.pioEnv = "";

        /**
         * MyNodeInfo firmwareEdition.
         * @member {meshtastic.FirmwareEdition} firmwareEdition
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.firmwareEdition = 0;

        /**
         * MyNodeInfo nodedbCount.
         * @member {number} nodedbCount
         * @memberof meshtastic.MyNodeInfo
         * @instance
         */
        MyNodeInfo.prototype.nodedbCount = 0;

        /**
         * Creates a new MyNodeInfo instance using the specified properties.
         * @function create
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {meshtastic.IMyNodeInfo=} [properties] Properties to set
         * @returns {meshtastic.MyNodeInfo} MyNodeInfo instance
         */
        MyNodeInfo.create = function create(properties) {
            return new MyNodeInfo(properties);
        };

        /**
         * Encodes the specified MyNodeInfo message. Does not implicitly {@link meshtastic.MyNodeInfo.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {meshtastic.IMyNodeInfo} message MyNodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MyNodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.myNodeNum != null && Object.hasOwnProperty.call(message, "myNodeNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.myNodeNum);
            if (message.rebootCount != null && Object.hasOwnProperty.call(message, "rebootCount"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.rebootCount);
            if (message.minAppVersion != null && Object.hasOwnProperty.call(message, "minAppVersion"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.minAppVersion);
            if (message.deviceId != null && Object.hasOwnProperty.call(message, "deviceId"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.deviceId);
            if (message.pioEnv != null && Object.hasOwnProperty.call(message, "pioEnv"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.pioEnv);
            if (message.firmwareEdition != null && Object.hasOwnProperty.call(message, "firmwareEdition"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.firmwareEdition);
            if (message.nodedbCount != null && Object.hasOwnProperty.call(message, "nodedbCount"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.nodedbCount);
            return writer;
        };

        /**
         * Encodes the specified MyNodeInfo message, length delimited. Does not implicitly {@link meshtastic.MyNodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {meshtastic.IMyNodeInfo} message MyNodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MyNodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MyNodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.MyNodeInfo} MyNodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyNodeInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.MyNodeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.myNodeNum = reader.uint32();
                        break;
                    }
                case 8: {
                        message.rebootCount = reader.uint32();
                        break;
                    }
                case 11: {
                        message.minAppVersion = reader.uint32();
                        break;
                    }
                case 12: {
                        message.deviceId = reader.bytes();
                        break;
                    }
                case 13: {
                        message.pioEnv = reader.string();
                        break;
                    }
                case 14: {
                        message.firmwareEdition = reader.int32();
                        break;
                    }
                case 15: {
                        message.nodedbCount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MyNodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.MyNodeInfo} MyNodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyNodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MyNodeInfo message.
         * @function verify
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MyNodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.myNodeNum != null && message.hasOwnProperty("myNodeNum"))
                if (!$util.isInteger(message.myNodeNum))
                    return "myNodeNum: integer expected";
            if (message.rebootCount != null && message.hasOwnProperty("rebootCount"))
                if (!$util.isInteger(message.rebootCount))
                    return "rebootCount: integer expected";
            if (message.minAppVersion != null && message.hasOwnProperty("minAppVersion"))
                if (!$util.isInteger(message.minAppVersion))
                    return "minAppVersion: integer expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!(message.deviceId && typeof message.deviceId.length === "number" || $util.isString(message.deviceId)))
                    return "deviceId: buffer expected";
            if (message.pioEnv != null && message.hasOwnProperty("pioEnv"))
                if (!$util.isString(message.pioEnv))
                    return "pioEnv: string expected";
            if (message.firmwareEdition != null && message.hasOwnProperty("firmwareEdition"))
                switch (message.firmwareEdition) {
                default:
                    return "firmwareEdition: enum value expected";
                case 0:
                case 1:
                case 16:
                case 17:
                case 18:
                case 19:
                case 127:
                    break;
                }
            if (message.nodedbCount != null && message.hasOwnProperty("nodedbCount"))
                if (!$util.isInteger(message.nodedbCount))
                    return "nodedbCount: integer expected";
            return null;
        };

        /**
         * Creates a MyNodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.MyNodeInfo} MyNodeInfo
         */
        MyNodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.MyNodeInfo)
                return object;
            var message = new $root.meshtastic.MyNodeInfo();
            if (object.myNodeNum != null)
                message.myNodeNum = object.myNodeNum >>> 0;
            if (object.rebootCount != null)
                message.rebootCount = object.rebootCount >>> 0;
            if (object.minAppVersion != null)
                message.minAppVersion = object.minAppVersion >>> 0;
            if (object.deviceId != null)
                if (typeof object.deviceId === "string")
                    $util.base64.decode(object.deviceId, message.deviceId = $util.newBuffer($util.base64.length(object.deviceId)), 0);
                else if (object.deviceId.length >= 0)
                    message.deviceId = object.deviceId;
            if (object.pioEnv != null)
                message.pioEnv = String(object.pioEnv);
            switch (object.firmwareEdition) {
            default:
                if (typeof object.firmwareEdition === "number") {
                    message.firmwareEdition = object.firmwareEdition;
                    break;
                }
                break;
            case "VANILLA":
            case 0:
                message.firmwareEdition = 0;
                break;
            case "SMART_CITIZEN":
            case 1:
                message.firmwareEdition = 1;
                break;
            case "OPEN_SAUCE":
            case 16:
                message.firmwareEdition = 16;
                break;
            case "DEFCON":
            case 17:
                message.firmwareEdition = 17;
                break;
            case "BURNING_MAN":
            case 18:
                message.firmwareEdition = 18;
                break;
            case "HAMVENTION":
            case 19:
                message.firmwareEdition = 19;
                break;
            case "DIY_EDITION":
            case 127:
                message.firmwareEdition = 127;
                break;
            }
            if (object.nodedbCount != null)
                message.nodedbCount = object.nodedbCount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a MyNodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {meshtastic.MyNodeInfo} message MyNodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MyNodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.myNodeNum = 0;
                object.rebootCount = 0;
                object.minAppVersion = 0;
                if (options.bytes === String)
                    object.deviceId = "";
                else {
                    object.deviceId = [];
                    if (options.bytes !== Array)
                        object.deviceId = $util.newBuffer(object.deviceId);
                }
                object.pioEnv = "";
                object.firmwareEdition = options.enums === String ? "VANILLA" : 0;
                object.nodedbCount = 0;
            }
            if (message.myNodeNum != null && message.hasOwnProperty("myNodeNum"))
                object.myNodeNum = message.myNodeNum;
            if (message.rebootCount != null && message.hasOwnProperty("rebootCount"))
                object.rebootCount = message.rebootCount;
            if (message.minAppVersion != null && message.hasOwnProperty("minAppVersion"))
                object.minAppVersion = message.minAppVersion;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                object.deviceId = options.bytes === String ? $util.base64.encode(message.deviceId, 0, message.deviceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceId) : message.deviceId;
            if (message.pioEnv != null && message.hasOwnProperty("pioEnv"))
                object.pioEnv = message.pioEnv;
            if (message.firmwareEdition != null && message.hasOwnProperty("firmwareEdition"))
                object.firmwareEdition = options.enums === String ? $root.meshtastic.FirmwareEdition[message.firmwareEdition] === undefined ? message.firmwareEdition : $root.meshtastic.FirmwareEdition[message.firmwareEdition] : message.firmwareEdition;
            if (message.nodedbCount != null && message.hasOwnProperty("nodedbCount"))
                object.nodedbCount = message.nodedbCount;
            return object;
        };

        /**
         * Converts this MyNodeInfo to JSON.
         * @function toJSON
         * @memberof meshtastic.MyNodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MyNodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MyNodeInfo
         * @function getTypeUrl
         * @memberof meshtastic.MyNodeInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MyNodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.MyNodeInfo";
        };

        return MyNodeInfo;
    })();

    meshtastic.LogRecord = (function() {

        /**
         * Properties of a LogRecord.
         * @memberof meshtastic
         * @interface ILogRecord
         * @property {string|null} [message] LogRecord message
         * @property {number|null} [time] LogRecord time
         * @property {string|null} [source] LogRecord source
         * @property {meshtastic.LogRecord.Level|null} [level] LogRecord level
         */

        /**
         * Constructs a new LogRecord.
         * @memberof meshtastic
         * @classdesc Represents a LogRecord.
         * @implements ILogRecord
         * @constructor
         * @param {meshtastic.ILogRecord=} [properties] Properties to set
         */
        function LogRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogRecord message.
         * @member {string} message
         * @memberof meshtastic.LogRecord
         * @instance
         */
        LogRecord.prototype.message = "";

        /**
         * LogRecord time.
         * @member {number} time
         * @memberof meshtastic.LogRecord
         * @instance
         */
        LogRecord.prototype.time = 0;

        /**
         * LogRecord source.
         * @member {string} source
         * @memberof meshtastic.LogRecord
         * @instance
         */
        LogRecord.prototype.source = "";

        /**
         * LogRecord level.
         * @member {meshtastic.LogRecord.Level} level
         * @memberof meshtastic.LogRecord
         * @instance
         */
        LogRecord.prototype.level = 0;

        /**
         * Creates a new LogRecord instance using the specified properties.
         * @function create
         * @memberof meshtastic.LogRecord
         * @static
         * @param {meshtastic.ILogRecord=} [properties] Properties to set
         * @returns {meshtastic.LogRecord} LogRecord instance
         */
        LogRecord.create = function create(properties) {
            return new LogRecord(properties);
        };

        /**
         * Encodes the specified LogRecord message. Does not implicitly {@link meshtastic.LogRecord.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.LogRecord
         * @static
         * @param {meshtastic.ILogRecord} message LogRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.time);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.source);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.level);
            return writer;
        };

        /**
         * Encodes the specified LogRecord message, length delimited. Does not implicitly {@link meshtastic.LogRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.LogRecord
         * @static
         * @param {meshtastic.ILogRecord} message LogRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogRecord message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.LogRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.LogRecord} LogRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogRecord.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.LogRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.message = reader.string();
                        break;
                    }
                case 2: {
                        message.time = reader.fixed32();
                        break;
                    }
                case 3: {
                        message.source = reader.string();
                        break;
                    }
                case 4: {
                        message.level = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.LogRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.LogRecord} LogRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogRecord message.
         * @function verify
         * @memberof meshtastic.LogRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.source != null && message.hasOwnProperty("source"))
                if (!$util.isString(message.source))
                    return "source: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                switch (message.level) {
                default:
                    return "level: enum value expected";
                case 0:
                case 50:
                case 40:
                case 30:
                case 20:
                case 10:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a LogRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.LogRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.LogRecord} LogRecord
         */
        LogRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.LogRecord)
                return object;
            var message = new $root.meshtastic.LogRecord();
            if (object.message != null)
                message.message = String(object.message);
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.source != null)
                message.source = String(object.source);
            switch (object.level) {
            default:
                if (typeof object.level === "number") {
                    message.level = object.level;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.level = 0;
                break;
            case "CRITICAL":
            case 50:
                message.level = 50;
                break;
            case "ERROR":
            case 40:
                message.level = 40;
                break;
            case "WARNING":
            case 30:
                message.level = 30;
                break;
            case "INFO":
            case 20:
                message.level = 20;
                break;
            case "DEBUG":
            case 10:
                message.level = 10;
                break;
            case "TRACE":
            case 5:
                message.level = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LogRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.LogRecord
         * @static
         * @param {meshtastic.LogRecord} message LogRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.message = "";
                object.time = 0;
                object.source = "";
                object.level = options.enums === String ? "UNSET" : 0;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = message.source;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = options.enums === String ? $root.meshtastic.LogRecord.Level[message.level] === undefined ? message.level : $root.meshtastic.LogRecord.Level[message.level] : message.level;
            return object;
        };

        /**
         * Converts this LogRecord to JSON.
         * @function toJSON
         * @memberof meshtastic.LogRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogRecord
         * @function getTypeUrl
         * @memberof meshtastic.LogRecord
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.LogRecord";
        };

        /**
         * Level enum.
         * @name meshtastic.LogRecord.Level
         * @enum {number}
         * @property {number} UNSET=0 UNSET value
         * @property {number} CRITICAL=50 CRITICAL value
         * @property {number} ERROR=40 ERROR value
         * @property {number} WARNING=30 WARNING value
         * @property {number} INFO=20 INFO value
         * @property {number} DEBUG=10 DEBUG value
         * @property {number} TRACE=5 TRACE value
         */
        LogRecord.Level = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNSET"] = 0;
            values[valuesById[50] = "CRITICAL"] = 50;
            values[valuesById[40] = "ERROR"] = 40;
            values[valuesById[30] = "WARNING"] = 30;
            values[valuesById[20] = "INFO"] = 20;
            values[valuesById[10] = "DEBUG"] = 10;
            values[valuesById[5] = "TRACE"] = 5;
            return values;
        })();

        return LogRecord;
    })();

    meshtastic.QueueStatus = (function() {

        /**
         * Properties of a QueueStatus.
         * @memberof meshtastic
         * @interface IQueueStatus
         * @property {number|null} [res] QueueStatus res
         * @property {number|null} [free] QueueStatus free
         * @property {number|null} [maxlen] QueueStatus maxlen
         * @property {number|null} [meshPacketId] QueueStatus meshPacketId
         */

        /**
         * Constructs a new QueueStatus.
         * @memberof meshtastic
         * @classdesc Represents a QueueStatus.
         * @implements IQueueStatus
         * @constructor
         * @param {meshtastic.IQueueStatus=} [properties] Properties to set
         */
        function QueueStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueueStatus res.
         * @member {number} res
         * @memberof meshtastic.QueueStatus
         * @instance
         */
        QueueStatus.prototype.res = 0;

        /**
         * QueueStatus free.
         * @member {number} free
         * @memberof meshtastic.QueueStatus
         * @instance
         */
        QueueStatus.prototype.free = 0;

        /**
         * QueueStatus maxlen.
         * @member {number} maxlen
         * @memberof meshtastic.QueueStatus
         * @instance
         */
        QueueStatus.prototype.maxlen = 0;

        /**
         * QueueStatus meshPacketId.
         * @member {number} meshPacketId
         * @memberof meshtastic.QueueStatus
         * @instance
         */
        QueueStatus.prototype.meshPacketId = 0;

        /**
         * Creates a new QueueStatus instance using the specified properties.
         * @function create
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {meshtastic.IQueueStatus=} [properties] Properties to set
         * @returns {meshtastic.QueueStatus} QueueStatus instance
         */
        QueueStatus.create = function create(properties) {
            return new QueueStatus(properties);
        };

        /**
         * Encodes the specified QueueStatus message. Does not implicitly {@link meshtastic.QueueStatus.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {meshtastic.IQueueStatus} message QueueStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueueStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.res != null && Object.hasOwnProperty.call(message, "res"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.res);
            if (message.free != null && Object.hasOwnProperty.call(message, "free"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.free);
            if (message.maxlen != null && Object.hasOwnProperty.call(message, "maxlen"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxlen);
            if (message.meshPacketId != null && Object.hasOwnProperty.call(message, "meshPacketId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.meshPacketId);
            return writer;
        };

        /**
         * Encodes the specified QueueStatus message, length delimited. Does not implicitly {@link meshtastic.QueueStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {meshtastic.IQueueStatus} message QueueStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueueStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueueStatus message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.QueueStatus} QueueStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueueStatus.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.QueueStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.res = reader.int32();
                        break;
                    }
                case 2: {
                        message.free = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxlen = reader.uint32();
                        break;
                    }
                case 4: {
                        message.meshPacketId = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueueStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.QueueStatus} QueueStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueueStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueueStatus message.
         * @function verify
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueueStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.res != null && message.hasOwnProperty("res"))
                if (!$util.isInteger(message.res))
                    return "res: integer expected";
            if (message.free != null && message.hasOwnProperty("free"))
                if (!$util.isInteger(message.free))
                    return "free: integer expected";
            if (message.maxlen != null && message.hasOwnProperty("maxlen"))
                if (!$util.isInteger(message.maxlen))
                    return "maxlen: integer expected";
            if (message.meshPacketId != null && message.hasOwnProperty("meshPacketId"))
                if (!$util.isInteger(message.meshPacketId))
                    return "meshPacketId: integer expected";
            return null;
        };

        /**
         * Creates a QueueStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.QueueStatus} QueueStatus
         */
        QueueStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.QueueStatus)
                return object;
            var message = new $root.meshtastic.QueueStatus();
            if (object.res != null)
                message.res = object.res | 0;
            if (object.free != null)
                message.free = object.free >>> 0;
            if (object.maxlen != null)
                message.maxlen = object.maxlen >>> 0;
            if (object.meshPacketId != null)
                message.meshPacketId = object.meshPacketId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a QueueStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {meshtastic.QueueStatus} message QueueStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueueStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.res = 0;
                object.free = 0;
                object.maxlen = 0;
                object.meshPacketId = 0;
            }
            if (message.res != null && message.hasOwnProperty("res"))
                object.res = message.res;
            if (message.free != null && message.hasOwnProperty("free"))
                object.free = message.free;
            if (message.maxlen != null && message.hasOwnProperty("maxlen"))
                object.maxlen = message.maxlen;
            if (message.meshPacketId != null && message.hasOwnProperty("meshPacketId"))
                object.meshPacketId = message.meshPacketId;
            return object;
        };

        /**
         * Converts this QueueStatus to JSON.
         * @function toJSON
         * @memberof meshtastic.QueueStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueueStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QueueStatus
         * @function getTypeUrl
         * @memberof meshtastic.QueueStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueueStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.QueueStatus";
        };

        return QueueStatus;
    })();

    meshtastic.FromRadio = (function() {

        /**
         * Properties of a FromRadio.
         * @memberof meshtastic
         * @interface IFromRadio
         * @property {number|null} [id] FromRadio id
         * @property {meshtastic.IMeshPacket|null} [packet] FromRadio packet
         * @property {meshtastic.IMyNodeInfo|null} [myInfo] FromRadio myInfo
         * @property {meshtastic.INodeInfo|null} [nodeInfo] FromRadio nodeInfo
         * @property {meshtastic.IConfig|null} [config] FromRadio config
         * @property {meshtastic.ILogRecord|null} [logRecord] FromRadio logRecord
         * @property {number|null} [configCompleteId] FromRadio configCompleteId
         * @property {boolean|null} [rebooted] FromRadio rebooted
         * @property {meshtastic.IModuleConfig|null} [moduleConfig] FromRadio moduleConfig
         * @property {meshtastic.IChannel|null} [channel] FromRadio channel
         * @property {meshtastic.IQueueStatus|null} [queueStatus] FromRadio queueStatus
         * @property {meshtastic.IXModem|null} [xmodemPacket] FromRadio xmodemPacket
         * @property {meshtastic.IDeviceMetadata|null} [metadata] FromRadio metadata
         * @property {meshtastic.IMqttClientProxyMessage|null} [mqttClientProxyMessage] FromRadio mqttClientProxyMessage
         * @property {meshtastic.IFileInfo|null} [fileInfo] FromRadio fileInfo
         * @property {meshtastic.IClientNotification|null} [clientNotification] FromRadio clientNotification
         * @property {meshtastic.IDeviceUIConfig|null} [deviceuiConfig] FromRadio deviceuiConfig
         */

        /**
         * Constructs a new FromRadio.
         * @memberof meshtastic
         * @classdesc Represents a FromRadio.
         * @implements IFromRadio
         * @constructor
         * @param {meshtastic.IFromRadio=} [properties] Properties to set
         */
        function FromRadio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FromRadio id.
         * @member {number} id
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.id = 0;

        /**
         * FromRadio packet.
         * @member {meshtastic.IMeshPacket|null|undefined} packet
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.packet = null;

        /**
         * FromRadio myInfo.
         * @member {meshtastic.IMyNodeInfo|null|undefined} myInfo
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.myInfo = null;

        /**
         * FromRadio nodeInfo.
         * @member {meshtastic.INodeInfo|null|undefined} nodeInfo
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.nodeInfo = null;

        /**
         * FromRadio config.
         * @member {meshtastic.IConfig|null|undefined} config
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.config = null;

        /**
         * FromRadio logRecord.
         * @member {meshtastic.ILogRecord|null|undefined} logRecord
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.logRecord = null;

        /**
         * FromRadio configCompleteId.
         * @member {number|null|undefined} configCompleteId
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.configCompleteId = null;

        /**
         * FromRadio rebooted.
         * @member {boolean|null|undefined} rebooted
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.rebooted = null;

        /**
         * FromRadio moduleConfig.
         * @member {meshtastic.IModuleConfig|null|undefined} moduleConfig
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.moduleConfig = null;

        /**
         * FromRadio channel.
         * @member {meshtastic.IChannel|null|undefined} channel
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.channel = null;

        /**
         * FromRadio queueStatus.
         * @member {meshtastic.IQueueStatus|null|undefined} queueStatus
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.queueStatus = null;

        /**
         * FromRadio xmodemPacket.
         * @member {meshtastic.IXModem|null|undefined} xmodemPacket
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.xmodemPacket = null;

        /**
         * FromRadio metadata.
         * @member {meshtastic.IDeviceMetadata|null|undefined} metadata
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.metadata = null;

        /**
         * FromRadio mqttClientProxyMessage.
         * @member {meshtastic.IMqttClientProxyMessage|null|undefined} mqttClientProxyMessage
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.mqttClientProxyMessage = null;

        /**
         * FromRadio fileInfo.
         * @member {meshtastic.IFileInfo|null|undefined} fileInfo
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.fileInfo = null;

        /**
         * FromRadio clientNotification.
         * @member {meshtastic.IClientNotification|null|undefined} clientNotification
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.clientNotification = null;

        /**
         * FromRadio deviceuiConfig.
         * @member {meshtastic.IDeviceUIConfig|null|undefined} deviceuiConfig
         * @memberof meshtastic.FromRadio
         * @instance
         */
        FromRadio.prototype.deviceuiConfig = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * FromRadio payloadVariant.
         * @member {"packet"|"myInfo"|"nodeInfo"|"config"|"logRecord"|"configCompleteId"|"rebooted"|"moduleConfig"|"channel"|"queueStatus"|"xmodemPacket"|"metadata"|"mqttClientProxyMessage"|"fileInfo"|"clientNotification"|"deviceuiConfig"|undefined} payloadVariant
         * @memberof meshtastic.FromRadio
         * @instance
         */
        Object.defineProperty(FromRadio.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["packet", "myInfo", "nodeInfo", "config", "logRecord", "configCompleteId", "rebooted", "moduleConfig", "channel", "queueStatus", "xmodemPacket", "metadata", "mqttClientProxyMessage", "fileInfo", "clientNotification", "deviceuiConfig"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FromRadio instance using the specified properties.
         * @function create
         * @memberof meshtastic.FromRadio
         * @static
         * @param {meshtastic.IFromRadio=} [properties] Properties to set
         * @returns {meshtastic.FromRadio} FromRadio instance
         */
        FromRadio.create = function create(properties) {
            return new FromRadio(properties);
        };

        /**
         * Encodes the specified FromRadio message. Does not implicitly {@link meshtastic.FromRadio.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.FromRadio
         * @static
         * @param {meshtastic.IFromRadio} message FromRadio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FromRadio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.packet != null && Object.hasOwnProperty.call(message, "packet"))
                $root.meshtastic.MeshPacket.encode(message.packet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.myInfo != null && Object.hasOwnProperty.call(message, "myInfo"))
                $root.meshtastic.MyNodeInfo.encode(message.myInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.nodeInfo != null && Object.hasOwnProperty.call(message, "nodeInfo"))
                $root.meshtastic.NodeInfo.encode(message.nodeInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                $root.meshtastic.Config.encode(message.config, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.logRecord != null && Object.hasOwnProperty.call(message, "logRecord"))
                $root.meshtastic.LogRecord.encode(message.logRecord, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.configCompleteId != null && Object.hasOwnProperty.call(message, "configCompleteId"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.configCompleteId);
            if (message.rebooted != null && Object.hasOwnProperty.call(message, "rebooted"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.rebooted);
            if (message.moduleConfig != null && Object.hasOwnProperty.call(message, "moduleConfig"))
                $root.meshtastic.ModuleConfig.encode(message.moduleConfig, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                $root.meshtastic.Channel.encode(message.channel, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.queueStatus != null && Object.hasOwnProperty.call(message, "queueStatus"))
                $root.meshtastic.QueueStatus.encode(message.queueStatus, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.xmodemPacket != null && Object.hasOwnProperty.call(message, "xmodemPacket"))
                $root.meshtastic.XModem.encode(message.xmodemPacket, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                $root.meshtastic.DeviceMetadata.encode(message.metadata, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.mqttClientProxyMessage != null && Object.hasOwnProperty.call(message, "mqttClientProxyMessage"))
                $root.meshtastic.MqttClientProxyMessage.encode(message.mqttClientProxyMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.fileInfo != null && Object.hasOwnProperty.call(message, "fileInfo"))
                $root.meshtastic.FileInfo.encode(message.fileInfo, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.clientNotification != null && Object.hasOwnProperty.call(message, "clientNotification"))
                $root.meshtastic.ClientNotification.encode(message.clientNotification, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.deviceuiConfig != null && Object.hasOwnProperty.call(message, "deviceuiConfig"))
                $root.meshtastic.DeviceUIConfig.encode(message.deviceuiConfig, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FromRadio message, length delimited. Does not implicitly {@link meshtastic.FromRadio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.FromRadio
         * @static
         * @param {meshtastic.IFromRadio} message FromRadio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FromRadio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FromRadio message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.FromRadio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.FromRadio} FromRadio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FromRadio.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.FromRadio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.packet = $root.meshtastic.MeshPacket.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.myInfo = $root.meshtastic.MyNodeInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.nodeInfo = $root.meshtastic.NodeInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.config = $root.meshtastic.Config.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.logRecord = $root.meshtastic.LogRecord.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.configCompleteId = reader.uint32();
                        break;
                    }
                case 8: {
                        message.rebooted = reader.bool();
                        break;
                    }
                case 9: {
                        message.moduleConfig = $root.meshtastic.ModuleConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.channel = $root.meshtastic.Channel.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.queueStatus = $root.meshtastic.QueueStatus.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.xmodemPacket = $root.meshtastic.XModem.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.metadata = $root.meshtastic.DeviceMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.fileInfo = $root.meshtastic.FileInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.clientNotification = $root.meshtastic.ClientNotification.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.deviceuiConfig = $root.meshtastic.DeviceUIConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FromRadio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.FromRadio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.FromRadio} FromRadio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FromRadio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FromRadio message.
         * @function verify
         * @memberof meshtastic.FromRadio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FromRadio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.packet != null && message.hasOwnProperty("packet")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.MeshPacket.verify(message.packet);
                    if (error)
                        return "packet." + error;
                }
            }
            if (message.myInfo != null && message.hasOwnProperty("myInfo")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.MyNodeInfo.verify(message.myInfo);
                    if (error)
                        return "myInfo." + error;
                }
            }
            if (message.nodeInfo != null && message.hasOwnProperty("nodeInfo")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.NodeInfo.verify(message.nodeInfo);
                    if (error)
                        return "nodeInfo." + error;
                }
            }
            if (message.config != null && message.hasOwnProperty("config")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Config.verify(message.config);
                    if (error)
                        return "config." + error;
                }
            }
            if (message.logRecord != null && message.hasOwnProperty("logRecord")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.LogRecord.verify(message.logRecord);
                    if (error)
                        return "logRecord." + error;
                }
            }
            if (message.configCompleteId != null && message.hasOwnProperty("configCompleteId")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (!$util.isInteger(message.configCompleteId))
                    return "configCompleteId: integer expected";
            }
            if (message.rebooted != null && message.hasOwnProperty("rebooted")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (typeof message.rebooted !== "boolean")
                    return "rebooted: boolean expected";
            }
            if (message.moduleConfig != null && message.hasOwnProperty("moduleConfig")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.verify(message.moduleConfig);
                    if (error)
                        return "moduleConfig." + error;
                }
            }
            if (message.channel != null && message.hasOwnProperty("channel")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Channel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
            }
            if (message.queueStatus != null && message.hasOwnProperty("queueStatus")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.QueueStatus.verify(message.queueStatus);
                    if (error)
                        return "queueStatus." + error;
                }
            }
            if (message.xmodemPacket != null && message.hasOwnProperty("xmodemPacket")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.XModem.verify(message.xmodemPacket);
                    if (error)
                        return "xmodemPacket." + error;
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.DeviceMetadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
            }
            if (message.mqttClientProxyMessage != null && message.hasOwnProperty("mqttClientProxyMessage")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.MqttClientProxyMessage.verify(message.mqttClientProxyMessage);
                    if (error)
                        return "mqttClientProxyMessage." + error;
                }
            }
            if (message.fileInfo != null && message.hasOwnProperty("fileInfo")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.FileInfo.verify(message.fileInfo);
                    if (error)
                        return "fileInfo." + error;
                }
            }
            if (message.clientNotification != null && message.hasOwnProperty("clientNotification")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ClientNotification.verify(message.clientNotification);
                    if (error)
                        return "clientNotification." + error;
                }
            }
            if (message.deviceuiConfig != null && message.hasOwnProperty("deviceuiConfig")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.DeviceUIConfig.verify(message.deviceuiConfig);
                    if (error)
                        return "deviceuiConfig." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FromRadio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.FromRadio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.FromRadio} FromRadio
         */
        FromRadio.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.FromRadio)
                return object;
            var message = new $root.meshtastic.FromRadio();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.packet != null) {
                if (typeof object.packet !== "object")
                    throw TypeError(".meshtastic.FromRadio.packet: object expected");
                message.packet = $root.meshtastic.MeshPacket.fromObject(object.packet);
            }
            if (object.myInfo != null) {
                if (typeof object.myInfo !== "object")
                    throw TypeError(".meshtastic.FromRadio.myInfo: object expected");
                message.myInfo = $root.meshtastic.MyNodeInfo.fromObject(object.myInfo);
            }
            if (object.nodeInfo != null) {
                if (typeof object.nodeInfo !== "object")
                    throw TypeError(".meshtastic.FromRadio.nodeInfo: object expected");
                message.nodeInfo = $root.meshtastic.NodeInfo.fromObject(object.nodeInfo);
            }
            if (object.config != null) {
                if (typeof object.config !== "object")
                    throw TypeError(".meshtastic.FromRadio.config: object expected");
                message.config = $root.meshtastic.Config.fromObject(object.config);
            }
            if (object.logRecord != null) {
                if (typeof object.logRecord !== "object")
                    throw TypeError(".meshtastic.FromRadio.logRecord: object expected");
                message.logRecord = $root.meshtastic.LogRecord.fromObject(object.logRecord);
            }
            if (object.configCompleteId != null)
                message.configCompleteId = object.configCompleteId >>> 0;
            if (object.rebooted != null)
                message.rebooted = Boolean(object.rebooted);
            if (object.moduleConfig != null) {
                if (typeof object.moduleConfig !== "object")
                    throw TypeError(".meshtastic.FromRadio.moduleConfig: object expected");
                message.moduleConfig = $root.meshtastic.ModuleConfig.fromObject(object.moduleConfig);
            }
            if (object.channel != null) {
                if (typeof object.channel !== "object")
                    throw TypeError(".meshtastic.FromRadio.channel: object expected");
                message.channel = $root.meshtastic.Channel.fromObject(object.channel);
            }
            if (object.queueStatus != null) {
                if (typeof object.queueStatus !== "object")
                    throw TypeError(".meshtastic.FromRadio.queueStatus: object expected");
                message.queueStatus = $root.meshtastic.QueueStatus.fromObject(object.queueStatus);
            }
            if (object.xmodemPacket != null) {
                if (typeof object.xmodemPacket !== "object")
                    throw TypeError(".meshtastic.FromRadio.xmodemPacket: object expected");
                message.xmodemPacket = $root.meshtastic.XModem.fromObject(object.xmodemPacket);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".meshtastic.FromRadio.metadata: object expected");
                message.metadata = $root.meshtastic.DeviceMetadata.fromObject(object.metadata);
            }
            if (object.mqttClientProxyMessage != null) {
                if (typeof object.mqttClientProxyMessage !== "object")
                    throw TypeError(".meshtastic.FromRadio.mqttClientProxyMessage: object expected");
                message.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.fromObject(object.mqttClientProxyMessage);
            }
            if (object.fileInfo != null) {
                if (typeof object.fileInfo !== "object")
                    throw TypeError(".meshtastic.FromRadio.fileInfo: object expected");
                message.fileInfo = $root.meshtastic.FileInfo.fromObject(object.fileInfo);
            }
            if (object.clientNotification != null) {
                if (typeof object.clientNotification !== "object")
                    throw TypeError(".meshtastic.FromRadio.clientNotification: object expected");
                message.clientNotification = $root.meshtastic.ClientNotification.fromObject(object.clientNotification);
            }
            if (object.deviceuiConfig != null) {
                if (typeof object.deviceuiConfig !== "object")
                    throw TypeError(".meshtastic.FromRadio.deviceuiConfig: object expected");
                message.deviceuiConfig = $root.meshtastic.DeviceUIConfig.fromObject(object.deviceuiConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a FromRadio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.FromRadio
         * @static
         * @param {meshtastic.FromRadio} message FromRadio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FromRadio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.packet != null && message.hasOwnProperty("packet")) {
                object.packet = $root.meshtastic.MeshPacket.toObject(message.packet, options);
                if (options.oneofs)
                    object.payloadVariant = "packet";
            }
            if (message.myInfo != null && message.hasOwnProperty("myInfo")) {
                object.myInfo = $root.meshtastic.MyNodeInfo.toObject(message.myInfo, options);
                if (options.oneofs)
                    object.payloadVariant = "myInfo";
            }
            if (message.nodeInfo != null && message.hasOwnProperty("nodeInfo")) {
                object.nodeInfo = $root.meshtastic.NodeInfo.toObject(message.nodeInfo, options);
                if (options.oneofs)
                    object.payloadVariant = "nodeInfo";
            }
            if (message.config != null && message.hasOwnProperty("config")) {
                object.config = $root.meshtastic.Config.toObject(message.config, options);
                if (options.oneofs)
                    object.payloadVariant = "config";
            }
            if (message.logRecord != null && message.hasOwnProperty("logRecord")) {
                object.logRecord = $root.meshtastic.LogRecord.toObject(message.logRecord, options);
                if (options.oneofs)
                    object.payloadVariant = "logRecord";
            }
            if (message.configCompleteId != null && message.hasOwnProperty("configCompleteId")) {
                object.configCompleteId = message.configCompleteId;
                if (options.oneofs)
                    object.payloadVariant = "configCompleteId";
            }
            if (message.rebooted != null && message.hasOwnProperty("rebooted")) {
                object.rebooted = message.rebooted;
                if (options.oneofs)
                    object.payloadVariant = "rebooted";
            }
            if (message.moduleConfig != null && message.hasOwnProperty("moduleConfig")) {
                object.moduleConfig = $root.meshtastic.ModuleConfig.toObject(message.moduleConfig, options);
                if (options.oneofs)
                    object.payloadVariant = "moduleConfig";
            }
            if (message.channel != null && message.hasOwnProperty("channel")) {
                object.channel = $root.meshtastic.Channel.toObject(message.channel, options);
                if (options.oneofs)
                    object.payloadVariant = "channel";
            }
            if (message.queueStatus != null && message.hasOwnProperty("queueStatus")) {
                object.queueStatus = $root.meshtastic.QueueStatus.toObject(message.queueStatus, options);
                if (options.oneofs)
                    object.payloadVariant = "queueStatus";
            }
            if (message.xmodemPacket != null && message.hasOwnProperty("xmodemPacket")) {
                object.xmodemPacket = $root.meshtastic.XModem.toObject(message.xmodemPacket, options);
                if (options.oneofs)
                    object.payloadVariant = "xmodemPacket";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                object.metadata = $root.meshtastic.DeviceMetadata.toObject(message.metadata, options);
                if (options.oneofs)
                    object.payloadVariant = "metadata";
            }
            if (message.mqttClientProxyMessage != null && message.hasOwnProperty("mqttClientProxyMessage")) {
                object.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.toObject(message.mqttClientProxyMessage, options);
                if (options.oneofs)
                    object.payloadVariant = "mqttClientProxyMessage";
            }
            if (message.fileInfo != null && message.hasOwnProperty("fileInfo")) {
                object.fileInfo = $root.meshtastic.FileInfo.toObject(message.fileInfo, options);
                if (options.oneofs)
                    object.payloadVariant = "fileInfo";
            }
            if (message.clientNotification != null && message.hasOwnProperty("clientNotification")) {
                object.clientNotification = $root.meshtastic.ClientNotification.toObject(message.clientNotification, options);
                if (options.oneofs)
                    object.payloadVariant = "clientNotification";
            }
            if (message.deviceuiConfig != null && message.hasOwnProperty("deviceuiConfig")) {
                object.deviceuiConfig = $root.meshtastic.DeviceUIConfig.toObject(message.deviceuiConfig, options);
                if (options.oneofs)
                    object.payloadVariant = "deviceuiConfig";
            }
            return object;
        };

        /**
         * Converts this FromRadio to JSON.
         * @function toJSON
         * @memberof meshtastic.FromRadio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FromRadio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FromRadio
         * @function getTypeUrl
         * @memberof meshtastic.FromRadio
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FromRadio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.FromRadio";
        };

        return FromRadio;
    })();

    meshtastic.ClientNotification = (function() {

        /**
         * Properties of a ClientNotification.
         * @memberof meshtastic
         * @interface IClientNotification
         * @property {number|null} [replyId] ClientNotification replyId
         * @property {number|null} [time] ClientNotification time
         * @property {meshtastic.LogRecord.Level|null} [level] ClientNotification level
         * @property {string|null} [message] ClientNotification message
         * @property {meshtastic.IKeyVerificationNumberInform|null} [keyVerificationNumberInform] ClientNotification keyVerificationNumberInform
         * @property {meshtastic.IKeyVerificationNumberRequest|null} [keyVerificationNumberRequest] ClientNotification keyVerificationNumberRequest
         * @property {meshtastic.IKeyVerificationFinal|null} [keyVerificationFinal] ClientNotification keyVerificationFinal
         * @property {meshtastic.IDuplicatedPublicKey|null} [duplicatedPublicKey] ClientNotification duplicatedPublicKey
         * @property {meshtastic.ILowEntropyKey|null} [lowEntropyKey] ClientNotification lowEntropyKey
         */

        /**
         * Constructs a new ClientNotification.
         * @memberof meshtastic
         * @classdesc Represents a ClientNotification.
         * @implements IClientNotification
         * @constructor
         * @param {meshtastic.IClientNotification=} [properties] Properties to set
         */
        function ClientNotification(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientNotification replyId.
         * @member {number|null|undefined} replyId
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.replyId = null;

        /**
         * ClientNotification time.
         * @member {number} time
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.time = 0;

        /**
         * ClientNotification level.
         * @member {meshtastic.LogRecord.Level} level
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.level = 0;

        /**
         * ClientNotification message.
         * @member {string} message
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.message = "";

        /**
         * ClientNotification keyVerificationNumberInform.
         * @member {meshtastic.IKeyVerificationNumberInform|null|undefined} keyVerificationNumberInform
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.keyVerificationNumberInform = null;

        /**
         * ClientNotification keyVerificationNumberRequest.
         * @member {meshtastic.IKeyVerificationNumberRequest|null|undefined} keyVerificationNumberRequest
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.keyVerificationNumberRequest = null;

        /**
         * ClientNotification keyVerificationFinal.
         * @member {meshtastic.IKeyVerificationFinal|null|undefined} keyVerificationFinal
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.keyVerificationFinal = null;

        /**
         * ClientNotification duplicatedPublicKey.
         * @member {meshtastic.IDuplicatedPublicKey|null|undefined} duplicatedPublicKey
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.duplicatedPublicKey = null;

        /**
         * ClientNotification lowEntropyKey.
         * @member {meshtastic.ILowEntropyKey|null|undefined} lowEntropyKey
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        ClientNotification.prototype.lowEntropyKey = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ClientNotification _replyId.
         * @member {"replyId"|undefined} _replyId
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        Object.defineProperty(ClientNotification.prototype, "_replyId", {
            get: $util.oneOfGetter($oneOfFields = ["replyId"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientNotification payloadVariant.
         * @member {"keyVerificationNumberInform"|"keyVerificationNumberRequest"|"keyVerificationFinal"|"duplicatedPublicKey"|"lowEntropyKey"|undefined} payloadVariant
         * @memberof meshtastic.ClientNotification
         * @instance
         */
        Object.defineProperty(ClientNotification.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["keyVerificationNumberInform", "keyVerificationNumberRequest", "keyVerificationFinal", "duplicatedPublicKey", "lowEntropyKey"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientNotification instance using the specified properties.
         * @function create
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {meshtastic.IClientNotification=} [properties] Properties to set
         * @returns {meshtastic.ClientNotification} ClientNotification instance
         */
        ClientNotification.create = function create(properties) {
            return new ClientNotification(properties);
        };

        /**
         * Encodes the specified ClientNotification message. Does not implicitly {@link meshtastic.ClientNotification.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {meshtastic.IClientNotification} message ClientNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNotification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.replyId != null && Object.hasOwnProperty.call(message, "replyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.replyId);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.time);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
            if (message.keyVerificationNumberInform != null && Object.hasOwnProperty.call(message, "keyVerificationNumberInform"))
                $root.meshtastic.KeyVerificationNumberInform.encode(message.keyVerificationNumberInform, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.keyVerificationNumberRequest != null && Object.hasOwnProperty.call(message, "keyVerificationNumberRequest"))
                $root.meshtastic.KeyVerificationNumberRequest.encode(message.keyVerificationNumberRequest, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.keyVerificationFinal != null && Object.hasOwnProperty.call(message, "keyVerificationFinal"))
                $root.meshtastic.KeyVerificationFinal.encode(message.keyVerificationFinal, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.duplicatedPublicKey != null && Object.hasOwnProperty.call(message, "duplicatedPublicKey"))
                $root.meshtastic.DuplicatedPublicKey.encode(message.duplicatedPublicKey, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.lowEntropyKey != null && Object.hasOwnProperty.call(message, "lowEntropyKey"))
                $root.meshtastic.LowEntropyKey.encode(message.lowEntropyKey, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientNotification message, length delimited. Does not implicitly {@link meshtastic.ClientNotification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {meshtastic.IClientNotification} message ClientNotification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNotification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientNotification message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ClientNotification} ClientNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNotification.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ClientNotification();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.replyId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.time = reader.fixed32();
                        break;
                    }
                case 3: {
                        message.level = reader.int32();
                        break;
                    }
                case 4: {
                        message.message = reader.string();
                        break;
                    }
                case 11: {
                        message.keyVerificationNumberInform = $root.meshtastic.KeyVerificationNumberInform.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.keyVerificationNumberRequest = $root.meshtastic.KeyVerificationNumberRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.keyVerificationFinal = $root.meshtastic.KeyVerificationFinal.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.duplicatedPublicKey = $root.meshtastic.DuplicatedPublicKey.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.lowEntropyKey = $root.meshtastic.LowEntropyKey.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientNotification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ClientNotification} ClientNotification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNotification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientNotification message.
         * @function verify
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientNotification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.replyId != null && message.hasOwnProperty("replyId")) {
                properties._replyId = 1;
                if (!$util.isInteger(message.replyId))
                    return "replyId: integer expected";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                switch (message.level) {
                default:
                    return "level: enum value expected";
                case 0:
                case 50:
                case 40:
                case 30:
                case 20:
                case 10:
                case 5:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.keyVerificationNumberInform != null && message.hasOwnProperty("keyVerificationNumberInform")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.KeyVerificationNumberInform.verify(message.keyVerificationNumberInform);
                    if (error)
                        return "keyVerificationNumberInform." + error;
                }
            }
            if (message.keyVerificationNumberRequest != null && message.hasOwnProperty("keyVerificationNumberRequest")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.KeyVerificationNumberRequest.verify(message.keyVerificationNumberRequest);
                    if (error)
                        return "keyVerificationNumberRequest." + error;
                }
            }
            if (message.keyVerificationFinal != null && message.hasOwnProperty("keyVerificationFinal")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.KeyVerificationFinal.verify(message.keyVerificationFinal);
                    if (error)
                        return "keyVerificationFinal." + error;
                }
            }
            if (message.duplicatedPublicKey != null && message.hasOwnProperty("duplicatedPublicKey")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.DuplicatedPublicKey.verify(message.duplicatedPublicKey);
                    if (error)
                        return "duplicatedPublicKey." + error;
                }
            }
            if (message.lowEntropyKey != null && message.hasOwnProperty("lowEntropyKey")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.LowEntropyKey.verify(message.lowEntropyKey);
                    if (error)
                        return "lowEntropyKey." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientNotification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ClientNotification} ClientNotification
         */
        ClientNotification.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ClientNotification)
                return object;
            var message = new $root.meshtastic.ClientNotification();
            if (object.replyId != null)
                message.replyId = object.replyId >>> 0;
            if (object.time != null)
                message.time = object.time >>> 0;
            switch (object.level) {
            default:
                if (typeof object.level === "number") {
                    message.level = object.level;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.level = 0;
                break;
            case "CRITICAL":
            case 50:
                message.level = 50;
                break;
            case "ERROR":
            case 40:
                message.level = 40;
                break;
            case "WARNING":
            case 30:
                message.level = 30;
                break;
            case "INFO":
            case 20:
                message.level = 20;
                break;
            case "DEBUG":
            case 10:
                message.level = 10;
                break;
            case "TRACE":
            case 5:
                message.level = 5;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.keyVerificationNumberInform != null) {
                if (typeof object.keyVerificationNumberInform !== "object")
                    throw TypeError(".meshtastic.ClientNotification.keyVerificationNumberInform: object expected");
                message.keyVerificationNumberInform = $root.meshtastic.KeyVerificationNumberInform.fromObject(object.keyVerificationNumberInform);
            }
            if (object.keyVerificationNumberRequest != null) {
                if (typeof object.keyVerificationNumberRequest !== "object")
                    throw TypeError(".meshtastic.ClientNotification.keyVerificationNumberRequest: object expected");
                message.keyVerificationNumberRequest = $root.meshtastic.KeyVerificationNumberRequest.fromObject(object.keyVerificationNumberRequest);
            }
            if (object.keyVerificationFinal != null) {
                if (typeof object.keyVerificationFinal !== "object")
                    throw TypeError(".meshtastic.ClientNotification.keyVerificationFinal: object expected");
                message.keyVerificationFinal = $root.meshtastic.KeyVerificationFinal.fromObject(object.keyVerificationFinal);
            }
            if (object.duplicatedPublicKey != null) {
                if (typeof object.duplicatedPublicKey !== "object")
                    throw TypeError(".meshtastic.ClientNotification.duplicatedPublicKey: object expected");
                message.duplicatedPublicKey = $root.meshtastic.DuplicatedPublicKey.fromObject(object.duplicatedPublicKey);
            }
            if (object.lowEntropyKey != null) {
                if (typeof object.lowEntropyKey !== "object")
                    throw TypeError(".meshtastic.ClientNotification.lowEntropyKey: object expected");
                message.lowEntropyKey = $root.meshtastic.LowEntropyKey.fromObject(object.lowEntropyKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientNotification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {meshtastic.ClientNotification} message ClientNotification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientNotification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = 0;
                object.level = options.enums === String ? "UNSET" : 0;
                object.message = "";
            }
            if (message.replyId != null && message.hasOwnProperty("replyId")) {
                object.replyId = message.replyId;
                if (options.oneofs)
                    object._replyId = "replyId";
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = options.enums === String ? $root.meshtastic.LogRecord.Level[message.level] === undefined ? message.level : $root.meshtastic.LogRecord.Level[message.level] : message.level;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.keyVerificationNumberInform != null && message.hasOwnProperty("keyVerificationNumberInform")) {
                object.keyVerificationNumberInform = $root.meshtastic.KeyVerificationNumberInform.toObject(message.keyVerificationNumberInform, options);
                if (options.oneofs)
                    object.payloadVariant = "keyVerificationNumberInform";
            }
            if (message.keyVerificationNumberRequest != null && message.hasOwnProperty("keyVerificationNumberRequest")) {
                object.keyVerificationNumberRequest = $root.meshtastic.KeyVerificationNumberRequest.toObject(message.keyVerificationNumberRequest, options);
                if (options.oneofs)
                    object.payloadVariant = "keyVerificationNumberRequest";
            }
            if (message.keyVerificationFinal != null && message.hasOwnProperty("keyVerificationFinal")) {
                object.keyVerificationFinal = $root.meshtastic.KeyVerificationFinal.toObject(message.keyVerificationFinal, options);
                if (options.oneofs)
                    object.payloadVariant = "keyVerificationFinal";
            }
            if (message.duplicatedPublicKey != null && message.hasOwnProperty("duplicatedPublicKey")) {
                object.duplicatedPublicKey = $root.meshtastic.DuplicatedPublicKey.toObject(message.duplicatedPublicKey, options);
                if (options.oneofs)
                    object.payloadVariant = "duplicatedPublicKey";
            }
            if (message.lowEntropyKey != null && message.hasOwnProperty("lowEntropyKey")) {
                object.lowEntropyKey = $root.meshtastic.LowEntropyKey.toObject(message.lowEntropyKey, options);
                if (options.oneofs)
                    object.payloadVariant = "lowEntropyKey";
            }
            return object;
        };

        /**
         * Converts this ClientNotification to JSON.
         * @function toJSON
         * @memberof meshtastic.ClientNotification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientNotification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientNotification
         * @function getTypeUrl
         * @memberof meshtastic.ClientNotification
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientNotification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ClientNotification";
        };

        return ClientNotification;
    })();

    meshtastic.KeyVerificationNumberInform = (function() {

        /**
         * Properties of a KeyVerificationNumberInform.
         * @memberof meshtastic
         * @interface IKeyVerificationNumberInform
         * @property {number|Long|null} [nonce] KeyVerificationNumberInform nonce
         * @property {string|null} [remoteLongname] KeyVerificationNumberInform remoteLongname
         * @property {number|null} [securityNumber] KeyVerificationNumberInform securityNumber
         */

        /**
         * Constructs a new KeyVerificationNumberInform.
         * @memberof meshtastic
         * @classdesc Represents a KeyVerificationNumberInform.
         * @implements IKeyVerificationNumberInform
         * @constructor
         * @param {meshtastic.IKeyVerificationNumberInform=} [properties] Properties to set
         */
        function KeyVerificationNumberInform(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyVerificationNumberInform nonce.
         * @member {number|Long} nonce
         * @memberof meshtastic.KeyVerificationNumberInform
         * @instance
         */
        KeyVerificationNumberInform.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * KeyVerificationNumberInform remoteLongname.
         * @member {string} remoteLongname
         * @memberof meshtastic.KeyVerificationNumberInform
         * @instance
         */
        KeyVerificationNumberInform.prototype.remoteLongname = "";

        /**
         * KeyVerificationNumberInform securityNumber.
         * @member {number} securityNumber
         * @memberof meshtastic.KeyVerificationNumberInform
         * @instance
         */
        KeyVerificationNumberInform.prototype.securityNumber = 0;

        /**
         * Creates a new KeyVerificationNumberInform instance using the specified properties.
         * @function create
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {meshtastic.IKeyVerificationNumberInform=} [properties] Properties to set
         * @returns {meshtastic.KeyVerificationNumberInform} KeyVerificationNumberInform instance
         */
        KeyVerificationNumberInform.create = function create(properties) {
            return new KeyVerificationNumberInform(properties);
        };

        /**
         * Encodes the specified KeyVerificationNumberInform message. Does not implicitly {@link meshtastic.KeyVerificationNumberInform.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {meshtastic.IKeyVerificationNumberInform} message KeyVerificationNumberInform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationNumberInform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
            if (message.remoteLongname != null && Object.hasOwnProperty.call(message, "remoteLongname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteLongname);
            if (message.securityNumber != null && Object.hasOwnProperty.call(message, "securityNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.securityNumber);
            return writer;
        };

        /**
         * Encodes the specified KeyVerificationNumberInform message, length delimited. Does not implicitly {@link meshtastic.KeyVerificationNumberInform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {meshtastic.IKeyVerificationNumberInform} message KeyVerificationNumberInform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationNumberInform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyVerificationNumberInform message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.KeyVerificationNumberInform} KeyVerificationNumberInform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationNumberInform.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.KeyVerificationNumberInform();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nonce = reader.uint64();
                        break;
                    }
                case 2: {
                        message.remoteLongname = reader.string();
                        break;
                    }
                case 3: {
                        message.securityNumber = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyVerificationNumberInform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.KeyVerificationNumberInform} KeyVerificationNumberInform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationNumberInform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyVerificationNumberInform message.
         * @function verify
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyVerificationNumberInform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                    return "nonce: integer|Long expected";
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                if (!$util.isString(message.remoteLongname))
                    return "remoteLongname: string expected";
            if (message.securityNumber != null && message.hasOwnProperty("securityNumber"))
                if (!$util.isInteger(message.securityNumber))
                    return "securityNumber: integer expected";
            return null;
        };

        /**
         * Creates a KeyVerificationNumberInform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.KeyVerificationNumberInform} KeyVerificationNumberInform
         */
        KeyVerificationNumberInform.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.KeyVerificationNumberInform)
                return object;
            var message = new $root.meshtastic.KeyVerificationNumberInform();
            if (object.nonce != null)
                if ($util.Long)
                    (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                else if (typeof object.nonce === "string")
                    message.nonce = parseInt(object.nonce, 10);
                else if (typeof object.nonce === "number")
                    message.nonce = object.nonce;
                else if (typeof object.nonce === "object")
                    message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
            if (object.remoteLongname != null)
                message.remoteLongname = String(object.remoteLongname);
            if (object.securityNumber != null)
                message.securityNumber = object.securityNumber >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a KeyVerificationNumberInform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {meshtastic.KeyVerificationNumberInform} message KeyVerificationNumberInform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyVerificationNumberInform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nonce = options.longs === String ? "0" : 0;
                object.remoteLongname = "";
                object.securityNumber = 0;
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (typeof message.nonce === "number")
                    object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                else
                    object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                object.remoteLongname = message.remoteLongname;
            if (message.securityNumber != null && message.hasOwnProperty("securityNumber"))
                object.securityNumber = message.securityNumber;
            return object;
        };

        /**
         * Converts this KeyVerificationNumberInform to JSON.
         * @function toJSON
         * @memberof meshtastic.KeyVerificationNumberInform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyVerificationNumberInform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KeyVerificationNumberInform
         * @function getTypeUrl
         * @memberof meshtastic.KeyVerificationNumberInform
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyVerificationNumberInform.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.KeyVerificationNumberInform";
        };

        return KeyVerificationNumberInform;
    })();

    meshtastic.KeyVerificationNumberRequest = (function() {

        /**
         * Properties of a KeyVerificationNumberRequest.
         * @memberof meshtastic
         * @interface IKeyVerificationNumberRequest
         * @property {number|Long|null} [nonce] KeyVerificationNumberRequest nonce
         * @property {string|null} [remoteLongname] KeyVerificationNumberRequest remoteLongname
         */

        /**
         * Constructs a new KeyVerificationNumberRequest.
         * @memberof meshtastic
         * @classdesc Represents a KeyVerificationNumberRequest.
         * @implements IKeyVerificationNumberRequest
         * @constructor
         * @param {meshtastic.IKeyVerificationNumberRequest=} [properties] Properties to set
         */
        function KeyVerificationNumberRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyVerificationNumberRequest nonce.
         * @member {number|Long} nonce
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @instance
         */
        KeyVerificationNumberRequest.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * KeyVerificationNumberRequest remoteLongname.
         * @member {string} remoteLongname
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @instance
         */
        KeyVerificationNumberRequest.prototype.remoteLongname = "";

        /**
         * Creates a new KeyVerificationNumberRequest instance using the specified properties.
         * @function create
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {meshtastic.IKeyVerificationNumberRequest=} [properties] Properties to set
         * @returns {meshtastic.KeyVerificationNumberRequest} KeyVerificationNumberRequest instance
         */
        KeyVerificationNumberRequest.create = function create(properties) {
            return new KeyVerificationNumberRequest(properties);
        };

        /**
         * Encodes the specified KeyVerificationNumberRequest message. Does not implicitly {@link meshtastic.KeyVerificationNumberRequest.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {meshtastic.IKeyVerificationNumberRequest} message KeyVerificationNumberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationNumberRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
            if (message.remoteLongname != null && Object.hasOwnProperty.call(message, "remoteLongname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteLongname);
            return writer;
        };

        /**
         * Encodes the specified KeyVerificationNumberRequest message, length delimited. Does not implicitly {@link meshtastic.KeyVerificationNumberRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {meshtastic.IKeyVerificationNumberRequest} message KeyVerificationNumberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationNumberRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyVerificationNumberRequest message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.KeyVerificationNumberRequest} KeyVerificationNumberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationNumberRequest.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.KeyVerificationNumberRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nonce = reader.uint64();
                        break;
                    }
                case 2: {
                        message.remoteLongname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyVerificationNumberRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.KeyVerificationNumberRequest} KeyVerificationNumberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationNumberRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyVerificationNumberRequest message.
         * @function verify
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyVerificationNumberRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                    return "nonce: integer|Long expected";
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                if (!$util.isString(message.remoteLongname))
                    return "remoteLongname: string expected";
            return null;
        };

        /**
         * Creates a KeyVerificationNumberRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.KeyVerificationNumberRequest} KeyVerificationNumberRequest
         */
        KeyVerificationNumberRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.KeyVerificationNumberRequest)
                return object;
            var message = new $root.meshtastic.KeyVerificationNumberRequest();
            if (object.nonce != null)
                if ($util.Long)
                    (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                else if (typeof object.nonce === "string")
                    message.nonce = parseInt(object.nonce, 10);
                else if (typeof object.nonce === "number")
                    message.nonce = object.nonce;
                else if (typeof object.nonce === "object")
                    message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
            if (object.remoteLongname != null)
                message.remoteLongname = String(object.remoteLongname);
            return message;
        };

        /**
         * Creates a plain object from a KeyVerificationNumberRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {meshtastic.KeyVerificationNumberRequest} message KeyVerificationNumberRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyVerificationNumberRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nonce = options.longs === String ? "0" : 0;
                object.remoteLongname = "";
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (typeof message.nonce === "number")
                    object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                else
                    object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                object.remoteLongname = message.remoteLongname;
            return object;
        };

        /**
         * Converts this KeyVerificationNumberRequest to JSON.
         * @function toJSON
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyVerificationNumberRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KeyVerificationNumberRequest
         * @function getTypeUrl
         * @memberof meshtastic.KeyVerificationNumberRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyVerificationNumberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.KeyVerificationNumberRequest";
        };

        return KeyVerificationNumberRequest;
    })();

    meshtastic.KeyVerificationFinal = (function() {

        /**
         * Properties of a KeyVerificationFinal.
         * @memberof meshtastic
         * @interface IKeyVerificationFinal
         * @property {number|Long|null} [nonce] KeyVerificationFinal nonce
         * @property {string|null} [remoteLongname] KeyVerificationFinal remoteLongname
         * @property {boolean|null} [isSender] KeyVerificationFinal isSender
         * @property {string|null} [verificationCharacters] KeyVerificationFinal verificationCharacters
         */

        /**
         * Constructs a new KeyVerificationFinal.
         * @memberof meshtastic
         * @classdesc Represents a KeyVerificationFinal.
         * @implements IKeyVerificationFinal
         * @constructor
         * @param {meshtastic.IKeyVerificationFinal=} [properties] Properties to set
         */
        function KeyVerificationFinal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyVerificationFinal nonce.
         * @member {number|Long} nonce
         * @memberof meshtastic.KeyVerificationFinal
         * @instance
         */
        KeyVerificationFinal.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * KeyVerificationFinal remoteLongname.
         * @member {string} remoteLongname
         * @memberof meshtastic.KeyVerificationFinal
         * @instance
         */
        KeyVerificationFinal.prototype.remoteLongname = "";

        /**
         * KeyVerificationFinal isSender.
         * @member {boolean} isSender
         * @memberof meshtastic.KeyVerificationFinal
         * @instance
         */
        KeyVerificationFinal.prototype.isSender = false;

        /**
         * KeyVerificationFinal verificationCharacters.
         * @member {string} verificationCharacters
         * @memberof meshtastic.KeyVerificationFinal
         * @instance
         */
        KeyVerificationFinal.prototype.verificationCharacters = "";

        /**
         * Creates a new KeyVerificationFinal instance using the specified properties.
         * @function create
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {meshtastic.IKeyVerificationFinal=} [properties] Properties to set
         * @returns {meshtastic.KeyVerificationFinal} KeyVerificationFinal instance
         */
        KeyVerificationFinal.create = function create(properties) {
            return new KeyVerificationFinal(properties);
        };

        /**
         * Encodes the specified KeyVerificationFinal message. Does not implicitly {@link meshtastic.KeyVerificationFinal.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {meshtastic.IKeyVerificationFinal} message KeyVerificationFinal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationFinal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
            if (message.remoteLongname != null && Object.hasOwnProperty.call(message, "remoteLongname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remoteLongname);
            if (message.isSender != null && Object.hasOwnProperty.call(message, "isSender"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSender);
            if (message.verificationCharacters != null && Object.hasOwnProperty.call(message, "verificationCharacters"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.verificationCharacters);
            return writer;
        };

        /**
         * Encodes the specified KeyVerificationFinal message, length delimited. Does not implicitly {@link meshtastic.KeyVerificationFinal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {meshtastic.IKeyVerificationFinal} message KeyVerificationFinal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyVerificationFinal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyVerificationFinal message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.KeyVerificationFinal} KeyVerificationFinal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationFinal.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.KeyVerificationFinal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nonce = reader.uint64();
                        break;
                    }
                case 2: {
                        message.remoteLongname = reader.string();
                        break;
                    }
                case 3: {
                        message.isSender = reader.bool();
                        break;
                    }
                case 4: {
                        message.verificationCharacters = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyVerificationFinal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.KeyVerificationFinal} KeyVerificationFinal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyVerificationFinal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyVerificationFinal message.
         * @function verify
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyVerificationFinal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                    return "nonce: integer|Long expected";
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                if (!$util.isString(message.remoteLongname))
                    return "remoteLongname: string expected";
            if (message.isSender != null && message.hasOwnProperty("isSender"))
                if (typeof message.isSender !== "boolean")
                    return "isSender: boolean expected";
            if (message.verificationCharacters != null && message.hasOwnProperty("verificationCharacters"))
                if (!$util.isString(message.verificationCharacters))
                    return "verificationCharacters: string expected";
            return null;
        };

        /**
         * Creates a KeyVerificationFinal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.KeyVerificationFinal} KeyVerificationFinal
         */
        KeyVerificationFinal.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.KeyVerificationFinal)
                return object;
            var message = new $root.meshtastic.KeyVerificationFinal();
            if (object.nonce != null)
                if ($util.Long)
                    (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                else if (typeof object.nonce === "string")
                    message.nonce = parseInt(object.nonce, 10);
                else if (typeof object.nonce === "number")
                    message.nonce = object.nonce;
                else if (typeof object.nonce === "object")
                    message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
            if (object.remoteLongname != null)
                message.remoteLongname = String(object.remoteLongname);
            if (object.isSender != null)
                message.isSender = Boolean(object.isSender);
            if (object.verificationCharacters != null)
                message.verificationCharacters = String(object.verificationCharacters);
            return message;
        };

        /**
         * Creates a plain object from a KeyVerificationFinal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {meshtastic.KeyVerificationFinal} message KeyVerificationFinal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyVerificationFinal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nonce = options.longs === String ? "0" : 0;
                object.remoteLongname = "";
                object.isSender = false;
                object.verificationCharacters = "";
            }
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (typeof message.nonce === "number")
                    object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                else
                    object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
            if (message.remoteLongname != null && message.hasOwnProperty("remoteLongname"))
                object.remoteLongname = message.remoteLongname;
            if (message.isSender != null && message.hasOwnProperty("isSender"))
                object.isSender = message.isSender;
            if (message.verificationCharacters != null && message.hasOwnProperty("verificationCharacters"))
                object.verificationCharacters = message.verificationCharacters;
            return object;
        };

        /**
         * Converts this KeyVerificationFinal to JSON.
         * @function toJSON
         * @memberof meshtastic.KeyVerificationFinal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyVerificationFinal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KeyVerificationFinal
         * @function getTypeUrl
         * @memberof meshtastic.KeyVerificationFinal
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyVerificationFinal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.KeyVerificationFinal";
        };

        return KeyVerificationFinal;
    })();

    meshtastic.DuplicatedPublicKey = (function() {

        /**
         * Properties of a DuplicatedPublicKey.
         * @memberof meshtastic
         * @interface IDuplicatedPublicKey
         */

        /**
         * Constructs a new DuplicatedPublicKey.
         * @memberof meshtastic
         * @classdesc Represents a DuplicatedPublicKey.
         * @implements IDuplicatedPublicKey
         * @constructor
         * @param {meshtastic.IDuplicatedPublicKey=} [properties] Properties to set
         */
        function DuplicatedPublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DuplicatedPublicKey instance using the specified properties.
         * @function create
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {meshtastic.IDuplicatedPublicKey=} [properties] Properties to set
         * @returns {meshtastic.DuplicatedPublicKey} DuplicatedPublicKey instance
         */
        DuplicatedPublicKey.create = function create(properties) {
            return new DuplicatedPublicKey(properties);
        };

        /**
         * Encodes the specified DuplicatedPublicKey message. Does not implicitly {@link meshtastic.DuplicatedPublicKey.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {meshtastic.IDuplicatedPublicKey} message DuplicatedPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DuplicatedPublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DuplicatedPublicKey message, length delimited. Does not implicitly {@link meshtastic.DuplicatedPublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {meshtastic.IDuplicatedPublicKey} message DuplicatedPublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DuplicatedPublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DuplicatedPublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.DuplicatedPublicKey} DuplicatedPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DuplicatedPublicKey.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.DuplicatedPublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DuplicatedPublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.DuplicatedPublicKey} DuplicatedPublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DuplicatedPublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DuplicatedPublicKey message.
         * @function verify
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DuplicatedPublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DuplicatedPublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.DuplicatedPublicKey} DuplicatedPublicKey
         */
        DuplicatedPublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.DuplicatedPublicKey)
                return object;
            return new $root.meshtastic.DuplicatedPublicKey();
        };

        /**
         * Creates a plain object from a DuplicatedPublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {meshtastic.DuplicatedPublicKey} message DuplicatedPublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DuplicatedPublicKey.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DuplicatedPublicKey to JSON.
         * @function toJSON
         * @memberof meshtastic.DuplicatedPublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DuplicatedPublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DuplicatedPublicKey
         * @function getTypeUrl
         * @memberof meshtastic.DuplicatedPublicKey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DuplicatedPublicKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.DuplicatedPublicKey";
        };

        return DuplicatedPublicKey;
    })();

    meshtastic.LowEntropyKey = (function() {

        /**
         * Properties of a LowEntropyKey.
         * @memberof meshtastic
         * @interface ILowEntropyKey
         */

        /**
         * Constructs a new LowEntropyKey.
         * @memberof meshtastic
         * @classdesc Represents a LowEntropyKey.
         * @implements ILowEntropyKey
         * @constructor
         * @param {meshtastic.ILowEntropyKey=} [properties] Properties to set
         */
        function LowEntropyKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new LowEntropyKey instance using the specified properties.
         * @function create
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {meshtastic.ILowEntropyKey=} [properties] Properties to set
         * @returns {meshtastic.LowEntropyKey} LowEntropyKey instance
         */
        LowEntropyKey.create = function create(properties) {
            return new LowEntropyKey(properties);
        };

        /**
         * Encodes the specified LowEntropyKey message. Does not implicitly {@link meshtastic.LowEntropyKey.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {meshtastic.ILowEntropyKey} message LowEntropyKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LowEntropyKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified LowEntropyKey message, length delimited. Does not implicitly {@link meshtastic.LowEntropyKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {meshtastic.ILowEntropyKey} message LowEntropyKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LowEntropyKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LowEntropyKey message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.LowEntropyKey} LowEntropyKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LowEntropyKey.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.LowEntropyKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LowEntropyKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.LowEntropyKey} LowEntropyKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LowEntropyKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LowEntropyKey message.
         * @function verify
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LowEntropyKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a LowEntropyKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.LowEntropyKey} LowEntropyKey
         */
        LowEntropyKey.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.LowEntropyKey)
                return object;
            return new $root.meshtastic.LowEntropyKey();
        };

        /**
         * Creates a plain object from a LowEntropyKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {meshtastic.LowEntropyKey} message LowEntropyKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LowEntropyKey.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this LowEntropyKey to JSON.
         * @function toJSON
         * @memberof meshtastic.LowEntropyKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LowEntropyKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LowEntropyKey
         * @function getTypeUrl
         * @memberof meshtastic.LowEntropyKey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LowEntropyKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.LowEntropyKey";
        };

        return LowEntropyKey;
    })();

    meshtastic.FileInfo = (function() {

        /**
         * Properties of a FileInfo.
         * @memberof meshtastic
         * @interface IFileInfo
         * @property {string|null} [fileName] FileInfo fileName
         * @property {number|null} [sizeBytes] FileInfo sizeBytes
         */

        /**
         * Constructs a new FileInfo.
         * @memberof meshtastic
         * @classdesc Represents a FileInfo.
         * @implements IFileInfo
         * @constructor
         * @param {meshtastic.IFileInfo=} [properties] Properties to set
         */
        function FileInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileInfo fileName.
         * @member {string} fileName
         * @memberof meshtastic.FileInfo
         * @instance
         */
        FileInfo.prototype.fileName = "";

        /**
         * FileInfo sizeBytes.
         * @member {number} sizeBytes
         * @memberof meshtastic.FileInfo
         * @instance
         */
        FileInfo.prototype.sizeBytes = 0;

        /**
         * Creates a new FileInfo instance using the specified properties.
         * @function create
         * @memberof meshtastic.FileInfo
         * @static
         * @param {meshtastic.IFileInfo=} [properties] Properties to set
         * @returns {meshtastic.FileInfo} FileInfo instance
         */
        FileInfo.create = function create(properties) {
            return new FileInfo(properties);
        };

        /**
         * Encodes the specified FileInfo message. Does not implicitly {@link meshtastic.FileInfo.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.FileInfo
         * @static
         * @param {meshtastic.IFileInfo} message FileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
            if (message.sizeBytes != null && Object.hasOwnProperty.call(message, "sizeBytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sizeBytes);
            return writer;
        };

        /**
         * Encodes the specified FileInfo message, length delimited. Does not implicitly {@link meshtastic.FileInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.FileInfo
         * @static
         * @param {meshtastic.IFileInfo} message FileInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileInfo message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.FileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.FileInfo} FileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.FileInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.fileName = reader.string();
                        break;
                    }
                case 2: {
                        message.sizeBytes = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.FileInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.FileInfo} FileInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileInfo message.
         * @function verify
         * @memberof meshtastic.FileInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.sizeBytes != null && message.hasOwnProperty("sizeBytes"))
                if (!$util.isInteger(message.sizeBytes))
                    return "sizeBytes: integer expected";
            return null;
        };

        /**
         * Creates a FileInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.FileInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.FileInfo} FileInfo
         */
        FileInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.FileInfo)
                return object;
            var message = new $root.meshtastic.FileInfo();
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.sizeBytes != null)
                message.sizeBytes = object.sizeBytes >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a FileInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.FileInfo
         * @static
         * @param {meshtastic.FileInfo} message FileInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fileName = "";
                object.sizeBytes = 0;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.sizeBytes != null && message.hasOwnProperty("sizeBytes"))
                object.sizeBytes = message.sizeBytes;
            return object;
        };

        /**
         * Converts this FileInfo to JSON.
         * @function toJSON
         * @memberof meshtastic.FileInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FileInfo
         * @function getTypeUrl
         * @memberof meshtastic.FileInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FileInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.FileInfo";
        };

        return FileInfo;
    })();

    meshtastic.ToRadio = (function() {

        /**
         * Properties of a ToRadio.
         * @memberof meshtastic
         * @interface IToRadio
         * @property {meshtastic.IMeshPacket|null} [packet] ToRadio packet
         * @property {number|null} [wantConfigId] ToRadio wantConfigId
         * @property {boolean|null} [disconnect] ToRadio disconnect
         * @property {meshtastic.IXModem|null} [xmodemPacket] ToRadio xmodemPacket
         * @property {meshtastic.IMqttClientProxyMessage|null} [mqttClientProxyMessage] ToRadio mqttClientProxyMessage
         * @property {meshtastic.IHeartbeat|null} [heartbeat] ToRadio heartbeat
         */

        /**
         * Constructs a new ToRadio.
         * @memberof meshtastic
         * @classdesc Represents a ToRadio.
         * @implements IToRadio
         * @constructor
         * @param {meshtastic.IToRadio=} [properties] Properties to set
         */
        function ToRadio(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ToRadio packet.
         * @member {meshtastic.IMeshPacket|null|undefined} packet
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.packet = null;

        /**
         * ToRadio wantConfigId.
         * @member {number|null|undefined} wantConfigId
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.wantConfigId = null;

        /**
         * ToRadio disconnect.
         * @member {boolean|null|undefined} disconnect
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.disconnect = null;

        /**
         * ToRadio xmodemPacket.
         * @member {meshtastic.IXModem|null|undefined} xmodemPacket
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.xmodemPacket = null;

        /**
         * ToRadio mqttClientProxyMessage.
         * @member {meshtastic.IMqttClientProxyMessage|null|undefined} mqttClientProxyMessage
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.mqttClientProxyMessage = null;

        /**
         * ToRadio heartbeat.
         * @member {meshtastic.IHeartbeat|null|undefined} heartbeat
         * @memberof meshtastic.ToRadio
         * @instance
         */
        ToRadio.prototype.heartbeat = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ToRadio payloadVariant.
         * @member {"packet"|"wantConfigId"|"disconnect"|"xmodemPacket"|"mqttClientProxyMessage"|"heartbeat"|undefined} payloadVariant
         * @memberof meshtastic.ToRadio
         * @instance
         */
        Object.defineProperty(ToRadio.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["packet", "wantConfigId", "disconnect", "xmodemPacket", "mqttClientProxyMessage", "heartbeat"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ToRadio instance using the specified properties.
         * @function create
         * @memberof meshtastic.ToRadio
         * @static
         * @param {meshtastic.IToRadio=} [properties] Properties to set
         * @returns {meshtastic.ToRadio} ToRadio instance
         */
        ToRadio.create = function create(properties) {
            return new ToRadio(properties);
        };

        /**
         * Encodes the specified ToRadio message. Does not implicitly {@link meshtastic.ToRadio.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ToRadio
         * @static
         * @param {meshtastic.IToRadio} message ToRadio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToRadio.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.packet != null && Object.hasOwnProperty.call(message, "packet"))
                $root.meshtastic.MeshPacket.encode(message.packet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.wantConfigId != null && Object.hasOwnProperty.call(message, "wantConfigId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.wantConfigId);
            if (message.disconnect != null && Object.hasOwnProperty.call(message, "disconnect"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.disconnect);
            if (message.xmodemPacket != null && Object.hasOwnProperty.call(message, "xmodemPacket"))
                $root.meshtastic.XModem.encode(message.xmodemPacket, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.mqttClientProxyMessage != null && Object.hasOwnProperty.call(message, "mqttClientProxyMessage"))
                $root.meshtastic.MqttClientProxyMessage.encode(message.mqttClientProxyMessage, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.heartbeat != null && Object.hasOwnProperty.call(message, "heartbeat"))
                $root.meshtastic.Heartbeat.encode(message.heartbeat, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ToRadio message, length delimited. Does not implicitly {@link meshtastic.ToRadio.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ToRadio
         * @static
         * @param {meshtastic.IToRadio} message ToRadio message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ToRadio.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ToRadio message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ToRadio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ToRadio} ToRadio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToRadio.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ToRadio();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.packet = $root.meshtastic.MeshPacket.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.wantConfigId = reader.uint32();
                        break;
                    }
                case 4: {
                        message.disconnect = reader.bool();
                        break;
                    }
                case 5: {
                        message.xmodemPacket = $root.meshtastic.XModem.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.heartbeat = $root.meshtastic.Heartbeat.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ToRadio message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ToRadio
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ToRadio} ToRadio
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ToRadio.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ToRadio message.
         * @function verify
         * @memberof meshtastic.ToRadio
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ToRadio.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.packet != null && message.hasOwnProperty("packet")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.MeshPacket.verify(message.packet);
                    if (error)
                        return "packet." + error;
                }
            }
            if (message.wantConfigId != null && message.hasOwnProperty("wantConfigId")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (!$util.isInteger(message.wantConfigId))
                    return "wantConfigId: integer expected";
            }
            if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (typeof message.disconnect !== "boolean")
                    return "disconnect: boolean expected";
            }
            if (message.xmodemPacket != null && message.hasOwnProperty("xmodemPacket")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.XModem.verify(message.xmodemPacket);
                    if (error)
                        return "xmodemPacket." + error;
                }
            }
            if (message.mqttClientProxyMessage != null && message.hasOwnProperty("mqttClientProxyMessage")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.MqttClientProxyMessage.verify(message.mqttClientProxyMessage);
                    if (error)
                        return "mqttClientProxyMessage." + error;
                }
            }
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.Heartbeat.verify(message.heartbeat);
                    if (error)
                        return "heartbeat." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ToRadio message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ToRadio
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ToRadio} ToRadio
         */
        ToRadio.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ToRadio)
                return object;
            var message = new $root.meshtastic.ToRadio();
            if (object.packet != null) {
                if (typeof object.packet !== "object")
                    throw TypeError(".meshtastic.ToRadio.packet: object expected");
                message.packet = $root.meshtastic.MeshPacket.fromObject(object.packet);
            }
            if (object.wantConfigId != null)
                message.wantConfigId = object.wantConfigId >>> 0;
            if (object.disconnect != null)
                message.disconnect = Boolean(object.disconnect);
            if (object.xmodemPacket != null) {
                if (typeof object.xmodemPacket !== "object")
                    throw TypeError(".meshtastic.ToRadio.xmodemPacket: object expected");
                message.xmodemPacket = $root.meshtastic.XModem.fromObject(object.xmodemPacket);
            }
            if (object.mqttClientProxyMessage != null) {
                if (typeof object.mqttClientProxyMessage !== "object")
                    throw TypeError(".meshtastic.ToRadio.mqttClientProxyMessage: object expected");
                message.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.fromObject(object.mqttClientProxyMessage);
            }
            if (object.heartbeat != null) {
                if (typeof object.heartbeat !== "object")
                    throw TypeError(".meshtastic.ToRadio.heartbeat: object expected");
                message.heartbeat = $root.meshtastic.Heartbeat.fromObject(object.heartbeat);
            }
            return message;
        };

        /**
         * Creates a plain object from a ToRadio message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ToRadio
         * @static
         * @param {meshtastic.ToRadio} message ToRadio
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ToRadio.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.packet != null && message.hasOwnProperty("packet")) {
                object.packet = $root.meshtastic.MeshPacket.toObject(message.packet, options);
                if (options.oneofs)
                    object.payloadVariant = "packet";
            }
            if (message.wantConfigId != null && message.hasOwnProperty("wantConfigId")) {
                object.wantConfigId = message.wantConfigId;
                if (options.oneofs)
                    object.payloadVariant = "wantConfigId";
            }
            if (message.disconnect != null && message.hasOwnProperty("disconnect")) {
                object.disconnect = message.disconnect;
                if (options.oneofs)
                    object.payloadVariant = "disconnect";
            }
            if (message.xmodemPacket != null && message.hasOwnProperty("xmodemPacket")) {
                object.xmodemPacket = $root.meshtastic.XModem.toObject(message.xmodemPacket, options);
                if (options.oneofs)
                    object.payloadVariant = "xmodemPacket";
            }
            if (message.mqttClientProxyMessage != null && message.hasOwnProperty("mqttClientProxyMessage")) {
                object.mqttClientProxyMessage = $root.meshtastic.MqttClientProxyMessage.toObject(message.mqttClientProxyMessage, options);
                if (options.oneofs)
                    object.payloadVariant = "mqttClientProxyMessage";
            }
            if (message.heartbeat != null && message.hasOwnProperty("heartbeat")) {
                object.heartbeat = $root.meshtastic.Heartbeat.toObject(message.heartbeat, options);
                if (options.oneofs)
                    object.payloadVariant = "heartbeat";
            }
            return object;
        };

        /**
         * Converts this ToRadio to JSON.
         * @function toJSON
         * @memberof meshtastic.ToRadio
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ToRadio.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ToRadio
         * @function getTypeUrl
         * @memberof meshtastic.ToRadio
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ToRadio.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ToRadio";
        };

        return ToRadio;
    })();

    meshtastic.Compressed = (function() {

        /**
         * Properties of a Compressed.
         * @memberof meshtastic
         * @interface ICompressed
         * @property {meshtastic.PortNum|null} [portnum] Compressed portnum
         * @property {Uint8Array|null} [data] Compressed data
         */

        /**
         * Constructs a new Compressed.
         * @memberof meshtastic
         * @classdesc Represents a Compressed.
         * @implements ICompressed
         * @constructor
         * @param {meshtastic.ICompressed=} [properties] Properties to set
         */
        function Compressed(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Compressed portnum.
         * @member {meshtastic.PortNum} portnum
         * @memberof meshtastic.Compressed
         * @instance
         */
        Compressed.prototype.portnum = 0;

        /**
         * Compressed data.
         * @member {Uint8Array} data
         * @memberof meshtastic.Compressed
         * @instance
         */
        Compressed.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Compressed instance using the specified properties.
         * @function create
         * @memberof meshtastic.Compressed
         * @static
         * @param {meshtastic.ICompressed=} [properties] Properties to set
         * @returns {meshtastic.Compressed} Compressed instance
         */
        Compressed.create = function create(properties) {
            return new Compressed(properties);
        };

        /**
         * Encodes the specified Compressed message. Does not implicitly {@link meshtastic.Compressed.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Compressed
         * @static
         * @param {meshtastic.ICompressed} message Compressed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Compressed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.portnum != null && Object.hasOwnProperty.call(message, "portnum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.portnum);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Compressed message, length delimited. Does not implicitly {@link meshtastic.Compressed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Compressed
         * @static
         * @param {meshtastic.ICompressed} message Compressed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Compressed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Compressed message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Compressed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Compressed} Compressed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Compressed.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Compressed();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.portnum = reader.int32();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Compressed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Compressed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Compressed} Compressed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Compressed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Compressed message.
         * @function verify
         * @memberof meshtastic.Compressed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Compressed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.portnum != null && message.hasOwnProperty("portnum"))
                switch (message.portnum) {
                default:
                    return "portnum: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 32:
                case 33:
                case 34:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 76:
                case 77:
                case 256:
                case 257:
                case 511:
                    break;
                }
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a Compressed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Compressed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Compressed} Compressed
         */
        Compressed.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Compressed)
                return object;
            var message = new $root.meshtastic.Compressed();
            switch (object.portnum) {
            default:
                if (typeof object.portnum === "number") {
                    message.portnum = object.portnum;
                    break;
                }
                break;
            case "UNKNOWN_APP":
            case 0:
                message.portnum = 0;
                break;
            case "TEXT_MESSAGE_APP":
            case 1:
                message.portnum = 1;
                break;
            case "REMOTE_HARDWARE_APP":
            case 2:
                message.portnum = 2;
                break;
            case "POSITION_APP":
            case 3:
                message.portnum = 3;
                break;
            case "NODEINFO_APP":
            case 4:
                message.portnum = 4;
                break;
            case "ROUTING_APP":
            case 5:
                message.portnum = 5;
                break;
            case "ADMIN_APP":
            case 6:
                message.portnum = 6;
                break;
            case "TEXT_MESSAGE_COMPRESSED_APP":
            case 7:
                message.portnum = 7;
                break;
            case "WAYPOINT_APP":
            case 8:
                message.portnum = 8;
                break;
            case "AUDIO_APP":
            case 9:
                message.portnum = 9;
                break;
            case "DETECTION_SENSOR_APP":
            case 10:
                message.portnum = 10;
                break;
            case "ALERT_APP":
            case 11:
                message.portnum = 11;
                break;
            case "KEY_VERIFICATION_APP":
            case 12:
                message.portnum = 12;
                break;
            case "REPLY_APP":
            case 32:
                message.portnum = 32;
                break;
            case "IP_TUNNEL_APP":
            case 33:
                message.portnum = 33;
                break;
            case "PAXCOUNTER_APP":
            case 34:
                message.portnum = 34;
                break;
            case "SERIAL_APP":
            case 64:
                message.portnum = 64;
                break;
            case "STORE_FORWARD_APP":
            case 65:
                message.portnum = 65;
                break;
            case "RANGE_TEST_APP":
            case 66:
                message.portnum = 66;
                break;
            case "TELEMETRY_APP":
            case 67:
                message.portnum = 67;
                break;
            case "ZPS_APP":
            case 68:
                message.portnum = 68;
                break;
            case "SIMULATOR_APP":
            case 69:
                message.portnum = 69;
                break;
            case "TRACEROUTE_APP":
            case 70:
                message.portnum = 70;
                break;
            case "NEIGHBORINFO_APP":
            case 71:
                message.portnum = 71;
                break;
            case "ATAK_PLUGIN":
            case 72:
                message.portnum = 72;
                break;
            case "MAP_REPORT_APP":
            case 73:
                message.portnum = 73;
                break;
            case "POWERSTRESS_APP":
            case 74:
                message.portnum = 74;
                break;
            case "RETICULUM_TUNNEL_APP":
            case 76:
                message.portnum = 76;
                break;
            case "CAYENNE_APP":
            case 77:
                message.portnum = 77;
                break;
            case "PRIVATE_APP":
            case 256:
                message.portnum = 256;
                break;
            case "ATAK_FORWARDER":
            case 257:
                message.portnum = 257;
                break;
            case "MAX":
            case 511:
                message.portnum = 511;
                break;
            }
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a Compressed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Compressed
         * @static
         * @param {meshtastic.Compressed} message Compressed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Compressed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.portnum = options.enums === String ? "UNKNOWN_APP" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.portnum != null && message.hasOwnProperty("portnum"))
                object.portnum = options.enums === String ? $root.meshtastic.PortNum[message.portnum] === undefined ? message.portnum : $root.meshtastic.PortNum[message.portnum] : message.portnum;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Compressed to JSON.
         * @function toJSON
         * @memberof meshtastic.Compressed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Compressed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Compressed
         * @function getTypeUrl
         * @memberof meshtastic.Compressed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Compressed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Compressed";
        };

        return Compressed;
    })();

    meshtastic.NeighborInfo = (function() {

        /**
         * Properties of a NeighborInfo.
         * @memberof meshtastic
         * @interface INeighborInfo
         * @property {number|null} [nodeId] NeighborInfo nodeId
         * @property {number|null} [lastSentById] NeighborInfo lastSentById
         * @property {number|null} [nodeBroadcastIntervalSecs] NeighborInfo nodeBroadcastIntervalSecs
         * @property {Array.<meshtastic.INeighbor>|null} [neighbors] NeighborInfo neighbors
         */

        /**
         * Constructs a new NeighborInfo.
         * @memberof meshtastic
         * @classdesc Represents a NeighborInfo.
         * @implements INeighborInfo
         * @constructor
         * @param {meshtastic.INeighborInfo=} [properties] Properties to set
         */
        function NeighborInfo(properties) {
            this.neighbors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NeighborInfo nodeId.
         * @member {number} nodeId
         * @memberof meshtastic.NeighborInfo
         * @instance
         */
        NeighborInfo.prototype.nodeId = 0;

        /**
         * NeighborInfo lastSentById.
         * @member {number} lastSentById
         * @memberof meshtastic.NeighborInfo
         * @instance
         */
        NeighborInfo.prototype.lastSentById = 0;

        /**
         * NeighborInfo nodeBroadcastIntervalSecs.
         * @member {number} nodeBroadcastIntervalSecs
         * @memberof meshtastic.NeighborInfo
         * @instance
         */
        NeighborInfo.prototype.nodeBroadcastIntervalSecs = 0;

        /**
         * NeighborInfo neighbors.
         * @member {Array.<meshtastic.INeighbor>} neighbors
         * @memberof meshtastic.NeighborInfo
         * @instance
         */
        NeighborInfo.prototype.neighbors = $util.emptyArray;

        /**
         * Creates a new NeighborInfo instance using the specified properties.
         * @function create
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {meshtastic.INeighborInfo=} [properties] Properties to set
         * @returns {meshtastic.NeighborInfo} NeighborInfo instance
         */
        NeighborInfo.create = function create(properties) {
            return new NeighborInfo(properties);
        };

        /**
         * Encodes the specified NeighborInfo message. Does not implicitly {@link meshtastic.NeighborInfo.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {meshtastic.INeighborInfo} message NeighborInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NeighborInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nodeId);
            if (message.lastSentById != null && Object.hasOwnProperty.call(message, "lastSentById"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lastSentById);
            if (message.nodeBroadcastIntervalSecs != null && Object.hasOwnProperty.call(message, "nodeBroadcastIntervalSecs"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.nodeBroadcastIntervalSecs);
            if (message.neighbors != null && message.neighbors.length)
                for (var i = 0; i < message.neighbors.length; ++i)
                    $root.meshtastic.Neighbor.encode(message.neighbors[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NeighborInfo message, length delimited. Does not implicitly {@link meshtastic.NeighborInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {meshtastic.INeighborInfo} message NeighborInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NeighborInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NeighborInfo message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.NeighborInfo} NeighborInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NeighborInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.NeighborInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nodeId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.lastSentById = reader.uint32();
                        break;
                    }
                case 3: {
                        message.nodeBroadcastIntervalSecs = reader.uint32();
                        break;
                    }
                case 4: {
                        if (!(message.neighbors && message.neighbors.length))
                            message.neighbors = [];
                        message.neighbors.push($root.meshtastic.Neighbor.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NeighborInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.NeighborInfo} NeighborInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NeighborInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NeighborInfo message.
         * @function verify
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NeighborInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId))
                    return "nodeId: integer expected";
            if (message.lastSentById != null && message.hasOwnProperty("lastSentById"))
                if (!$util.isInteger(message.lastSentById))
                    return "lastSentById: integer expected";
            if (message.nodeBroadcastIntervalSecs != null && message.hasOwnProperty("nodeBroadcastIntervalSecs"))
                if (!$util.isInteger(message.nodeBroadcastIntervalSecs))
                    return "nodeBroadcastIntervalSecs: integer expected";
            if (message.neighbors != null && message.hasOwnProperty("neighbors")) {
                if (!Array.isArray(message.neighbors))
                    return "neighbors: array expected";
                for (var i = 0; i < message.neighbors.length; ++i) {
                    var error = $root.meshtastic.Neighbor.verify(message.neighbors[i]);
                    if (error)
                        return "neighbors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NeighborInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.NeighborInfo} NeighborInfo
         */
        NeighborInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.NeighborInfo)
                return object;
            var message = new $root.meshtastic.NeighborInfo();
            if (object.nodeId != null)
                message.nodeId = object.nodeId >>> 0;
            if (object.lastSentById != null)
                message.lastSentById = object.lastSentById >>> 0;
            if (object.nodeBroadcastIntervalSecs != null)
                message.nodeBroadcastIntervalSecs = object.nodeBroadcastIntervalSecs >>> 0;
            if (object.neighbors) {
                if (!Array.isArray(object.neighbors))
                    throw TypeError(".meshtastic.NeighborInfo.neighbors: array expected");
                message.neighbors = [];
                for (var i = 0; i < object.neighbors.length; ++i) {
                    if (typeof object.neighbors[i] !== "object")
                        throw TypeError(".meshtastic.NeighborInfo.neighbors: object expected");
                    message.neighbors[i] = $root.meshtastic.Neighbor.fromObject(object.neighbors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NeighborInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {meshtastic.NeighborInfo} message NeighborInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NeighborInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.neighbors = [];
            if (options.defaults) {
                object.nodeId = 0;
                object.lastSentById = 0;
                object.nodeBroadcastIntervalSecs = 0;
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            if (message.lastSentById != null && message.hasOwnProperty("lastSentById"))
                object.lastSentById = message.lastSentById;
            if (message.nodeBroadcastIntervalSecs != null && message.hasOwnProperty("nodeBroadcastIntervalSecs"))
                object.nodeBroadcastIntervalSecs = message.nodeBroadcastIntervalSecs;
            if (message.neighbors && message.neighbors.length) {
                object.neighbors = [];
                for (var j = 0; j < message.neighbors.length; ++j)
                    object.neighbors[j] = $root.meshtastic.Neighbor.toObject(message.neighbors[j], options);
            }
            return object;
        };

        /**
         * Converts this NeighborInfo to JSON.
         * @function toJSON
         * @memberof meshtastic.NeighborInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NeighborInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NeighborInfo
         * @function getTypeUrl
         * @memberof meshtastic.NeighborInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NeighborInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.NeighborInfo";
        };

        return NeighborInfo;
    })();

    meshtastic.Neighbor = (function() {

        /**
         * Properties of a Neighbor.
         * @memberof meshtastic
         * @interface INeighbor
         * @property {number|null} [nodeId] Neighbor nodeId
         * @property {number|null} [snr] Neighbor snr
         * @property {number|null} [lastRxTime] Neighbor lastRxTime
         * @property {number|null} [nodeBroadcastIntervalSecs] Neighbor nodeBroadcastIntervalSecs
         */

        /**
         * Constructs a new Neighbor.
         * @memberof meshtastic
         * @classdesc Represents a Neighbor.
         * @implements INeighbor
         * @constructor
         * @param {meshtastic.INeighbor=} [properties] Properties to set
         */
        function Neighbor(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Neighbor nodeId.
         * @member {number} nodeId
         * @memberof meshtastic.Neighbor
         * @instance
         */
        Neighbor.prototype.nodeId = 0;

        /**
         * Neighbor snr.
         * @member {number} snr
         * @memberof meshtastic.Neighbor
         * @instance
         */
        Neighbor.prototype.snr = 0;

        /**
         * Neighbor lastRxTime.
         * @member {number} lastRxTime
         * @memberof meshtastic.Neighbor
         * @instance
         */
        Neighbor.prototype.lastRxTime = 0;

        /**
         * Neighbor nodeBroadcastIntervalSecs.
         * @member {number} nodeBroadcastIntervalSecs
         * @memberof meshtastic.Neighbor
         * @instance
         */
        Neighbor.prototype.nodeBroadcastIntervalSecs = 0;

        /**
         * Creates a new Neighbor instance using the specified properties.
         * @function create
         * @memberof meshtastic.Neighbor
         * @static
         * @param {meshtastic.INeighbor=} [properties] Properties to set
         * @returns {meshtastic.Neighbor} Neighbor instance
         */
        Neighbor.create = function create(properties) {
            return new Neighbor(properties);
        };

        /**
         * Encodes the specified Neighbor message. Does not implicitly {@link meshtastic.Neighbor.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Neighbor
         * @static
         * @param {meshtastic.INeighbor} message Neighbor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nodeId);
            if (message.snr != null && Object.hasOwnProperty.call(message, "snr"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.snr);
            if (message.lastRxTime != null && Object.hasOwnProperty.call(message, "lastRxTime"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.lastRxTime);
            if (message.nodeBroadcastIntervalSecs != null && Object.hasOwnProperty.call(message, "nodeBroadcastIntervalSecs"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.nodeBroadcastIntervalSecs);
            return writer;
        };

        /**
         * Encodes the specified Neighbor message, length delimited. Does not implicitly {@link meshtastic.Neighbor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Neighbor
         * @static
         * @param {meshtastic.INeighbor} message Neighbor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Neighbor message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Neighbor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Neighbor} Neighbor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbor.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Neighbor();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nodeId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.snr = reader.float();
                        break;
                    }
                case 3: {
                        message.lastRxTime = reader.fixed32();
                        break;
                    }
                case 4: {
                        message.nodeBroadcastIntervalSecs = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Neighbor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Neighbor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Neighbor} Neighbor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Neighbor message.
         * @function verify
         * @memberof meshtastic.Neighbor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Neighbor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId))
                    return "nodeId: integer expected";
            if (message.snr != null && message.hasOwnProperty("snr"))
                if (typeof message.snr !== "number")
                    return "snr: number expected";
            if (message.lastRxTime != null && message.hasOwnProperty("lastRxTime"))
                if (!$util.isInteger(message.lastRxTime))
                    return "lastRxTime: integer expected";
            if (message.nodeBroadcastIntervalSecs != null && message.hasOwnProperty("nodeBroadcastIntervalSecs"))
                if (!$util.isInteger(message.nodeBroadcastIntervalSecs))
                    return "nodeBroadcastIntervalSecs: integer expected";
            return null;
        };

        /**
         * Creates a Neighbor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Neighbor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Neighbor} Neighbor
         */
        Neighbor.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Neighbor)
                return object;
            var message = new $root.meshtastic.Neighbor();
            if (object.nodeId != null)
                message.nodeId = object.nodeId >>> 0;
            if (object.snr != null)
                message.snr = Number(object.snr);
            if (object.lastRxTime != null)
                message.lastRxTime = object.lastRxTime >>> 0;
            if (object.nodeBroadcastIntervalSecs != null)
                message.nodeBroadcastIntervalSecs = object.nodeBroadcastIntervalSecs >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Neighbor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Neighbor
         * @static
         * @param {meshtastic.Neighbor} message Neighbor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Neighbor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nodeId = 0;
                object.snr = 0;
                object.lastRxTime = 0;
                object.nodeBroadcastIntervalSecs = 0;
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            if (message.snr != null && message.hasOwnProperty("snr"))
                object.snr = options.json && !isFinite(message.snr) ? String(message.snr) : message.snr;
            if (message.lastRxTime != null && message.hasOwnProperty("lastRxTime"))
                object.lastRxTime = message.lastRxTime;
            if (message.nodeBroadcastIntervalSecs != null && message.hasOwnProperty("nodeBroadcastIntervalSecs"))
                object.nodeBroadcastIntervalSecs = message.nodeBroadcastIntervalSecs;
            return object;
        };

        /**
         * Converts this Neighbor to JSON.
         * @function toJSON
         * @memberof meshtastic.Neighbor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Neighbor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Neighbor
         * @function getTypeUrl
         * @memberof meshtastic.Neighbor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Neighbor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Neighbor";
        };

        return Neighbor;
    })();

    meshtastic.DeviceMetadata = (function() {

        /**
         * Properties of a DeviceMetadata.
         * @memberof meshtastic
         * @interface IDeviceMetadata
         * @property {string|null} [firmwareVersion] DeviceMetadata firmwareVersion
         * @property {number|null} [deviceStateVersion] DeviceMetadata deviceStateVersion
         * @property {boolean|null} [canShutdown] DeviceMetadata canShutdown
         * @property {boolean|null} [hasWifi] DeviceMetadata hasWifi
         * @property {boolean|null} [hasBluetooth] DeviceMetadata hasBluetooth
         * @property {boolean|null} [hasEthernet] DeviceMetadata hasEthernet
         * @property {meshtastic.Config.DeviceConfig.Role|null} [role] DeviceMetadata role
         * @property {number|null} [positionFlags] DeviceMetadata positionFlags
         * @property {meshtastic.HardwareModel|null} [hwModel] DeviceMetadata hwModel
         * @property {boolean|null} [hasRemoteHardware] DeviceMetadata hasRemoteHardware
         * @property {boolean|null} [hasPKC] DeviceMetadata hasPKC
         * @property {number|null} [excludedModules] DeviceMetadata excludedModules
         */

        /**
         * Constructs a new DeviceMetadata.
         * @memberof meshtastic
         * @classdesc Represents a DeviceMetadata.
         * @implements IDeviceMetadata
         * @constructor
         * @param {meshtastic.IDeviceMetadata=} [properties] Properties to set
         */
        function DeviceMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceMetadata firmwareVersion.
         * @member {string} firmwareVersion
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.firmwareVersion = "";

        /**
         * DeviceMetadata deviceStateVersion.
         * @member {number} deviceStateVersion
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.deviceStateVersion = 0;

        /**
         * DeviceMetadata canShutdown.
         * @member {boolean} canShutdown
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.canShutdown = false;

        /**
         * DeviceMetadata hasWifi.
         * @member {boolean} hasWifi
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hasWifi = false;

        /**
         * DeviceMetadata hasBluetooth.
         * @member {boolean} hasBluetooth
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hasBluetooth = false;

        /**
         * DeviceMetadata hasEthernet.
         * @member {boolean} hasEthernet
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hasEthernet = false;

        /**
         * DeviceMetadata role.
         * @member {meshtastic.Config.DeviceConfig.Role} role
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.role = 0;

        /**
         * DeviceMetadata positionFlags.
         * @member {number} positionFlags
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.positionFlags = 0;

        /**
         * DeviceMetadata hwModel.
         * @member {meshtastic.HardwareModel} hwModel
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hwModel = 0;

        /**
         * DeviceMetadata hasRemoteHardware.
         * @member {boolean} hasRemoteHardware
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hasRemoteHardware = false;

        /**
         * DeviceMetadata hasPKC.
         * @member {boolean} hasPKC
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.hasPKC = false;

        /**
         * DeviceMetadata excludedModules.
         * @member {number} excludedModules
         * @memberof meshtastic.DeviceMetadata
         * @instance
         */
        DeviceMetadata.prototype.excludedModules = 0;

        /**
         * Creates a new DeviceMetadata instance using the specified properties.
         * @function create
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {meshtastic.IDeviceMetadata=} [properties] Properties to set
         * @returns {meshtastic.DeviceMetadata} DeviceMetadata instance
         */
        DeviceMetadata.create = function create(properties) {
            return new DeviceMetadata(properties);
        };

        /**
         * Encodes the specified DeviceMetadata message. Does not implicitly {@link meshtastic.DeviceMetadata.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {meshtastic.IDeviceMetadata} message DeviceMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firmwareVersion != null && Object.hasOwnProperty.call(message, "firmwareVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.firmwareVersion);
            if (message.deviceStateVersion != null && Object.hasOwnProperty.call(message, "deviceStateVersion"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.deviceStateVersion);
            if (message.canShutdown != null && Object.hasOwnProperty.call(message, "canShutdown"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.canShutdown);
            if (message.hasWifi != null && Object.hasOwnProperty.call(message, "hasWifi"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.hasWifi);
            if (message.hasBluetooth != null && Object.hasOwnProperty.call(message, "hasBluetooth"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasBluetooth);
            if (message.hasEthernet != null && Object.hasOwnProperty.call(message, "hasEthernet"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasEthernet);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.role);
            if (message.positionFlags != null && Object.hasOwnProperty.call(message, "positionFlags"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.positionFlags);
            if (message.hwModel != null && Object.hasOwnProperty.call(message, "hwModel"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.hwModel);
            if (message.hasRemoteHardware != null && Object.hasOwnProperty.call(message, "hasRemoteHardware"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasRemoteHardware);
            if (message.hasPKC != null && Object.hasOwnProperty.call(message, "hasPKC"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.hasPKC);
            if (message.excludedModules != null && Object.hasOwnProperty.call(message, "excludedModules"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.excludedModules);
            return writer;
        };

        /**
         * Encodes the specified DeviceMetadata message, length delimited. Does not implicitly {@link meshtastic.DeviceMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {meshtastic.IDeviceMetadata} message DeviceMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.DeviceMetadata} DeviceMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceMetadata.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.DeviceMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.firmwareVersion = reader.string();
                        break;
                    }
                case 2: {
                        message.deviceStateVersion = reader.uint32();
                        break;
                    }
                case 3: {
                        message.canShutdown = reader.bool();
                        break;
                    }
                case 4: {
                        message.hasWifi = reader.bool();
                        break;
                    }
                case 5: {
                        message.hasBluetooth = reader.bool();
                        break;
                    }
                case 6: {
                        message.hasEthernet = reader.bool();
                        break;
                    }
                case 7: {
                        message.role = reader.int32();
                        break;
                    }
                case 8: {
                        message.positionFlags = reader.uint32();
                        break;
                    }
                case 9: {
                        message.hwModel = reader.int32();
                        break;
                    }
                case 10: {
                        message.hasRemoteHardware = reader.bool();
                        break;
                    }
                case 11: {
                        message.hasPKC = reader.bool();
                        break;
                    }
                case 12: {
                        message.excludedModules = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.DeviceMetadata} DeviceMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceMetadata message.
         * @function verify
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                if (!$util.isString(message.firmwareVersion))
                    return "firmwareVersion: string expected";
            if (message.deviceStateVersion != null && message.hasOwnProperty("deviceStateVersion"))
                if (!$util.isInteger(message.deviceStateVersion))
                    return "deviceStateVersion: integer expected";
            if (message.canShutdown != null && message.hasOwnProperty("canShutdown"))
                if (typeof message.canShutdown !== "boolean")
                    return "canShutdown: boolean expected";
            if (message.hasWifi != null && message.hasOwnProperty("hasWifi"))
                if (typeof message.hasWifi !== "boolean")
                    return "hasWifi: boolean expected";
            if (message.hasBluetooth != null && message.hasOwnProperty("hasBluetooth"))
                if (typeof message.hasBluetooth !== "boolean")
                    return "hasBluetooth: boolean expected";
            if (message.hasEthernet != null && message.hasOwnProperty("hasEthernet"))
                if (typeof message.hasEthernet !== "boolean")
                    return "hasEthernet: boolean expected";
            if (message.role != null && message.hasOwnProperty("role"))
                switch (message.role) {
                default:
                    return "role: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            if (message.positionFlags != null && message.hasOwnProperty("positionFlags"))
                if (!$util.isInteger(message.positionFlags))
                    return "positionFlags: integer expected";
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                switch (message.hwModel) {
                default:
                    return "hwModel: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 255:
                    break;
                }
            if (message.hasRemoteHardware != null && message.hasOwnProperty("hasRemoteHardware"))
                if (typeof message.hasRemoteHardware !== "boolean")
                    return "hasRemoteHardware: boolean expected";
            if (message.hasPKC != null && message.hasOwnProperty("hasPKC"))
                if (typeof message.hasPKC !== "boolean")
                    return "hasPKC: boolean expected";
            if (message.excludedModules != null && message.hasOwnProperty("excludedModules"))
                if (!$util.isInteger(message.excludedModules))
                    return "excludedModules: integer expected";
            return null;
        };

        /**
         * Creates a DeviceMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.DeviceMetadata} DeviceMetadata
         */
        DeviceMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.DeviceMetadata)
                return object;
            var message = new $root.meshtastic.DeviceMetadata();
            if (object.firmwareVersion != null)
                message.firmwareVersion = String(object.firmwareVersion);
            if (object.deviceStateVersion != null)
                message.deviceStateVersion = object.deviceStateVersion >>> 0;
            if (object.canShutdown != null)
                message.canShutdown = Boolean(object.canShutdown);
            if (object.hasWifi != null)
                message.hasWifi = Boolean(object.hasWifi);
            if (object.hasBluetooth != null)
                message.hasBluetooth = Boolean(object.hasBluetooth);
            if (object.hasEthernet != null)
                message.hasEthernet = Boolean(object.hasEthernet);
            switch (object.role) {
            default:
                if (typeof object.role === "number") {
                    message.role = object.role;
                    break;
                }
                break;
            case "CLIENT":
            case 0:
                message.role = 0;
                break;
            case "CLIENT_MUTE":
            case 1:
                message.role = 1;
                break;
            case "ROUTER":
            case 2:
                message.role = 2;
                break;
            case "ROUTER_CLIENT":
            case 3:
                message.role = 3;
                break;
            case "REPEATER":
            case 4:
                message.role = 4;
                break;
            case "TRACKER":
            case 5:
                message.role = 5;
                break;
            case "SENSOR":
            case 6:
                message.role = 6;
                break;
            case "TAK":
            case 7:
                message.role = 7;
                break;
            case "CLIENT_HIDDEN":
            case 8:
                message.role = 8;
                break;
            case "LOST_AND_FOUND":
            case 9:
                message.role = 9;
                break;
            case "TAK_TRACKER":
            case 10:
                message.role = 10;
                break;
            case "ROUTER_LATE":
            case 11:
                message.role = 11;
                break;
            case "CLIENT_BASE":
            case 12:
                message.role = 12;
                break;
            }
            if (object.positionFlags != null)
                message.positionFlags = object.positionFlags >>> 0;
            switch (object.hwModel) {
            default:
                if (typeof object.hwModel === "number") {
                    message.hwModel = object.hwModel;
                    break;
                }
                break;
            case "UNSET":
            case 0:
                message.hwModel = 0;
                break;
            case "TLORA_V2":
            case 1:
                message.hwModel = 1;
                break;
            case "TLORA_V1":
            case 2:
                message.hwModel = 2;
                break;
            case "TLORA_V2_1_1P6":
            case 3:
                message.hwModel = 3;
                break;
            case "TBEAM":
            case 4:
                message.hwModel = 4;
                break;
            case "HELTEC_V2_0":
            case 5:
                message.hwModel = 5;
                break;
            case "TBEAM_V0P7":
            case 6:
                message.hwModel = 6;
                break;
            case "T_ECHO":
            case 7:
                message.hwModel = 7;
                break;
            case "TLORA_V1_1P3":
            case 8:
                message.hwModel = 8;
                break;
            case "RAK4631":
            case 9:
                message.hwModel = 9;
                break;
            case "HELTEC_V2_1":
            case 10:
                message.hwModel = 10;
                break;
            case "HELTEC_V1":
            case 11:
                message.hwModel = 11;
                break;
            case "LILYGO_TBEAM_S3_CORE":
            case 12:
                message.hwModel = 12;
                break;
            case "RAK11200":
            case 13:
                message.hwModel = 13;
                break;
            case "NANO_G1":
            case 14:
                message.hwModel = 14;
                break;
            case "TLORA_V2_1_1P8":
            case 15:
                message.hwModel = 15;
                break;
            case "TLORA_T3_S3":
            case 16:
                message.hwModel = 16;
                break;
            case "NANO_G1_EXPLORER":
            case 17:
                message.hwModel = 17;
                break;
            case "NANO_G2_ULTRA":
            case 18:
                message.hwModel = 18;
                break;
            case "LORA_TYPE":
            case 19:
                message.hwModel = 19;
                break;
            case "WIPHONE":
            case 20:
                message.hwModel = 20;
                break;
            case "WIO_WM1110":
            case 21:
                message.hwModel = 21;
                break;
            case "RAK2560":
            case 22:
                message.hwModel = 22;
                break;
            case "HELTEC_HRU_3601":
            case 23:
                message.hwModel = 23;
                break;
            case "HELTEC_WIRELESS_BRIDGE":
            case 24:
                message.hwModel = 24;
                break;
            case "STATION_G1":
            case 25:
                message.hwModel = 25;
                break;
            case "RAK11310":
            case 26:
                message.hwModel = 26;
                break;
            case "SENSELORA_RP2040":
            case 27:
                message.hwModel = 27;
                break;
            case "SENSELORA_S3":
            case 28:
                message.hwModel = 28;
                break;
            case "CANARYONE":
            case 29:
                message.hwModel = 29;
                break;
            case "RP2040_LORA":
            case 30:
                message.hwModel = 30;
                break;
            case "STATION_G2":
            case 31:
                message.hwModel = 31;
                break;
            case "LORA_RELAY_V1":
            case 32:
                message.hwModel = 32;
                break;
            case "NRF52840DK":
            case 33:
                message.hwModel = 33;
                break;
            case "PPR":
            case 34:
                message.hwModel = 34;
                break;
            case "GENIEBLOCKS":
            case 35:
                message.hwModel = 35;
                break;
            case "NRF52_UNKNOWN":
            case 36:
                message.hwModel = 36;
                break;
            case "PORTDUINO":
            case 37:
                message.hwModel = 37;
                break;
            case "ANDROID_SIM":
            case 38:
                message.hwModel = 38;
                break;
            case "DIY_V1":
            case 39:
                message.hwModel = 39;
                break;
            case "NRF52840_PCA10059":
            case 40:
                message.hwModel = 40;
                break;
            case "DR_DEV":
            case 41:
                message.hwModel = 41;
                break;
            case "M5STACK":
            case 42:
                message.hwModel = 42;
                break;
            case "HELTEC_V3":
            case 43:
                message.hwModel = 43;
                break;
            case "HELTEC_WSL_V3":
            case 44:
                message.hwModel = 44;
                break;
            case "BETAFPV_2400_TX":
            case 45:
                message.hwModel = 45;
                break;
            case "BETAFPV_900_NANO_TX":
            case 46:
                message.hwModel = 46;
                break;
            case "RPI_PICO":
            case 47:
                message.hwModel = 47;
                break;
            case "HELTEC_WIRELESS_TRACKER":
            case 48:
                message.hwModel = 48;
                break;
            case "HELTEC_WIRELESS_PAPER":
            case 49:
                message.hwModel = 49;
                break;
            case "T_DECK":
            case 50:
                message.hwModel = 50;
                break;
            case "T_WATCH_S3":
            case 51:
                message.hwModel = 51;
                break;
            case "PICOMPUTER_S3":
            case 52:
                message.hwModel = 52;
                break;
            case "HELTEC_HT62":
            case 53:
                message.hwModel = 53;
                break;
            case "EBYTE_ESP32_S3":
            case 54:
                message.hwModel = 54;
                break;
            case "ESP32_S3_PICO":
            case 55:
                message.hwModel = 55;
                break;
            case "CHATTER_2":
            case 56:
                message.hwModel = 56;
                break;
            case "HELTEC_WIRELESS_PAPER_V1_0":
            case 57:
                message.hwModel = 57;
                break;
            case "HELTEC_WIRELESS_TRACKER_V1_0":
            case 58:
                message.hwModel = 58;
                break;
            case "UNPHONE":
            case 59:
                message.hwModel = 59;
                break;
            case "TD_LORAC":
            case 60:
                message.hwModel = 60;
                break;
            case "CDEBYTE_EORA_S3":
            case 61:
                message.hwModel = 61;
                break;
            case "TWC_MESH_V4":
            case 62:
                message.hwModel = 62;
                break;
            case "NRF52_PROMICRO_DIY":
            case 63:
                message.hwModel = 63;
                break;
            case "RADIOMASTER_900_BANDIT_NANO":
            case 64:
                message.hwModel = 64;
                break;
            case "HELTEC_CAPSULE_SENSOR_V3":
            case 65:
                message.hwModel = 65;
                break;
            case "HELTEC_VISION_MASTER_T190":
            case 66:
                message.hwModel = 66;
                break;
            case "HELTEC_VISION_MASTER_E213":
            case 67:
                message.hwModel = 67;
                break;
            case "HELTEC_VISION_MASTER_E290":
            case 68:
                message.hwModel = 68;
                break;
            case "HELTEC_MESH_NODE_T114":
            case 69:
                message.hwModel = 69;
                break;
            case "SENSECAP_INDICATOR":
            case 70:
                message.hwModel = 70;
                break;
            case "TRACKER_T1000_E":
            case 71:
                message.hwModel = 71;
                break;
            case "RAK3172":
            case 72:
                message.hwModel = 72;
                break;
            case "WIO_E5":
            case 73:
                message.hwModel = 73;
                break;
            case "RADIOMASTER_900_BANDIT":
            case 74:
                message.hwModel = 74;
                break;
            case "ME25LS01_4Y10TD":
            case 75:
                message.hwModel = 75;
                break;
            case "RP2040_FEATHER_RFM95":
            case 76:
                message.hwModel = 76;
                break;
            case "M5STACK_COREBASIC":
            case 77:
                message.hwModel = 77;
                break;
            case "M5STACK_CORE2":
            case 78:
                message.hwModel = 78;
                break;
            case "RPI_PICO2":
            case 79:
                message.hwModel = 79;
                break;
            case "M5STACK_CORES3":
            case 80:
                message.hwModel = 80;
                break;
            case "SEEED_XIAO_S3":
            case 81:
                message.hwModel = 81;
                break;
            case "MS24SF1":
            case 82:
                message.hwModel = 82;
                break;
            case "TLORA_C6":
            case 83:
                message.hwModel = 83;
                break;
            case "WISMESH_TAP":
            case 84:
                message.hwModel = 84;
                break;
            case "ROUTASTIC":
            case 85:
                message.hwModel = 85;
                break;
            case "MESH_TAB":
            case 86:
                message.hwModel = 86;
                break;
            case "MESHLINK":
            case 87:
                message.hwModel = 87;
                break;
            case "XIAO_NRF52_KIT":
            case 88:
                message.hwModel = 88;
                break;
            case "THINKNODE_M1":
            case 89:
                message.hwModel = 89;
                break;
            case "THINKNODE_M2":
            case 90:
                message.hwModel = 90;
                break;
            case "T_ETH_ELITE":
            case 91:
                message.hwModel = 91;
                break;
            case "HELTEC_SENSOR_HUB":
            case 92:
                message.hwModel = 92;
                break;
            case "RESERVED_FRIED_CHICKEN":
            case 93:
                message.hwModel = 93;
                break;
            case "HELTEC_MESH_POCKET":
            case 94:
                message.hwModel = 94;
                break;
            case "SEEED_SOLAR_NODE":
            case 95:
                message.hwModel = 95;
                break;
            case "NOMADSTAR_METEOR_PRO":
            case 96:
                message.hwModel = 96;
                break;
            case "CROWPANEL":
            case 97:
                message.hwModel = 97;
                break;
            case "LINK_32":
            case 98:
                message.hwModel = 98;
                break;
            case "SEEED_WIO_TRACKER_L1":
            case 99:
                message.hwModel = 99;
                break;
            case "SEEED_WIO_TRACKER_L1_EINK":
            case 100:
                message.hwModel = 100;
                break;
            case "MUZI_R1_NEO":
            case 101:
                message.hwModel = 101;
                break;
            case "T_DECK_PRO":
            case 102:
                message.hwModel = 102;
                break;
            case "T_LORA_PAGER":
            case 103:
                message.hwModel = 103;
                break;
            case "M5STACK_RESERVED":
            case 104:
                message.hwModel = 104;
                break;
            case "WISMESH_TAG":
            case 105:
                message.hwModel = 105;
                break;
            case "RAK3312":
            case 106:
                message.hwModel = 106;
                break;
            case "THINKNODE_M5":
            case 107:
                message.hwModel = 107;
                break;
            case "HELTEC_MESH_SOLAR":
            case 108:
                message.hwModel = 108;
                break;
            case "T_ECHO_LITE":
            case 109:
                message.hwModel = 109;
                break;
            case "HELTEC_V4":
            case 110:
                message.hwModel = 110;
                break;
            case "M5STACK_C6L":
            case 111:
                message.hwModel = 111;
                break;
            case "M5STACK_CARDPUTER_ADV":
            case 112:
                message.hwModel = 112;
                break;
            case "HELTEC_WIRELESS_TRACKER_V2":
            case 113:
                message.hwModel = 113;
                break;
            case "T_WATCH_ULTRA":
            case 114:
                message.hwModel = 114;
                break;
            case "THINKNODE_M3":
            case 115:
                message.hwModel = 115;
                break;
            case "WISMESH_TAP_V2":
            case 116:
                message.hwModel = 116;
                break;
            case "RAK3401":
            case 117:
                message.hwModel = 117;
                break;
            case "RAK6421":
            case 118:
                message.hwModel = 118;
                break;
            case "THINKNODE_M4":
            case 119:
                message.hwModel = 119;
                break;
            case "THINKNODE_M6":
            case 120:
                message.hwModel = 120;
                break;
            case "PRIVATE_HW":
            case 255:
                message.hwModel = 255;
                break;
            }
            if (object.hasRemoteHardware != null)
                message.hasRemoteHardware = Boolean(object.hasRemoteHardware);
            if (object.hasPKC != null)
                message.hasPKC = Boolean(object.hasPKC);
            if (object.excludedModules != null)
                message.excludedModules = object.excludedModules >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DeviceMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {meshtastic.DeviceMetadata} message DeviceMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.firmwareVersion = "";
                object.deviceStateVersion = 0;
                object.canShutdown = false;
                object.hasWifi = false;
                object.hasBluetooth = false;
                object.hasEthernet = false;
                object.role = options.enums === String ? "CLIENT" : 0;
                object.positionFlags = 0;
                object.hwModel = options.enums === String ? "UNSET" : 0;
                object.hasRemoteHardware = false;
                object.hasPKC = false;
                object.excludedModules = 0;
            }
            if (message.firmwareVersion != null && message.hasOwnProperty("firmwareVersion"))
                object.firmwareVersion = message.firmwareVersion;
            if (message.deviceStateVersion != null && message.hasOwnProperty("deviceStateVersion"))
                object.deviceStateVersion = message.deviceStateVersion;
            if (message.canShutdown != null && message.hasOwnProperty("canShutdown"))
                object.canShutdown = message.canShutdown;
            if (message.hasWifi != null && message.hasOwnProperty("hasWifi"))
                object.hasWifi = message.hasWifi;
            if (message.hasBluetooth != null && message.hasOwnProperty("hasBluetooth"))
                object.hasBluetooth = message.hasBluetooth;
            if (message.hasEthernet != null && message.hasOwnProperty("hasEthernet"))
                object.hasEthernet = message.hasEthernet;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = options.enums === String ? $root.meshtastic.Config.DeviceConfig.Role[message.role] === undefined ? message.role : $root.meshtastic.Config.DeviceConfig.Role[message.role] : message.role;
            if (message.positionFlags != null && message.hasOwnProperty("positionFlags"))
                object.positionFlags = message.positionFlags;
            if (message.hwModel != null && message.hasOwnProperty("hwModel"))
                object.hwModel = options.enums === String ? $root.meshtastic.HardwareModel[message.hwModel] === undefined ? message.hwModel : $root.meshtastic.HardwareModel[message.hwModel] : message.hwModel;
            if (message.hasRemoteHardware != null && message.hasOwnProperty("hasRemoteHardware"))
                object.hasRemoteHardware = message.hasRemoteHardware;
            if (message.hasPKC != null && message.hasOwnProperty("hasPKC"))
                object.hasPKC = message.hasPKC;
            if (message.excludedModules != null && message.hasOwnProperty("excludedModules"))
                object.excludedModules = message.excludedModules;
            return object;
        };

        /**
         * Converts this DeviceMetadata to JSON.
         * @function toJSON
         * @memberof meshtastic.DeviceMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeviceMetadata
         * @function getTypeUrl
         * @memberof meshtastic.DeviceMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeviceMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.DeviceMetadata";
        };

        return DeviceMetadata;
    })();

    /**
     * ExcludedModules enum.
     * @name meshtastic.ExcludedModules
     * @enum {number}
     * @property {number} EXCLUDED_NONE=0 EXCLUDED_NONE value
     * @property {number} MQTT_CONFIG=1 MQTT_CONFIG value
     * @property {number} SERIAL_CONFIG=2 SERIAL_CONFIG value
     * @property {number} EXTNOTIF_CONFIG=4 EXTNOTIF_CONFIG value
     * @property {number} STOREFORWARD_CONFIG=8 STOREFORWARD_CONFIG value
     * @property {number} RANGETEST_CONFIG=16 RANGETEST_CONFIG value
     * @property {number} TELEMETRY_CONFIG=32 TELEMETRY_CONFIG value
     * @property {number} CANNEDMSG_CONFIG=64 CANNEDMSG_CONFIG value
     * @property {number} AUDIO_CONFIG=128 AUDIO_CONFIG value
     * @property {number} REMOTEHARDWARE_CONFIG=256 REMOTEHARDWARE_CONFIG value
     * @property {number} NEIGHBORINFO_CONFIG=512 NEIGHBORINFO_CONFIG value
     * @property {number} AMBIENTLIGHTING_CONFIG=1024 AMBIENTLIGHTING_CONFIG value
     * @property {number} DETECTIONSENSOR_CONFIG=2048 DETECTIONSENSOR_CONFIG value
     * @property {number} PAXCOUNTER_CONFIG=4096 PAXCOUNTER_CONFIG value
     * @property {number} BLUETOOTH_CONFIG=8192 BLUETOOTH_CONFIG value
     * @property {number} NETWORK_CONFIG=16384 NETWORK_CONFIG value
     */
    meshtastic.ExcludedModules = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EXCLUDED_NONE"] = 0;
        values[valuesById[1] = "MQTT_CONFIG"] = 1;
        values[valuesById[2] = "SERIAL_CONFIG"] = 2;
        values[valuesById[4] = "EXTNOTIF_CONFIG"] = 4;
        values[valuesById[8] = "STOREFORWARD_CONFIG"] = 8;
        values[valuesById[16] = "RANGETEST_CONFIG"] = 16;
        values[valuesById[32] = "TELEMETRY_CONFIG"] = 32;
        values[valuesById[64] = "CANNEDMSG_CONFIG"] = 64;
        values[valuesById[128] = "AUDIO_CONFIG"] = 128;
        values[valuesById[256] = "REMOTEHARDWARE_CONFIG"] = 256;
        values[valuesById[512] = "NEIGHBORINFO_CONFIG"] = 512;
        values[valuesById[1024] = "AMBIENTLIGHTING_CONFIG"] = 1024;
        values[valuesById[2048] = "DETECTIONSENSOR_CONFIG"] = 2048;
        values[valuesById[4096] = "PAXCOUNTER_CONFIG"] = 4096;
        values[valuesById[8192] = "BLUETOOTH_CONFIG"] = 8192;
        values[valuesById[16384] = "NETWORK_CONFIG"] = 16384;
        return values;
    })();

    meshtastic.Heartbeat = (function() {

        /**
         * Properties of a Heartbeat.
         * @memberof meshtastic
         * @interface IHeartbeat
         * @property {number|null} [nonce] Heartbeat nonce
         */

        /**
         * Constructs a new Heartbeat.
         * @memberof meshtastic
         * @classdesc Represents a Heartbeat.
         * @implements IHeartbeat
         * @constructor
         * @param {meshtastic.IHeartbeat=} [properties] Properties to set
         */
        function Heartbeat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Heartbeat nonce.
         * @member {number} nonce
         * @memberof meshtastic.Heartbeat
         * @instance
         */
        Heartbeat.prototype.nonce = 0;

        /**
         * Creates a new Heartbeat instance using the specified properties.
         * @function create
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {meshtastic.IHeartbeat=} [properties] Properties to set
         * @returns {meshtastic.Heartbeat} Heartbeat instance
         */
        Heartbeat.create = function create(properties) {
            return new Heartbeat(properties);
        };

        /**
         * Encodes the specified Heartbeat message. Does not implicitly {@link meshtastic.Heartbeat.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {meshtastic.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nonce);
            return writer;
        };

        /**
         * Encodes the specified Heartbeat message, length delimited. Does not implicitly {@link meshtastic.Heartbeat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {meshtastic.IHeartbeat} message Heartbeat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Heartbeat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Heartbeat message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Heartbeat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nonce = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Heartbeat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Heartbeat} Heartbeat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Heartbeat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Heartbeat message.
         * @function verify
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Heartbeat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                if (!$util.isInteger(message.nonce))
                    return "nonce: integer expected";
            return null;
        };

        /**
         * Creates a Heartbeat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Heartbeat} Heartbeat
         */
        Heartbeat.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Heartbeat)
                return object;
            var message = new $root.meshtastic.Heartbeat();
            if (object.nonce != null)
                message.nonce = object.nonce >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Heartbeat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {meshtastic.Heartbeat} message Heartbeat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Heartbeat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.nonce = 0;
            if (message.nonce != null && message.hasOwnProperty("nonce"))
                object.nonce = message.nonce;
            return object;
        };

        /**
         * Converts this Heartbeat to JSON.
         * @function toJSON
         * @memberof meshtastic.Heartbeat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Heartbeat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Heartbeat
         * @function getTypeUrl
         * @memberof meshtastic.Heartbeat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Heartbeat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Heartbeat";
        };

        return Heartbeat;
    })();

    meshtastic.NodeRemoteHardwarePin = (function() {

        /**
         * Properties of a NodeRemoteHardwarePin.
         * @memberof meshtastic
         * @interface INodeRemoteHardwarePin
         * @property {number|null} [nodeNum] NodeRemoteHardwarePin nodeNum
         * @property {meshtastic.IRemoteHardwarePin|null} [pin] NodeRemoteHardwarePin pin
         */

        /**
         * Constructs a new NodeRemoteHardwarePin.
         * @memberof meshtastic
         * @classdesc Represents a NodeRemoteHardwarePin.
         * @implements INodeRemoteHardwarePin
         * @constructor
         * @param {meshtastic.INodeRemoteHardwarePin=} [properties] Properties to set
         */
        function NodeRemoteHardwarePin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeRemoteHardwarePin nodeNum.
         * @member {number} nodeNum
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @instance
         */
        NodeRemoteHardwarePin.prototype.nodeNum = 0;

        /**
         * NodeRemoteHardwarePin pin.
         * @member {meshtastic.IRemoteHardwarePin|null|undefined} pin
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @instance
         */
        NodeRemoteHardwarePin.prototype.pin = null;

        /**
         * Creates a new NodeRemoteHardwarePin instance using the specified properties.
         * @function create
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {meshtastic.INodeRemoteHardwarePin=} [properties] Properties to set
         * @returns {meshtastic.NodeRemoteHardwarePin} NodeRemoteHardwarePin instance
         */
        NodeRemoteHardwarePin.create = function create(properties) {
            return new NodeRemoteHardwarePin(properties);
        };

        /**
         * Encodes the specified NodeRemoteHardwarePin message. Does not implicitly {@link meshtastic.NodeRemoteHardwarePin.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {meshtastic.INodeRemoteHardwarePin} message NodeRemoteHardwarePin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeRemoteHardwarePin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeNum != null && Object.hasOwnProperty.call(message, "nodeNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nodeNum);
            if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                $root.meshtastic.RemoteHardwarePin.encode(message.pin, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeRemoteHardwarePin message, length delimited. Does not implicitly {@link meshtastic.NodeRemoteHardwarePin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {meshtastic.INodeRemoteHardwarePin} message NodeRemoteHardwarePin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeRemoteHardwarePin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeRemoteHardwarePin message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.NodeRemoteHardwarePin} NodeRemoteHardwarePin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeRemoteHardwarePin.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.NodeRemoteHardwarePin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.nodeNum = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pin = $root.meshtastic.RemoteHardwarePin.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeRemoteHardwarePin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.NodeRemoteHardwarePin} NodeRemoteHardwarePin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeRemoteHardwarePin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeRemoteHardwarePin message.
         * @function verify
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeRemoteHardwarePin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeNum != null && message.hasOwnProperty("nodeNum"))
                if (!$util.isInteger(message.nodeNum))
                    return "nodeNum: integer expected";
            if (message.pin != null && message.hasOwnProperty("pin")) {
                var error = $root.meshtastic.RemoteHardwarePin.verify(message.pin);
                if (error)
                    return "pin." + error;
            }
            return null;
        };

        /**
         * Creates a NodeRemoteHardwarePin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.NodeRemoteHardwarePin} NodeRemoteHardwarePin
         */
        NodeRemoteHardwarePin.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.NodeRemoteHardwarePin)
                return object;
            var message = new $root.meshtastic.NodeRemoteHardwarePin();
            if (object.nodeNum != null)
                message.nodeNum = object.nodeNum >>> 0;
            if (object.pin != null) {
                if (typeof object.pin !== "object")
                    throw TypeError(".meshtastic.NodeRemoteHardwarePin.pin: object expected");
                message.pin = $root.meshtastic.RemoteHardwarePin.fromObject(object.pin);
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeRemoteHardwarePin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {meshtastic.NodeRemoteHardwarePin} message NodeRemoteHardwarePin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeRemoteHardwarePin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.nodeNum = 0;
                object.pin = null;
            }
            if (message.nodeNum != null && message.hasOwnProperty("nodeNum"))
                object.nodeNum = message.nodeNum;
            if (message.pin != null && message.hasOwnProperty("pin"))
                object.pin = $root.meshtastic.RemoteHardwarePin.toObject(message.pin, options);
            return object;
        };

        /**
         * Converts this NodeRemoteHardwarePin to JSON.
         * @function toJSON
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeRemoteHardwarePin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NodeRemoteHardwarePin
         * @function getTypeUrl
         * @memberof meshtastic.NodeRemoteHardwarePin
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NodeRemoteHardwarePin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.NodeRemoteHardwarePin";
        };

        return NodeRemoteHardwarePin;
    })();

    meshtastic.ChunkedPayload = (function() {

        /**
         * Properties of a ChunkedPayload.
         * @memberof meshtastic
         * @interface IChunkedPayload
         * @property {number|null} [payloadId] ChunkedPayload payloadId
         * @property {number|null} [chunkCount] ChunkedPayload chunkCount
         * @property {number|null} [chunkIndex] ChunkedPayload chunkIndex
         * @property {Uint8Array|null} [payloadChunk] ChunkedPayload payloadChunk
         */

        /**
         * Constructs a new ChunkedPayload.
         * @memberof meshtastic
         * @classdesc Represents a ChunkedPayload.
         * @implements IChunkedPayload
         * @constructor
         * @param {meshtastic.IChunkedPayload=} [properties] Properties to set
         */
        function ChunkedPayload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkedPayload payloadId.
         * @member {number} payloadId
         * @memberof meshtastic.ChunkedPayload
         * @instance
         */
        ChunkedPayload.prototype.payloadId = 0;

        /**
         * ChunkedPayload chunkCount.
         * @member {number} chunkCount
         * @memberof meshtastic.ChunkedPayload
         * @instance
         */
        ChunkedPayload.prototype.chunkCount = 0;

        /**
         * ChunkedPayload chunkIndex.
         * @member {number} chunkIndex
         * @memberof meshtastic.ChunkedPayload
         * @instance
         */
        ChunkedPayload.prototype.chunkIndex = 0;

        /**
         * ChunkedPayload payloadChunk.
         * @member {Uint8Array} payloadChunk
         * @memberof meshtastic.ChunkedPayload
         * @instance
         */
        ChunkedPayload.prototype.payloadChunk = $util.newBuffer([]);

        /**
         * Creates a new ChunkedPayload instance using the specified properties.
         * @function create
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {meshtastic.IChunkedPayload=} [properties] Properties to set
         * @returns {meshtastic.ChunkedPayload} ChunkedPayload instance
         */
        ChunkedPayload.create = function create(properties) {
            return new ChunkedPayload(properties);
        };

        /**
         * Encodes the specified ChunkedPayload message. Does not implicitly {@link meshtastic.ChunkedPayload.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {meshtastic.IChunkedPayload} message ChunkedPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkedPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payloadId != null && Object.hasOwnProperty.call(message, "payloadId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.payloadId);
            if (message.chunkCount != null && Object.hasOwnProperty.call(message, "chunkCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.chunkCount);
            if (message.chunkIndex != null && Object.hasOwnProperty.call(message, "chunkIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.chunkIndex);
            if (message.payloadChunk != null && Object.hasOwnProperty.call(message, "payloadChunk"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.payloadChunk);
            return writer;
        };

        /**
         * Encodes the specified ChunkedPayload message, length delimited. Does not implicitly {@link meshtastic.ChunkedPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {meshtastic.IChunkedPayload} message ChunkedPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkedPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkedPayload message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ChunkedPayload} ChunkedPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkedPayload.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ChunkedPayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.payloadId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.chunkCount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.chunkIndex = reader.uint32();
                        break;
                    }
                case 4: {
                        message.payloadChunk = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkedPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ChunkedPayload} ChunkedPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkedPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkedPayload message.
         * @function verify
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkedPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payloadId != null && message.hasOwnProperty("payloadId"))
                if (!$util.isInteger(message.payloadId))
                    return "payloadId: integer expected";
            if (message.chunkCount != null && message.hasOwnProperty("chunkCount"))
                if (!$util.isInteger(message.chunkCount))
                    return "chunkCount: integer expected";
            if (message.chunkIndex != null && message.hasOwnProperty("chunkIndex"))
                if (!$util.isInteger(message.chunkIndex))
                    return "chunkIndex: integer expected";
            if (message.payloadChunk != null && message.hasOwnProperty("payloadChunk"))
                if (!(message.payloadChunk && typeof message.payloadChunk.length === "number" || $util.isString(message.payloadChunk)))
                    return "payloadChunk: buffer expected";
            return null;
        };

        /**
         * Creates a ChunkedPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ChunkedPayload} ChunkedPayload
         */
        ChunkedPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ChunkedPayload)
                return object;
            var message = new $root.meshtastic.ChunkedPayload();
            if (object.payloadId != null)
                message.payloadId = object.payloadId >>> 0;
            if (object.chunkCount != null)
                message.chunkCount = object.chunkCount >>> 0;
            if (object.chunkIndex != null)
                message.chunkIndex = object.chunkIndex >>> 0;
            if (object.payloadChunk != null)
                if (typeof object.payloadChunk === "string")
                    $util.base64.decode(object.payloadChunk, message.payloadChunk = $util.newBuffer($util.base64.length(object.payloadChunk)), 0);
                else if (object.payloadChunk.length >= 0)
                    message.payloadChunk = object.payloadChunk;
            return message;
        };

        /**
         * Creates a plain object from a ChunkedPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {meshtastic.ChunkedPayload} message ChunkedPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkedPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.payloadId = 0;
                object.chunkCount = 0;
                object.chunkIndex = 0;
                if (options.bytes === String)
                    object.payloadChunk = "";
                else {
                    object.payloadChunk = [];
                    if (options.bytes !== Array)
                        object.payloadChunk = $util.newBuffer(object.payloadChunk);
                }
            }
            if (message.payloadId != null && message.hasOwnProperty("payloadId"))
                object.payloadId = message.payloadId;
            if (message.chunkCount != null && message.hasOwnProperty("chunkCount"))
                object.chunkCount = message.chunkCount;
            if (message.chunkIndex != null && message.hasOwnProperty("chunkIndex"))
                object.chunkIndex = message.chunkIndex;
            if (message.payloadChunk != null && message.hasOwnProperty("payloadChunk"))
                object.payloadChunk = options.bytes === String ? $util.base64.encode(message.payloadChunk, 0, message.payloadChunk.length) : options.bytes === Array ? Array.prototype.slice.call(message.payloadChunk) : message.payloadChunk;
            return object;
        };

        /**
         * Converts this ChunkedPayload to JSON.
         * @function toJSON
         * @memberof meshtastic.ChunkedPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkedPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChunkedPayload
         * @function getTypeUrl
         * @memberof meshtastic.ChunkedPayload
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChunkedPayload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ChunkedPayload";
        };

        return ChunkedPayload;
    })();

    meshtastic.resend_chunks = (function() {

        /**
         * Properties of a resend_chunks.
         * @memberof meshtastic
         * @interface Iresend_chunks
         * @property {Array.<number>|null} [chunks] resend_chunks chunks
         */

        /**
         * Constructs a new resend_chunks.
         * @memberof meshtastic
         * @classdesc Represents a resend_chunks.
         * @implements Iresend_chunks
         * @constructor
         * @param {meshtastic.Iresend_chunks=} [properties] Properties to set
         */
        function resend_chunks(properties) {
            this.chunks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * resend_chunks chunks.
         * @member {Array.<number>} chunks
         * @memberof meshtastic.resend_chunks
         * @instance
         */
        resend_chunks.prototype.chunks = $util.emptyArray;

        /**
         * Creates a new resend_chunks instance using the specified properties.
         * @function create
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {meshtastic.Iresend_chunks=} [properties] Properties to set
         * @returns {meshtastic.resend_chunks} resend_chunks instance
         */
        resend_chunks.create = function create(properties) {
            return new resend_chunks(properties);
        };

        /**
         * Encodes the specified resend_chunks message. Does not implicitly {@link meshtastic.resend_chunks.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {meshtastic.Iresend_chunks} message resend_chunks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        resend_chunks.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chunks != null && message.chunks.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.chunks.length; ++i)
                    writer.uint32(message.chunks[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified resend_chunks message, length delimited. Does not implicitly {@link meshtastic.resend_chunks.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {meshtastic.Iresend_chunks} message resend_chunks message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        resend_chunks.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a resend_chunks message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.resend_chunks} resend_chunks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        resend_chunks.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.resend_chunks();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.chunks && message.chunks.length))
                            message.chunks = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.chunks.push(reader.uint32());
                        } else
                            message.chunks.push(reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a resend_chunks message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.resend_chunks} resend_chunks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        resend_chunks.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a resend_chunks message.
         * @function verify
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        resend_chunks.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chunks != null && message.hasOwnProperty("chunks")) {
                if (!Array.isArray(message.chunks))
                    return "chunks: array expected";
                for (var i = 0; i < message.chunks.length; ++i)
                    if (!$util.isInteger(message.chunks[i]))
                        return "chunks: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a resend_chunks message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.resend_chunks} resend_chunks
         */
        resend_chunks.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.resend_chunks)
                return object;
            var message = new $root.meshtastic.resend_chunks();
            if (object.chunks) {
                if (!Array.isArray(object.chunks))
                    throw TypeError(".meshtastic.resend_chunks.chunks: array expected");
                message.chunks = [];
                for (var i = 0; i < object.chunks.length; ++i)
                    message.chunks[i] = object.chunks[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a resend_chunks message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {meshtastic.resend_chunks} message resend_chunks
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        resend_chunks.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chunks = [];
            if (message.chunks && message.chunks.length) {
                object.chunks = [];
                for (var j = 0; j < message.chunks.length; ++j)
                    object.chunks[j] = message.chunks[j];
            }
            return object;
        };

        /**
         * Converts this resend_chunks to JSON.
         * @function toJSON
         * @memberof meshtastic.resend_chunks
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        resend_chunks.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for resend_chunks
         * @function getTypeUrl
         * @memberof meshtastic.resend_chunks
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        resend_chunks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.resend_chunks";
        };

        return resend_chunks;
    })();

    meshtastic.ChunkedPayloadResponse = (function() {

        /**
         * Properties of a ChunkedPayloadResponse.
         * @memberof meshtastic
         * @interface IChunkedPayloadResponse
         * @property {number|null} [payloadId] ChunkedPayloadResponse payloadId
         * @property {boolean|null} [requestTransfer] ChunkedPayloadResponse requestTransfer
         * @property {boolean|null} [acceptTransfer] ChunkedPayloadResponse acceptTransfer
         * @property {meshtastic.Iresend_chunks|null} [resendChunks] ChunkedPayloadResponse resendChunks
         */

        /**
         * Constructs a new ChunkedPayloadResponse.
         * @memberof meshtastic
         * @classdesc Represents a ChunkedPayloadResponse.
         * @implements IChunkedPayloadResponse
         * @constructor
         * @param {meshtastic.IChunkedPayloadResponse=} [properties] Properties to set
         */
        function ChunkedPayloadResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkedPayloadResponse payloadId.
         * @member {number} payloadId
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         */
        ChunkedPayloadResponse.prototype.payloadId = 0;

        /**
         * ChunkedPayloadResponse requestTransfer.
         * @member {boolean|null|undefined} requestTransfer
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         */
        ChunkedPayloadResponse.prototype.requestTransfer = null;

        /**
         * ChunkedPayloadResponse acceptTransfer.
         * @member {boolean|null|undefined} acceptTransfer
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         */
        ChunkedPayloadResponse.prototype.acceptTransfer = null;

        /**
         * ChunkedPayloadResponse resendChunks.
         * @member {meshtastic.Iresend_chunks|null|undefined} resendChunks
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         */
        ChunkedPayloadResponse.prototype.resendChunks = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ChunkedPayloadResponse payloadVariant.
         * @member {"requestTransfer"|"acceptTransfer"|"resendChunks"|undefined} payloadVariant
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         */
        Object.defineProperty(ChunkedPayloadResponse.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["requestTransfer", "acceptTransfer", "resendChunks"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChunkedPayloadResponse instance using the specified properties.
         * @function create
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {meshtastic.IChunkedPayloadResponse=} [properties] Properties to set
         * @returns {meshtastic.ChunkedPayloadResponse} ChunkedPayloadResponse instance
         */
        ChunkedPayloadResponse.create = function create(properties) {
            return new ChunkedPayloadResponse(properties);
        };

        /**
         * Encodes the specified ChunkedPayloadResponse message. Does not implicitly {@link meshtastic.ChunkedPayloadResponse.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {meshtastic.IChunkedPayloadResponse} message ChunkedPayloadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkedPayloadResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payloadId != null && Object.hasOwnProperty.call(message, "payloadId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.payloadId);
            if (message.requestTransfer != null && Object.hasOwnProperty.call(message, "requestTransfer"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.requestTransfer);
            if (message.acceptTransfer != null && Object.hasOwnProperty.call(message, "acceptTransfer"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.acceptTransfer);
            if (message.resendChunks != null && Object.hasOwnProperty.call(message, "resendChunks"))
                $root.meshtastic.resend_chunks.encode(message.resendChunks, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChunkedPayloadResponse message, length delimited. Does not implicitly {@link meshtastic.ChunkedPayloadResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {meshtastic.IChunkedPayloadResponse} message ChunkedPayloadResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkedPayloadResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkedPayloadResponse message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ChunkedPayloadResponse} ChunkedPayloadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkedPayloadResponse.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ChunkedPayloadResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.payloadId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.requestTransfer = reader.bool();
                        break;
                    }
                case 3: {
                        message.acceptTransfer = reader.bool();
                        break;
                    }
                case 4: {
                        message.resendChunks = $root.meshtastic.resend_chunks.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkedPayloadResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ChunkedPayloadResponse} ChunkedPayloadResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkedPayloadResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkedPayloadResponse message.
         * @function verify
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkedPayloadResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.payloadId != null && message.hasOwnProperty("payloadId"))
                if (!$util.isInteger(message.payloadId))
                    return "payloadId: integer expected";
            if (message.requestTransfer != null && message.hasOwnProperty("requestTransfer")) {
                properties.payloadVariant = 1;
                if (typeof message.requestTransfer !== "boolean")
                    return "requestTransfer: boolean expected";
            }
            if (message.acceptTransfer != null && message.hasOwnProperty("acceptTransfer")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                if (typeof message.acceptTransfer !== "boolean")
                    return "acceptTransfer: boolean expected";
            }
            if (message.resendChunks != null && message.hasOwnProperty("resendChunks")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.resend_chunks.verify(message.resendChunks);
                    if (error)
                        return "resendChunks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChunkedPayloadResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ChunkedPayloadResponse} ChunkedPayloadResponse
         */
        ChunkedPayloadResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ChunkedPayloadResponse)
                return object;
            var message = new $root.meshtastic.ChunkedPayloadResponse();
            if (object.payloadId != null)
                message.payloadId = object.payloadId >>> 0;
            if (object.requestTransfer != null)
                message.requestTransfer = Boolean(object.requestTransfer);
            if (object.acceptTransfer != null)
                message.acceptTransfer = Boolean(object.acceptTransfer);
            if (object.resendChunks != null) {
                if (typeof object.resendChunks !== "object")
                    throw TypeError(".meshtastic.ChunkedPayloadResponse.resendChunks: object expected");
                message.resendChunks = $root.meshtastic.resend_chunks.fromObject(object.resendChunks);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChunkedPayloadResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {meshtastic.ChunkedPayloadResponse} message ChunkedPayloadResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkedPayloadResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.payloadId = 0;
            if (message.payloadId != null && message.hasOwnProperty("payloadId"))
                object.payloadId = message.payloadId;
            if (message.requestTransfer != null && message.hasOwnProperty("requestTransfer")) {
                object.requestTransfer = message.requestTransfer;
                if (options.oneofs)
                    object.payloadVariant = "requestTransfer";
            }
            if (message.acceptTransfer != null && message.hasOwnProperty("acceptTransfer")) {
                object.acceptTransfer = message.acceptTransfer;
                if (options.oneofs)
                    object.payloadVariant = "acceptTransfer";
            }
            if (message.resendChunks != null && message.hasOwnProperty("resendChunks")) {
                object.resendChunks = $root.meshtastic.resend_chunks.toObject(message.resendChunks, options);
                if (options.oneofs)
                    object.payloadVariant = "resendChunks";
            }
            return object;
        };

        /**
         * Converts this ChunkedPayloadResponse to JSON.
         * @function toJSON
         * @memberof meshtastic.ChunkedPayloadResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkedPayloadResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChunkedPayloadResponse
         * @function getTypeUrl
         * @memberof meshtastic.ChunkedPayloadResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChunkedPayloadResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ChunkedPayloadResponse";
        };

        return ChunkedPayloadResponse;
    })();

    meshtastic.ChannelSettings = (function() {

        /**
         * Properties of a ChannelSettings.
         * @memberof meshtastic
         * @interface IChannelSettings
         * @property {number|null} [channelNum] ChannelSettings channelNum
         * @property {Uint8Array|null} [psk] ChannelSettings psk
         * @property {string|null} [name] ChannelSettings name
         * @property {number|null} [id] ChannelSettings id
         * @property {boolean|null} [uplinkEnabled] ChannelSettings uplinkEnabled
         * @property {boolean|null} [downlinkEnabled] ChannelSettings downlinkEnabled
         * @property {meshtastic.IModuleSettings|null} [moduleSettings] ChannelSettings moduleSettings
         */

        /**
         * Constructs a new ChannelSettings.
         * @memberof meshtastic
         * @classdesc Represents a ChannelSettings.
         * @implements IChannelSettings
         * @constructor
         * @param {meshtastic.IChannelSettings=} [properties] Properties to set
         */
        function ChannelSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelSettings channelNum.
         * @member {number} channelNum
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.channelNum = 0;

        /**
         * ChannelSettings psk.
         * @member {Uint8Array} psk
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.psk = $util.newBuffer([]);

        /**
         * ChannelSettings name.
         * @member {string} name
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.name = "";

        /**
         * ChannelSettings id.
         * @member {number} id
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.id = 0;

        /**
         * ChannelSettings uplinkEnabled.
         * @member {boolean} uplinkEnabled
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.uplinkEnabled = false;

        /**
         * ChannelSettings downlinkEnabled.
         * @member {boolean} downlinkEnabled
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.downlinkEnabled = false;

        /**
         * ChannelSettings moduleSettings.
         * @member {meshtastic.IModuleSettings|null|undefined} moduleSettings
         * @memberof meshtastic.ChannelSettings
         * @instance
         */
        ChannelSettings.prototype.moduleSettings = null;

        /**
         * Creates a new ChannelSettings instance using the specified properties.
         * @function create
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {meshtastic.IChannelSettings=} [properties] Properties to set
         * @returns {meshtastic.ChannelSettings} ChannelSettings instance
         */
        ChannelSettings.create = function create(properties) {
            return new ChannelSettings(properties);
        };

        /**
         * Encodes the specified ChannelSettings message. Does not implicitly {@link meshtastic.ChannelSettings.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {meshtastic.IChannelSettings} message ChannelSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelNum != null && Object.hasOwnProperty.call(message, "channelNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channelNum);
            if (message.psk != null && Object.hasOwnProperty.call(message, "psk"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.psk);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 4, wireType 5 =*/37).fixed32(message.id);
            if (message.uplinkEnabled != null && Object.hasOwnProperty.call(message, "uplinkEnabled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.uplinkEnabled);
            if (message.downlinkEnabled != null && Object.hasOwnProperty.call(message, "downlinkEnabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.downlinkEnabled);
            if (message.moduleSettings != null && Object.hasOwnProperty.call(message, "moduleSettings"))
                $root.meshtastic.ModuleSettings.encode(message.moduleSettings, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelSettings message, length delimited. Does not implicitly {@link meshtastic.ChannelSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {meshtastic.IChannelSettings} message ChannelSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelSettings message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ChannelSettings} ChannelSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelSettings.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ChannelSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.channelNum = reader.uint32();
                        break;
                    }
                case 2: {
                        message.psk = reader.bytes();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.id = reader.fixed32();
                        break;
                    }
                case 5: {
                        message.uplinkEnabled = reader.bool();
                        break;
                    }
                case 6: {
                        message.downlinkEnabled = reader.bool();
                        break;
                    }
                case 7: {
                        message.moduleSettings = $root.meshtastic.ModuleSettings.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ChannelSettings} ChannelSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelSettings message.
         * @function verify
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelNum != null && message.hasOwnProperty("channelNum"))
                if (!$util.isInteger(message.channelNum))
                    return "channelNum: integer expected";
            if (message.psk != null && message.hasOwnProperty("psk"))
                if (!(message.psk && typeof message.psk.length === "number" || $util.isString(message.psk)))
                    return "psk: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.uplinkEnabled != null && message.hasOwnProperty("uplinkEnabled"))
                if (typeof message.uplinkEnabled !== "boolean")
                    return "uplinkEnabled: boolean expected";
            if (message.downlinkEnabled != null && message.hasOwnProperty("downlinkEnabled"))
                if (typeof message.downlinkEnabled !== "boolean")
                    return "downlinkEnabled: boolean expected";
            if (message.moduleSettings != null && message.hasOwnProperty("moduleSettings")) {
                var error = $root.meshtastic.ModuleSettings.verify(message.moduleSettings);
                if (error)
                    return "moduleSettings." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ChannelSettings} ChannelSettings
         */
        ChannelSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ChannelSettings)
                return object;
            var message = new $root.meshtastic.ChannelSettings();
            if (object.channelNum != null)
                message.channelNum = object.channelNum >>> 0;
            if (object.psk != null)
                if (typeof object.psk === "string")
                    $util.base64.decode(object.psk, message.psk = $util.newBuffer($util.base64.length(object.psk)), 0);
                else if (object.psk.length >= 0)
                    message.psk = object.psk;
            if (object.name != null)
                message.name = String(object.name);
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.uplinkEnabled != null)
                message.uplinkEnabled = Boolean(object.uplinkEnabled);
            if (object.downlinkEnabled != null)
                message.downlinkEnabled = Boolean(object.downlinkEnabled);
            if (object.moduleSettings != null) {
                if (typeof object.moduleSettings !== "object")
                    throw TypeError(".meshtastic.ChannelSettings.moduleSettings: object expected");
                message.moduleSettings = $root.meshtastic.ModuleSettings.fromObject(object.moduleSettings);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {meshtastic.ChannelSettings} message ChannelSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.channelNum = 0;
                if (options.bytes === String)
                    object.psk = "";
                else {
                    object.psk = [];
                    if (options.bytes !== Array)
                        object.psk = $util.newBuffer(object.psk);
                }
                object.name = "";
                object.id = 0;
                object.uplinkEnabled = false;
                object.downlinkEnabled = false;
                object.moduleSettings = null;
            }
            if (message.channelNum != null && message.hasOwnProperty("channelNum"))
                object.channelNum = message.channelNum;
            if (message.psk != null && message.hasOwnProperty("psk"))
                object.psk = options.bytes === String ? $util.base64.encode(message.psk, 0, message.psk.length) : options.bytes === Array ? Array.prototype.slice.call(message.psk) : message.psk;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uplinkEnabled != null && message.hasOwnProperty("uplinkEnabled"))
                object.uplinkEnabled = message.uplinkEnabled;
            if (message.downlinkEnabled != null && message.hasOwnProperty("downlinkEnabled"))
                object.downlinkEnabled = message.downlinkEnabled;
            if (message.moduleSettings != null && message.hasOwnProperty("moduleSettings"))
                object.moduleSettings = $root.meshtastic.ModuleSettings.toObject(message.moduleSettings, options);
            return object;
        };

        /**
         * Converts this ChannelSettings to JSON.
         * @function toJSON
         * @memberof meshtastic.ChannelSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChannelSettings
         * @function getTypeUrl
         * @memberof meshtastic.ChannelSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChannelSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ChannelSettings";
        };

        return ChannelSettings;
    })();

    meshtastic.ModuleSettings = (function() {

        /**
         * Properties of a ModuleSettings.
         * @memberof meshtastic
         * @interface IModuleSettings
         * @property {number|null} [positionPrecision] ModuleSettings positionPrecision
         * @property {boolean|null} [isMuted] ModuleSettings isMuted
         */

        /**
         * Constructs a new ModuleSettings.
         * @memberof meshtastic
         * @classdesc Represents a ModuleSettings.
         * @implements IModuleSettings
         * @constructor
         * @param {meshtastic.IModuleSettings=} [properties] Properties to set
         */
        function ModuleSettings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModuleSettings positionPrecision.
         * @member {number} positionPrecision
         * @memberof meshtastic.ModuleSettings
         * @instance
         */
        ModuleSettings.prototype.positionPrecision = 0;

        /**
         * ModuleSettings isMuted.
         * @member {boolean} isMuted
         * @memberof meshtastic.ModuleSettings
         * @instance
         */
        ModuleSettings.prototype.isMuted = false;

        /**
         * Creates a new ModuleSettings instance using the specified properties.
         * @function create
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {meshtastic.IModuleSettings=} [properties] Properties to set
         * @returns {meshtastic.ModuleSettings} ModuleSettings instance
         */
        ModuleSettings.create = function create(properties) {
            return new ModuleSettings(properties);
        };

        /**
         * Encodes the specified ModuleSettings message. Does not implicitly {@link meshtastic.ModuleSettings.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {meshtastic.IModuleSettings} message ModuleSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.positionPrecision != null && Object.hasOwnProperty.call(message, "positionPrecision"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.positionPrecision);
            if (message.isMuted != null && Object.hasOwnProperty.call(message, "isMuted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isMuted);
            return writer;
        };

        /**
         * Encodes the specified ModuleSettings message, length delimited. Does not implicitly {@link meshtastic.ModuleSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {meshtastic.IModuleSettings} message ModuleSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModuleSettings message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ModuleSettings} ModuleSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleSettings.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleSettings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.positionPrecision = reader.uint32();
                        break;
                    }
                case 2: {
                        message.isMuted = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModuleSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ModuleSettings} ModuleSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModuleSettings message.
         * @function verify
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModuleSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                if (!$util.isInteger(message.positionPrecision))
                    return "positionPrecision: integer expected";
            if (message.isMuted != null && message.hasOwnProperty("isMuted"))
                if (typeof message.isMuted !== "boolean")
                    return "isMuted: boolean expected";
            return null;
        };

        /**
         * Creates a ModuleSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ModuleSettings} ModuleSettings
         */
        ModuleSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ModuleSettings)
                return object;
            var message = new $root.meshtastic.ModuleSettings();
            if (object.positionPrecision != null)
                message.positionPrecision = object.positionPrecision >>> 0;
            if (object.isMuted != null)
                message.isMuted = Boolean(object.isMuted);
            return message;
        };

        /**
         * Creates a plain object from a ModuleSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {meshtastic.ModuleSettings} message ModuleSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModuleSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.positionPrecision = 0;
                object.isMuted = false;
            }
            if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                object.positionPrecision = message.positionPrecision;
            if (message.isMuted != null && message.hasOwnProperty("isMuted"))
                object.isMuted = message.isMuted;
            return object;
        };

        /**
         * Converts this ModuleSettings to JSON.
         * @function toJSON
         * @memberof meshtastic.ModuleSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModuleSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ModuleSettings
         * @function getTypeUrl
         * @memberof meshtastic.ModuleSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ModuleSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ModuleSettings";
        };

        return ModuleSettings;
    })();

    meshtastic.Channel = (function() {

        /**
         * Properties of a Channel.
         * @memberof meshtastic
         * @interface IChannel
         * @property {number|null} [index] Channel index
         * @property {meshtastic.IChannelSettings|null} [settings] Channel settings
         * @property {meshtastic.Channel.Role|null} [role] Channel role
         */

        /**
         * Constructs a new Channel.
         * @memberof meshtastic
         * @classdesc Represents a Channel.
         * @implements IChannel
         * @constructor
         * @param {meshtastic.IChannel=} [properties] Properties to set
         */
        function Channel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Channel index.
         * @member {number} index
         * @memberof meshtastic.Channel
         * @instance
         */
        Channel.prototype.index = 0;

        /**
         * Channel settings.
         * @member {meshtastic.IChannelSettings|null|undefined} settings
         * @memberof meshtastic.Channel
         * @instance
         */
        Channel.prototype.settings = null;

        /**
         * Channel role.
         * @member {meshtastic.Channel.Role} role
         * @memberof meshtastic.Channel
         * @instance
         */
        Channel.prototype.role = 0;

        /**
         * Creates a new Channel instance using the specified properties.
         * @function create
         * @memberof meshtastic.Channel
         * @static
         * @param {meshtastic.IChannel=} [properties] Properties to set
         * @returns {meshtastic.Channel} Channel instance
         */
        Channel.create = function create(properties) {
            return new Channel(properties);
        };

        /**
         * Encodes the specified Channel message. Does not implicitly {@link meshtastic.Channel.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Channel
         * @static
         * @param {meshtastic.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.settings != null && Object.hasOwnProperty.call(message, "settings"))
                $root.meshtastic.ChannelSettings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.role);
            return writer;
        };

        /**
         * Encodes the specified Channel message, length delimited. Does not implicitly {@link meshtastic.Channel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Channel
         * @static
         * @param {meshtastic.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Channel message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Channel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.index = reader.int32();
                        break;
                    }
                case 2: {
                        message.settings = $root.meshtastic.ChannelSettings.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.role = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Channel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Channel message.
         * @function verify
         * @memberof meshtastic.Channel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Channel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.settings != null && message.hasOwnProperty("settings")) {
                var error = $root.meshtastic.ChannelSettings.verify(message.settings);
                if (error)
                    return "settings." + error;
            }
            if (message.role != null && message.hasOwnProperty("role"))
                switch (message.role) {
                default:
                    return "role: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Channel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Channel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Channel} Channel
         */
        Channel.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Channel)
                return object;
            var message = new $root.meshtastic.Channel();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.settings != null) {
                if (typeof object.settings !== "object")
                    throw TypeError(".meshtastic.Channel.settings: object expected");
                message.settings = $root.meshtastic.ChannelSettings.fromObject(object.settings);
            }
            switch (object.role) {
            default:
                if (typeof object.role === "number") {
                    message.role = object.role;
                    break;
                }
                break;
            case "DISABLED":
            case 0:
                message.role = 0;
                break;
            case "PRIMARY":
            case 1:
                message.role = 1;
                break;
            case "SECONDARY":
            case 2:
                message.role = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Channel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Channel
         * @static
         * @param {meshtastic.Channel} message Channel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Channel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.settings = null;
                object.role = options.enums === String ? "DISABLED" : 0;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.settings != null && message.hasOwnProperty("settings"))
                object.settings = $root.meshtastic.ChannelSettings.toObject(message.settings, options);
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = options.enums === String ? $root.meshtastic.Channel.Role[message.role] === undefined ? message.role : $root.meshtastic.Channel.Role[message.role] : message.role;
            return object;
        };

        /**
         * Converts this Channel to JSON.
         * @function toJSON
         * @memberof meshtastic.Channel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Channel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Channel
         * @function getTypeUrl
         * @memberof meshtastic.Channel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Channel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Channel";
        };

        /**
         * Role enum.
         * @name meshtastic.Channel.Role
         * @enum {number}
         * @property {number} DISABLED=0 DISABLED value
         * @property {number} PRIMARY=1 PRIMARY value
         * @property {number} SECONDARY=2 SECONDARY value
         */
        Channel.Role = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DISABLED"] = 0;
            values[valuesById[1] = "PRIMARY"] = 1;
            values[valuesById[2] = "SECONDARY"] = 2;
            return values;
        })();

        return Channel;
    })();

    meshtastic.ModuleConfig = (function() {

        /**
         * Properties of a ModuleConfig.
         * @memberof meshtastic
         * @interface IModuleConfig
         * @property {meshtastic.ModuleConfig.IMQTTConfig|null} [mqtt] ModuleConfig mqtt
         * @property {meshtastic.ModuleConfig.ISerialConfig|null} [serial] ModuleConfig serial
         * @property {meshtastic.ModuleConfig.IExternalNotificationConfig|null} [externalNotification] ModuleConfig externalNotification
         * @property {meshtastic.ModuleConfig.IStoreForwardConfig|null} [storeForward] ModuleConfig storeForward
         * @property {meshtastic.ModuleConfig.IRangeTestConfig|null} [rangeTest] ModuleConfig rangeTest
         * @property {meshtastic.ModuleConfig.ITelemetryConfig|null} [telemetry] ModuleConfig telemetry
         * @property {meshtastic.ModuleConfig.ICannedMessageConfig|null} [cannedMessage] ModuleConfig cannedMessage
         * @property {meshtastic.ModuleConfig.IAudioConfig|null} [audio] ModuleConfig audio
         * @property {meshtastic.ModuleConfig.IRemoteHardwareConfig|null} [remoteHardware] ModuleConfig remoteHardware
         * @property {meshtastic.ModuleConfig.INeighborInfoConfig|null} [neighborInfo] ModuleConfig neighborInfo
         * @property {meshtastic.ModuleConfig.IAmbientLightingConfig|null} [ambientLighting] ModuleConfig ambientLighting
         * @property {meshtastic.ModuleConfig.IDetectionSensorConfig|null} [detectionSensor] ModuleConfig detectionSensor
         * @property {meshtastic.ModuleConfig.IPaxcounterConfig|null} [paxcounter] ModuleConfig paxcounter
         */

        /**
         * Constructs a new ModuleConfig.
         * @memberof meshtastic
         * @classdesc Represents a ModuleConfig.
         * @implements IModuleConfig
         * @constructor
         * @param {meshtastic.IModuleConfig=} [properties] Properties to set
         */
        function ModuleConfig(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModuleConfig mqtt.
         * @member {meshtastic.ModuleConfig.IMQTTConfig|null|undefined} mqtt
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.mqtt = null;

        /**
         * ModuleConfig serial.
         * @member {meshtastic.ModuleConfig.ISerialConfig|null|undefined} serial
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.serial = null;

        /**
         * ModuleConfig externalNotification.
         * @member {meshtastic.ModuleConfig.IExternalNotificationConfig|null|undefined} externalNotification
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.externalNotification = null;

        /**
         * ModuleConfig storeForward.
         * @member {meshtastic.ModuleConfig.IStoreForwardConfig|null|undefined} storeForward
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.storeForward = null;

        /**
         * ModuleConfig rangeTest.
         * @member {meshtastic.ModuleConfig.IRangeTestConfig|null|undefined} rangeTest
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.rangeTest = null;

        /**
         * ModuleConfig telemetry.
         * @member {meshtastic.ModuleConfig.ITelemetryConfig|null|undefined} telemetry
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.telemetry = null;

        /**
         * ModuleConfig cannedMessage.
         * @member {meshtastic.ModuleConfig.ICannedMessageConfig|null|undefined} cannedMessage
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.cannedMessage = null;

        /**
         * ModuleConfig audio.
         * @member {meshtastic.ModuleConfig.IAudioConfig|null|undefined} audio
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.audio = null;

        /**
         * ModuleConfig remoteHardware.
         * @member {meshtastic.ModuleConfig.IRemoteHardwareConfig|null|undefined} remoteHardware
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.remoteHardware = null;

        /**
         * ModuleConfig neighborInfo.
         * @member {meshtastic.ModuleConfig.INeighborInfoConfig|null|undefined} neighborInfo
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.neighborInfo = null;

        /**
         * ModuleConfig ambientLighting.
         * @member {meshtastic.ModuleConfig.IAmbientLightingConfig|null|undefined} ambientLighting
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.ambientLighting = null;

        /**
         * ModuleConfig detectionSensor.
         * @member {meshtastic.ModuleConfig.IDetectionSensorConfig|null|undefined} detectionSensor
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.detectionSensor = null;

        /**
         * ModuleConfig paxcounter.
         * @member {meshtastic.ModuleConfig.IPaxcounterConfig|null|undefined} paxcounter
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        ModuleConfig.prototype.paxcounter = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ModuleConfig payloadVariant.
         * @member {"mqtt"|"serial"|"externalNotification"|"storeForward"|"rangeTest"|"telemetry"|"cannedMessage"|"audio"|"remoteHardware"|"neighborInfo"|"ambientLighting"|"detectionSensor"|"paxcounter"|undefined} payloadVariant
         * @memberof meshtastic.ModuleConfig
         * @instance
         */
        Object.defineProperty(ModuleConfig.prototype, "payloadVariant", {
            get: $util.oneOfGetter($oneOfFields = ["mqtt", "serial", "externalNotification", "storeForward", "rangeTest", "telemetry", "cannedMessage", "audio", "remoteHardware", "neighborInfo", "ambientLighting", "detectionSensor", "paxcounter"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ModuleConfig instance using the specified properties.
         * @function create
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {meshtastic.IModuleConfig=} [properties] Properties to set
         * @returns {meshtastic.ModuleConfig} ModuleConfig instance
         */
        ModuleConfig.create = function create(properties) {
            return new ModuleConfig(properties);
        };

        /**
         * Encodes the specified ModuleConfig message. Does not implicitly {@link meshtastic.ModuleConfig.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {meshtastic.IModuleConfig} message ModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mqtt != null && Object.hasOwnProperty.call(message, "mqtt"))
                $root.meshtastic.ModuleConfig.MQTTConfig.encode(message.mqtt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.serial != null && Object.hasOwnProperty.call(message, "serial"))
                $root.meshtastic.ModuleConfig.SerialConfig.encode(message.serial, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.externalNotification != null && Object.hasOwnProperty.call(message, "externalNotification"))
                $root.meshtastic.ModuleConfig.ExternalNotificationConfig.encode(message.externalNotification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.storeForward != null && Object.hasOwnProperty.call(message, "storeForward"))
                $root.meshtastic.ModuleConfig.StoreForwardConfig.encode(message.storeForward, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.rangeTest != null && Object.hasOwnProperty.call(message, "rangeTest"))
                $root.meshtastic.ModuleConfig.RangeTestConfig.encode(message.rangeTest, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.telemetry != null && Object.hasOwnProperty.call(message, "telemetry"))
                $root.meshtastic.ModuleConfig.TelemetryConfig.encode(message.telemetry, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.cannedMessage != null && Object.hasOwnProperty.call(message, "cannedMessage"))
                $root.meshtastic.ModuleConfig.CannedMessageConfig.encode(message.cannedMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                $root.meshtastic.ModuleConfig.AudioConfig.encode(message.audio, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.remoteHardware != null && Object.hasOwnProperty.call(message, "remoteHardware"))
                $root.meshtastic.ModuleConfig.RemoteHardwareConfig.encode(message.remoteHardware, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.neighborInfo != null && Object.hasOwnProperty.call(message, "neighborInfo"))
                $root.meshtastic.ModuleConfig.NeighborInfoConfig.encode(message.neighborInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.ambientLighting != null && Object.hasOwnProperty.call(message, "ambientLighting"))
                $root.meshtastic.ModuleConfig.AmbientLightingConfig.encode(message.ambientLighting, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.detectionSensor != null && Object.hasOwnProperty.call(message, "detectionSensor"))
                $root.meshtastic.ModuleConfig.DetectionSensorConfig.encode(message.detectionSensor, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.paxcounter != null && Object.hasOwnProperty.call(message, "paxcounter"))
                $root.meshtastic.ModuleConfig.PaxcounterConfig.encode(message.paxcounter, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ModuleConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {meshtastic.IModuleConfig} message ModuleConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModuleConfig message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.ModuleConfig} ModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleConfig.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.mqtt = $root.meshtastic.ModuleConfig.MQTTConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.serial = $root.meshtastic.ModuleConfig.SerialConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.externalNotification = $root.meshtastic.ModuleConfig.ExternalNotificationConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.storeForward = $root.meshtastic.ModuleConfig.StoreForwardConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.rangeTest = $root.meshtastic.ModuleConfig.RangeTestConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.telemetry = $root.meshtastic.ModuleConfig.TelemetryConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.cannedMessage = $root.meshtastic.ModuleConfig.CannedMessageConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.audio = $root.meshtastic.ModuleConfig.AudioConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.remoteHardware = $root.meshtastic.ModuleConfig.RemoteHardwareConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.neighborInfo = $root.meshtastic.ModuleConfig.NeighborInfoConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.ambientLighting = $root.meshtastic.ModuleConfig.AmbientLightingConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.detectionSensor = $root.meshtastic.ModuleConfig.DetectionSensorConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.paxcounter = $root.meshtastic.ModuleConfig.PaxcounterConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModuleConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.ModuleConfig} ModuleConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModuleConfig message.
         * @function verify
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModuleConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.MQTTConfig.verify(message.mqtt);
                    if (error)
                        return "mqtt." + error;
                }
            }
            if (message.serial != null && message.hasOwnProperty("serial")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.SerialConfig.verify(message.serial);
                    if (error)
                        return "serial." + error;
                }
            }
            if (message.externalNotification != null && message.hasOwnProperty("externalNotification")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.ExternalNotificationConfig.verify(message.externalNotification);
                    if (error)
                        return "externalNotification." + error;
                }
            }
            if (message.storeForward != null && message.hasOwnProperty("storeForward")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.StoreForwardConfig.verify(message.storeForward);
                    if (error)
                        return "storeForward." + error;
                }
            }
            if (message.rangeTest != null && message.hasOwnProperty("rangeTest")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.RangeTestConfig.verify(message.rangeTest);
                    if (error)
                        return "rangeTest." + error;
                }
            }
            if (message.telemetry != null && message.hasOwnProperty("telemetry")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.TelemetryConfig.verify(message.telemetry);
                    if (error)
                        return "telemetry." + error;
                }
            }
            if (message.cannedMessage != null && message.hasOwnProperty("cannedMessage")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.CannedMessageConfig.verify(message.cannedMessage);
                    if (error)
                        return "cannedMessage." + error;
                }
            }
            if (message.audio != null && message.hasOwnProperty("audio")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.AudioConfig.verify(message.audio);
                    if (error)
                        return "audio." + error;
                }
            }
            if (message.remoteHardware != null && message.hasOwnProperty("remoteHardware")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.RemoteHardwareConfig.verify(message.remoteHardware);
                    if (error)
                        return "remoteHardware." + error;
                }
            }
            if (message.neighborInfo != null && message.hasOwnProperty("neighborInfo")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.NeighborInfoConfig.verify(message.neighborInfo);
                    if (error)
                        return "neighborInfo." + error;
                }
            }
            if (message.ambientLighting != null && message.hasOwnProperty("ambientLighting")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.AmbientLightingConfig.verify(message.ambientLighting);
                    if (error)
                        return "ambientLighting." + error;
                }
            }
            if (message.detectionSensor != null && message.hasOwnProperty("detectionSensor")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.DetectionSensorConfig.verify(message.detectionSensor);
                    if (error)
                        return "detectionSensor." + error;
                }
            }
            if (message.paxcounter != null && message.hasOwnProperty("paxcounter")) {
                if (properties.payloadVariant === 1)
                    return "payloadVariant: multiple values";
                properties.payloadVariant = 1;
                {
                    var error = $root.meshtastic.ModuleConfig.PaxcounterConfig.verify(message.paxcounter);
                    if (error)
                        return "paxcounter." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ModuleConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.ModuleConfig} ModuleConfig
         */
        ModuleConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.ModuleConfig)
                return object;
            var message = new $root.meshtastic.ModuleConfig();
            if (object.mqtt != null) {
                if (typeof object.mqtt !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.mqtt: object expected");
                message.mqtt = $root.meshtastic.ModuleConfig.MQTTConfig.fromObject(object.mqtt);
            }
            if (object.serial != null) {
                if (typeof object.serial !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.serial: object expected");
                message.serial = $root.meshtastic.ModuleConfig.SerialConfig.fromObject(object.serial);
            }
            if (object.externalNotification != null) {
                if (typeof object.externalNotification !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.externalNotification: object expected");
                message.externalNotification = $root.meshtastic.ModuleConfig.ExternalNotificationConfig.fromObject(object.externalNotification);
            }
            if (object.storeForward != null) {
                if (typeof object.storeForward !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.storeForward: object expected");
                message.storeForward = $root.meshtastic.ModuleConfig.StoreForwardConfig.fromObject(object.storeForward);
            }
            if (object.rangeTest != null) {
                if (typeof object.rangeTest !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.rangeTest: object expected");
                message.rangeTest = $root.meshtastic.ModuleConfig.RangeTestConfig.fromObject(object.rangeTest);
            }
            if (object.telemetry != null) {
                if (typeof object.telemetry !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.telemetry: object expected");
                message.telemetry = $root.meshtastic.ModuleConfig.TelemetryConfig.fromObject(object.telemetry);
            }
            if (object.cannedMessage != null) {
                if (typeof object.cannedMessage !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.cannedMessage: object expected");
                message.cannedMessage = $root.meshtastic.ModuleConfig.CannedMessageConfig.fromObject(object.cannedMessage);
            }
            if (object.audio != null) {
                if (typeof object.audio !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.audio: object expected");
                message.audio = $root.meshtastic.ModuleConfig.AudioConfig.fromObject(object.audio);
            }
            if (object.remoteHardware != null) {
                if (typeof object.remoteHardware !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.remoteHardware: object expected");
                message.remoteHardware = $root.meshtastic.ModuleConfig.RemoteHardwareConfig.fromObject(object.remoteHardware);
            }
            if (object.neighborInfo != null) {
                if (typeof object.neighborInfo !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.neighborInfo: object expected");
                message.neighborInfo = $root.meshtastic.ModuleConfig.NeighborInfoConfig.fromObject(object.neighborInfo);
            }
            if (object.ambientLighting != null) {
                if (typeof object.ambientLighting !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.ambientLighting: object expected");
                message.ambientLighting = $root.meshtastic.ModuleConfig.AmbientLightingConfig.fromObject(object.ambientLighting);
            }
            if (object.detectionSensor != null) {
                if (typeof object.detectionSensor !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.detectionSensor: object expected");
                message.detectionSensor = $root.meshtastic.ModuleConfig.DetectionSensorConfig.fromObject(object.detectionSensor);
            }
            if (object.paxcounter != null) {
                if (typeof object.paxcounter !== "object")
                    throw TypeError(".meshtastic.ModuleConfig.paxcounter: object expected");
                message.paxcounter = $root.meshtastic.ModuleConfig.PaxcounterConfig.fromObject(object.paxcounter);
            }
            return message;
        };

        /**
         * Creates a plain object from a ModuleConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {meshtastic.ModuleConfig} message ModuleConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModuleConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.mqtt != null && message.hasOwnProperty("mqtt")) {
                object.mqtt = $root.meshtastic.ModuleConfig.MQTTConfig.toObject(message.mqtt, options);
                if (options.oneofs)
                    object.payloadVariant = "mqtt";
            }
            if (message.serial != null && message.hasOwnProperty("serial")) {
                object.serial = $root.meshtastic.ModuleConfig.SerialConfig.toObject(message.serial, options);
                if (options.oneofs)
                    object.payloadVariant = "serial";
            }
            if (message.externalNotification != null && message.hasOwnProperty("externalNotification")) {
                object.externalNotification = $root.meshtastic.ModuleConfig.ExternalNotificationConfig.toObject(message.externalNotification, options);
                if (options.oneofs)
                    object.payloadVariant = "externalNotification";
            }
            if (message.storeForward != null && message.hasOwnProperty("storeForward")) {
                object.storeForward = $root.meshtastic.ModuleConfig.StoreForwardConfig.toObject(message.storeForward, options);
                if (options.oneofs)
                    object.payloadVariant = "storeForward";
            }
            if (message.rangeTest != null && message.hasOwnProperty("rangeTest")) {
                object.rangeTest = $root.meshtastic.ModuleConfig.RangeTestConfig.toObject(message.rangeTest, options);
                if (options.oneofs)
                    object.payloadVariant = "rangeTest";
            }
            if (message.telemetry != null && message.hasOwnProperty("telemetry")) {
                object.telemetry = $root.meshtastic.ModuleConfig.TelemetryConfig.toObject(message.telemetry, options);
                if (options.oneofs)
                    object.payloadVariant = "telemetry";
            }
            if (message.cannedMessage != null && message.hasOwnProperty("cannedMessage")) {
                object.cannedMessage = $root.meshtastic.ModuleConfig.CannedMessageConfig.toObject(message.cannedMessage, options);
                if (options.oneofs)
                    object.payloadVariant = "cannedMessage";
            }
            if (message.audio != null && message.hasOwnProperty("audio")) {
                object.audio = $root.meshtastic.ModuleConfig.AudioConfig.toObject(message.audio, options);
                if (options.oneofs)
                    object.payloadVariant = "audio";
            }
            if (message.remoteHardware != null && message.hasOwnProperty("remoteHardware")) {
                object.remoteHardware = $root.meshtastic.ModuleConfig.RemoteHardwareConfig.toObject(message.remoteHardware, options);
                if (options.oneofs)
                    object.payloadVariant = "remoteHardware";
            }
            if (message.neighborInfo != null && message.hasOwnProperty("neighborInfo")) {
                object.neighborInfo = $root.meshtastic.ModuleConfig.NeighborInfoConfig.toObject(message.neighborInfo, options);
                if (options.oneofs)
                    object.payloadVariant = "neighborInfo";
            }
            if (message.ambientLighting != null && message.hasOwnProperty("ambientLighting")) {
                object.ambientLighting = $root.meshtastic.ModuleConfig.AmbientLightingConfig.toObject(message.ambientLighting, options);
                if (options.oneofs)
                    object.payloadVariant = "ambientLighting";
            }
            if (message.detectionSensor != null && message.hasOwnProperty("detectionSensor")) {
                object.detectionSensor = $root.meshtastic.ModuleConfig.DetectionSensorConfig.toObject(message.detectionSensor, options);
                if (options.oneofs)
                    object.payloadVariant = "detectionSensor";
            }
            if (message.paxcounter != null && message.hasOwnProperty("paxcounter")) {
                object.paxcounter = $root.meshtastic.ModuleConfig.PaxcounterConfig.toObject(message.paxcounter, options);
                if (options.oneofs)
                    object.payloadVariant = "paxcounter";
            }
            return object;
        };

        /**
         * Converts this ModuleConfig to JSON.
         * @function toJSON
         * @memberof meshtastic.ModuleConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModuleConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ModuleConfig
         * @function getTypeUrl
         * @memberof meshtastic.ModuleConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ModuleConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.ModuleConfig";
        };

        ModuleConfig.MQTTConfig = (function() {

            /**
             * Properties of a MQTTConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IMQTTConfig
             * @property {boolean|null} [enabled] MQTTConfig enabled
             * @property {string|null} [address] MQTTConfig address
             * @property {string|null} [username] MQTTConfig username
             * @property {string|null} [password] MQTTConfig password
             * @property {boolean|null} [encryptionEnabled] MQTTConfig encryptionEnabled
             * @property {boolean|null} [jsonEnabled] MQTTConfig jsonEnabled
             * @property {boolean|null} [tlsEnabled] MQTTConfig tlsEnabled
             * @property {string|null} [root] MQTTConfig root
             * @property {boolean|null} [proxyToClientEnabled] MQTTConfig proxyToClientEnabled
             * @property {boolean|null} [mapReportingEnabled] MQTTConfig mapReportingEnabled
             * @property {meshtastic.ModuleConfig.IMapReportSettings|null} [mapReportSettings] MQTTConfig mapReportSettings
             */

            /**
             * Constructs a new MQTTConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a MQTTConfig.
             * @implements IMQTTConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IMQTTConfig=} [properties] Properties to set
             */
            function MQTTConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MQTTConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.enabled = false;

            /**
             * MQTTConfig address.
             * @member {string} address
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.address = "";

            /**
             * MQTTConfig username.
             * @member {string} username
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.username = "";

            /**
             * MQTTConfig password.
             * @member {string} password
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.password = "";

            /**
             * MQTTConfig encryptionEnabled.
             * @member {boolean} encryptionEnabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.encryptionEnabled = false;

            /**
             * MQTTConfig jsonEnabled.
             * @member {boolean} jsonEnabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.jsonEnabled = false;

            /**
             * MQTTConfig tlsEnabled.
             * @member {boolean} tlsEnabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.tlsEnabled = false;

            /**
             * MQTTConfig root.
             * @member {string} root
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.root = "";

            /**
             * MQTTConfig proxyToClientEnabled.
             * @member {boolean} proxyToClientEnabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.proxyToClientEnabled = false;

            /**
             * MQTTConfig mapReportingEnabled.
             * @member {boolean} mapReportingEnabled
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.mapReportingEnabled = false;

            /**
             * MQTTConfig mapReportSettings.
             * @member {meshtastic.ModuleConfig.IMapReportSettings|null|undefined} mapReportSettings
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             */
            MQTTConfig.prototype.mapReportSettings = null;

            /**
             * Creates a new MQTTConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {meshtastic.ModuleConfig.IMQTTConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.MQTTConfig} MQTTConfig instance
             */
            MQTTConfig.create = function create(properties) {
                return new MQTTConfig(properties);
            };

            /**
             * Encodes the specified MQTTConfig message. Does not implicitly {@link meshtastic.ModuleConfig.MQTTConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {meshtastic.ModuleConfig.IMQTTConfig} message MQTTConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
                if (message.encryptionEnabled != null && Object.hasOwnProperty.call(message, "encryptionEnabled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.encryptionEnabled);
                if (message.jsonEnabled != null && Object.hasOwnProperty.call(message, "jsonEnabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.jsonEnabled);
                if (message.tlsEnabled != null && Object.hasOwnProperty.call(message, "tlsEnabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.tlsEnabled);
                if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.root);
                if (message.proxyToClientEnabled != null && Object.hasOwnProperty.call(message, "proxyToClientEnabled"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.proxyToClientEnabled);
                if (message.mapReportingEnabled != null && Object.hasOwnProperty.call(message, "mapReportingEnabled"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.mapReportingEnabled);
                if (message.mapReportSettings != null && Object.hasOwnProperty.call(message, "mapReportSettings"))
                    $root.meshtastic.ModuleConfig.MapReportSettings.encode(message.mapReportSettings, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MQTTConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.MQTTConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {meshtastic.ModuleConfig.IMQTTConfig} message MQTTConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MQTTConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MQTTConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.MQTTConfig} MQTTConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.MQTTConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.address = reader.string();
                            break;
                        }
                    case 3: {
                            message.username = reader.string();
                            break;
                        }
                    case 4: {
                            message.password = reader.string();
                            break;
                        }
                    case 5: {
                            message.encryptionEnabled = reader.bool();
                            break;
                        }
                    case 6: {
                            message.jsonEnabled = reader.bool();
                            break;
                        }
                    case 7: {
                            message.tlsEnabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.root = reader.string();
                            break;
                        }
                    case 9: {
                            message.proxyToClientEnabled = reader.bool();
                            break;
                        }
                    case 10: {
                            message.mapReportingEnabled = reader.bool();
                            break;
                        }
                    case 11: {
                            message.mapReportSettings = $root.meshtastic.ModuleConfig.MapReportSettings.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MQTTConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.MQTTConfig} MQTTConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MQTTConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MQTTConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MQTTConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.encryptionEnabled != null && message.hasOwnProperty("encryptionEnabled"))
                    if (typeof message.encryptionEnabled !== "boolean")
                        return "encryptionEnabled: boolean expected";
                if (message.jsonEnabled != null && message.hasOwnProperty("jsonEnabled"))
                    if (typeof message.jsonEnabled !== "boolean")
                        return "jsonEnabled: boolean expected";
                if (message.tlsEnabled != null && message.hasOwnProperty("tlsEnabled"))
                    if (typeof message.tlsEnabled !== "boolean")
                        return "tlsEnabled: boolean expected";
                if (message.root != null && message.hasOwnProperty("root"))
                    if (!$util.isString(message.root))
                        return "root: string expected";
                if (message.proxyToClientEnabled != null && message.hasOwnProperty("proxyToClientEnabled"))
                    if (typeof message.proxyToClientEnabled !== "boolean")
                        return "proxyToClientEnabled: boolean expected";
                if (message.mapReportingEnabled != null && message.hasOwnProperty("mapReportingEnabled"))
                    if (typeof message.mapReportingEnabled !== "boolean")
                        return "mapReportingEnabled: boolean expected";
                if (message.mapReportSettings != null && message.hasOwnProperty("mapReportSettings")) {
                    var error = $root.meshtastic.ModuleConfig.MapReportSettings.verify(message.mapReportSettings);
                    if (error)
                        return "mapReportSettings." + error;
                }
                return null;
            };

            /**
             * Creates a MQTTConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.MQTTConfig} MQTTConfig
             */
            MQTTConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.MQTTConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.MQTTConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.address != null)
                    message.address = String(object.address);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.encryptionEnabled != null)
                    message.encryptionEnabled = Boolean(object.encryptionEnabled);
                if (object.jsonEnabled != null)
                    message.jsonEnabled = Boolean(object.jsonEnabled);
                if (object.tlsEnabled != null)
                    message.tlsEnabled = Boolean(object.tlsEnabled);
                if (object.root != null)
                    message.root = String(object.root);
                if (object.proxyToClientEnabled != null)
                    message.proxyToClientEnabled = Boolean(object.proxyToClientEnabled);
                if (object.mapReportingEnabled != null)
                    message.mapReportingEnabled = Boolean(object.mapReportingEnabled);
                if (object.mapReportSettings != null) {
                    if (typeof object.mapReportSettings !== "object")
                        throw TypeError(".meshtastic.ModuleConfig.MQTTConfig.mapReportSettings: object expected");
                    message.mapReportSettings = $root.meshtastic.ModuleConfig.MapReportSettings.fromObject(object.mapReportSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a MQTTConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {meshtastic.ModuleConfig.MQTTConfig} message MQTTConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MQTTConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.address = "";
                    object.username = "";
                    object.password = "";
                    object.encryptionEnabled = false;
                    object.jsonEnabled = false;
                    object.tlsEnabled = false;
                    object.root = "";
                    object.proxyToClientEnabled = false;
                    object.mapReportingEnabled = false;
                    object.mapReportSettings = null;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.encryptionEnabled != null && message.hasOwnProperty("encryptionEnabled"))
                    object.encryptionEnabled = message.encryptionEnabled;
                if (message.jsonEnabled != null && message.hasOwnProperty("jsonEnabled"))
                    object.jsonEnabled = message.jsonEnabled;
                if (message.tlsEnabled != null && message.hasOwnProperty("tlsEnabled"))
                    object.tlsEnabled = message.tlsEnabled;
                if (message.root != null && message.hasOwnProperty("root"))
                    object.root = message.root;
                if (message.proxyToClientEnabled != null && message.hasOwnProperty("proxyToClientEnabled"))
                    object.proxyToClientEnabled = message.proxyToClientEnabled;
                if (message.mapReportingEnabled != null && message.hasOwnProperty("mapReportingEnabled"))
                    object.mapReportingEnabled = message.mapReportingEnabled;
                if (message.mapReportSettings != null && message.hasOwnProperty("mapReportSettings"))
                    object.mapReportSettings = $root.meshtastic.ModuleConfig.MapReportSettings.toObject(message.mapReportSettings, options);
                return object;
            };

            /**
             * Converts this MQTTConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MQTTConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MQTTConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.MQTTConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MQTTConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.MQTTConfig";
            };

            return MQTTConfig;
        })();

        ModuleConfig.MapReportSettings = (function() {

            /**
             * Properties of a MapReportSettings.
             * @memberof meshtastic.ModuleConfig
             * @interface IMapReportSettings
             * @property {number|null} [publishIntervalSecs] MapReportSettings publishIntervalSecs
             * @property {number|null} [positionPrecision] MapReportSettings positionPrecision
             * @property {boolean|null} [shouldReportLocation] MapReportSettings shouldReportLocation
             */

            /**
             * Constructs a new MapReportSettings.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a MapReportSettings.
             * @implements IMapReportSettings
             * @constructor
             * @param {meshtastic.ModuleConfig.IMapReportSettings=} [properties] Properties to set
             */
            function MapReportSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MapReportSettings publishIntervalSecs.
             * @member {number} publishIntervalSecs
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @instance
             */
            MapReportSettings.prototype.publishIntervalSecs = 0;

            /**
             * MapReportSettings positionPrecision.
             * @member {number} positionPrecision
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @instance
             */
            MapReportSettings.prototype.positionPrecision = 0;

            /**
             * MapReportSettings shouldReportLocation.
             * @member {boolean} shouldReportLocation
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @instance
             */
            MapReportSettings.prototype.shouldReportLocation = false;

            /**
             * Creates a new MapReportSettings instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {meshtastic.ModuleConfig.IMapReportSettings=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.MapReportSettings} MapReportSettings instance
             */
            MapReportSettings.create = function create(properties) {
                return new MapReportSettings(properties);
            };

            /**
             * Encodes the specified MapReportSettings message. Does not implicitly {@link meshtastic.ModuleConfig.MapReportSettings.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {meshtastic.ModuleConfig.IMapReportSettings} message MapReportSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MapReportSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publishIntervalSecs != null && Object.hasOwnProperty.call(message, "publishIntervalSecs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.publishIntervalSecs);
                if (message.positionPrecision != null && Object.hasOwnProperty.call(message, "positionPrecision"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.positionPrecision);
                if (message.shouldReportLocation != null && Object.hasOwnProperty.call(message, "shouldReportLocation"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.shouldReportLocation);
                return writer;
            };

            /**
             * Encodes the specified MapReportSettings message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.MapReportSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {meshtastic.ModuleConfig.IMapReportSettings} message MapReportSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MapReportSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MapReportSettings message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.MapReportSettings} MapReportSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MapReportSettings.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.MapReportSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.publishIntervalSecs = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.positionPrecision = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.shouldReportLocation = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MapReportSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.MapReportSettings} MapReportSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MapReportSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MapReportSettings message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MapReportSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publishIntervalSecs != null && message.hasOwnProperty("publishIntervalSecs"))
                    if (!$util.isInteger(message.publishIntervalSecs))
                        return "publishIntervalSecs: integer expected";
                if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                    if (!$util.isInteger(message.positionPrecision))
                        return "positionPrecision: integer expected";
                if (message.shouldReportLocation != null && message.hasOwnProperty("shouldReportLocation"))
                    if (typeof message.shouldReportLocation !== "boolean")
                        return "shouldReportLocation: boolean expected";
                return null;
            };

            /**
             * Creates a MapReportSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.MapReportSettings} MapReportSettings
             */
            MapReportSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.MapReportSettings)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.MapReportSettings();
                if (object.publishIntervalSecs != null)
                    message.publishIntervalSecs = object.publishIntervalSecs >>> 0;
                if (object.positionPrecision != null)
                    message.positionPrecision = object.positionPrecision >>> 0;
                if (object.shouldReportLocation != null)
                    message.shouldReportLocation = Boolean(object.shouldReportLocation);
                return message;
            };

            /**
             * Creates a plain object from a MapReportSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {meshtastic.ModuleConfig.MapReportSettings} message MapReportSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MapReportSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.publishIntervalSecs = 0;
                    object.positionPrecision = 0;
                    object.shouldReportLocation = false;
                }
                if (message.publishIntervalSecs != null && message.hasOwnProperty("publishIntervalSecs"))
                    object.publishIntervalSecs = message.publishIntervalSecs;
                if (message.positionPrecision != null && message.hasOwnProperty("positionPrecision"))
                    object.positionPrecision = message.positionPrecision;
                if (message.shouldReportLocation != null && message.hasOwnProperty("shouldReportLocation"))
                    object.shouldReportLocation = message.shouldReportLocation;
                return object;
            };

            /**
             * Converts this MapReportSettings to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MapReportSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MapReportSettings
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.MapReportSettings
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MapReportSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.MapReportSettings";
            };

            return MapReportSettings;
        })();

        ModuleConfig.RemoteHardwareConfig = (function() {

            /**
             * Properties of a RemoteHardwareConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IRemoteHardwareConfig
             * @property {boolean|null} [enabled] RemoteHardwareConfig enabled
             * @property {boolean|null} [allowUndefinedPinAccess] RemoteHardwareConfig allowUndefinedPinAccess
             * @property {Array.<meshtastic.IRemoteHardwarePin>|null} [availablePins] RemoteHardwareConfig availablePins
             */

            /**
             * Constructs a new RemoteHardwareConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a RemoteHardwareConfig.
             * @implements IRemoteHardwareConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IRemoteHardwareConfig=} [properties] Properties to set
             */
            function RemoteHardwareConfig(properties) {
                this.availablePins = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoteHardwareConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @instance
             */
            RemoteHardwareConfig.prototype.enabled = false;

            /**
             * RemoteHardwareConfig allowUndefinedPinAccess.
             * @member {boolean} allowUndefinedPinAccess
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @instance
             */
            RemoteHardwareConfig.prototype.allowUndefinedPinAccess = false;

            /**
             * RemoteHardwareConfig availablePins.
             * @member {Array.<meshtastic.IRemoteHardwarePin>} availablePins
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @instance
             */
            RemoteHardwareConfig.prototype.availablePins = $util.emptyArray;

            /**
             * Creates a new RemoteHardwareConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRemoteHardwareConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.RemoteHardwareConfig} RemoteHardwareConfig instance
             */
            RemoteHardwareConfig.create = function create(properties) {
                return new RemoteHardwareConfig(properties);
            };

            /**
             * Encodes the specified RemoteHardwareConfig message. Does not implicitly {@link meshtastic.ModuleConfig.RemoteHardwareConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRemoteHardwareConfig} message RemoteHardwareConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteHardwareConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.allowUndefinedPinAccess != null && Object.hasOwnProperty.call(message, "allowUndefinedPinAccess"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowUndefinedPinAccess);
                if (message.availablePins != null && message.availablePins.length)
                    for (var i = 0; i < message.availablePins.length; ++i)
                        $root.meshtastic.RemoteHardwarePin.encode(message.availablePins[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RemoteHardwareConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.RemoteHardwareConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRemoteHardwareConfig} message RemoteHardwareConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoteHardwareConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoteHardwareConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.RemoteHardwareConfig} RemoteHardwareConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteHardwareConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.RemoteHardwareConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.allowUndefinedPinAccess = reader.bool();
                            break;
                        }
                    case 3: {
                            if (!(message.availablePins && message.availablePins.length))
                                message.availablePins = [];
                            message.availablePins.push($root.meshtastic.RemoteHardwarePin.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoteHardwareConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.RemoteHardwareConfig} RemoteHardwareConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoteHardwareConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoteHardwareConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoteHardwareConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.allowUndefinedPinAccess != null && message.hasOwnProperty("allowUndefinedPinAccess"))
                    if (typeof message.allowUndefinedPinAccess !== "boolean")
                        return "allowUndefinedPinAccess: boolean expected";
                if (message.availablePins != null && message.hasOwnProperty("availablePins")) {
                    if (!Array.isArray(message.availablePins))
                        return "availablePins: array expected";
                    for (var i = 0; i < message.availablePins.length; ++i) {
                        var error = $root.meshtastic.RemoteHardwarePin.verify(message.availablePins[i]);
                        if (error)
                            return "availablePins." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RemoteHardwareConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.RemoteHardwareConfig} RemoteHardwareConfig
             */
            RemoteHardwareConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.RemoteHardwareConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.RemoteHardwareConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.allowUndefinedPinAccess != null)
                    message.allowUndefinedPinAccess = Boolean(object.allowUndefinedPinAccess);
                if (object.availablePins) {
                    if (!Array.isArray(object.availablePins))
                        throw TypeError(".meshtastic.ModuleConfig.RemoteHardwareConfig.availablePins: array expected");
                    message.availablePins = [];
                    for (var i = 0; i < object.availablePins.length; ++i) {
                        if (typeof object.availablePins[i] !== "object")
                            throw TypeError(".meshtastic.ModuleConfig.RemoteHardwareConfig.availablePins: object expected");
                        message.availablePins[i] = $root.meshtastic.RemoteHardwarePin.fromObject(object.availablePins[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a RemoteHardwareConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {meshtastic.ModuleConfig.RemoteHardwareConfig} message RemoteHardwareConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoteHardwareConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.availablePins = [];
                if (options.defaults) {
                    object.enabled = false;
                    object.allowUndefinedPinAccess = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.allowUndefinedPinAccess != null && message.hasOwnProperty("allowUndefinedPinAccess"))
                    object.allowUndefinedPinAccess = message.allowUndefinedPinAccess;
                if (message.availablePins && message.availablePins.length) {
                    object.availablePins = [];
                    for (var j = 0; j < message.availablePins.length; ++j)
                        object.availablePins[j] = $root.meshtastic.RemoteHardwarePin.toObject(message.availablePins[j], options);
                }
                return object;
            };

            /**
             * Converts this RemoteHardwareConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoteHardwareConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RemoteHardwareConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.RemoteHardwareConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RemoteHardwareConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.RemoteHardwareConfig";
            };

            return RemoteHardwareConfig;
        })();

        ModuleConfig.NeighborInfoConfig = (function() {

            /**
             * Properties of a NeighborInfoConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface INeighborInfoConfig
             * @property {boolean|null} [enabled] NeighborInfoConfig enabled
             * @property {number|null} [updateInterval] NeighborInfoConfig updateInterval
             * @property {boolean|null} [transmitOverLora] NeighborInfoConfig transmitOverLora
             */

            /**
             * Constructs a new NeighborInfoConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a NeighborInfoConfig.
             * @implements INeighborInfoConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.INeighborInfoConfig=} [properties] Properties to set
             */
            function NeighborInfoConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NeighborInfoConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @instance
             */
            NeighborInfoConfig.prototype.enabled = false;

            /**
             * NeighborInfoConfig updateInterval.
             * @member {number} updateInterval
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @instance
             */
            NeighborInfoConfig.prototype.updateInterval = 0;

            /**
             * NeighborInfoConfig transmitOverLora.
             * @member {boolean} transmitOverLora
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @instance
             */
            NeighborInfoConfig.prototype.transmitOverLora = false;

            /**
             * Creates a new NeighborInfoConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {meshtastic.ModuleConfig.INeighborInfoConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.NeighborInfoConfig} NeighborInfoConfig instance
             */
            NeighborInfoConfig.create = function create(properties) {
                return new NeighborInfoConfig(properties);
            };

            /**
             * Encodes the specified NeighborInfoConfig message. Does not implicitly {@link meshtastic.ModuleConfig.NeighborInfoConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {meshtastic.ModuleConfig.INeighborInfoConfig} message NeighborInfoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NeighborInfoConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.updateInterval != null && Object.hasOwnProperty.call(message, "updateInterval"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.updateInterval);
                if (message.transmitOverLora != null && Object.hasOwnProperty.call(message, "transmitOverLora"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.transmitOverLora);
                return writer;
            };

            /**
             * Encodes the specified NeighborInfoConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.NeighborInfoConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {meshtastic.ModuleConfig.INeighborInfoConfig} message NeighborInfoConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NeighborInfoConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NeighborInfoConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.NeighborInfoConfig} NeighborInfoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NeighborInfoConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.NeighborInfoConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.updateInterval = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.transmitOverLora = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NeighborInfoConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.NeighborInfoConfig} NeighborInfoConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NeighborInfoConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NeighborInfoConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NeighborInfoConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.updateInterval != null && message.hasOwnProperty("updateInterval"))
                    if (!$util.isInteger(message.updateInterval))
                        return "updateInterval: integer expected";
                if (message.transmitOverLora != null && message.hasOwnProperty("transmitOverLora"))
                    if (typeof message.transmitOverLora !== "boolean")
                        return "transmitOverLora: boolean expected";
                return null;
            };

            /**
             * Creates a NeighborInfoConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.NeighborInfoConfig} NeighborInfoConfig
             */
            NeighborInfoConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.NeighborInfoConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.NeighborInfoConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.updateInterval != null)
                    message.updateInterval = object.updateInterval >>> 0;
                if (object.transmitOverLora != null)
                    message.transmitOverLora = Boolean(object.transmitOverLora);
                return message;
            };

            /**
             * Creates a plain object from a NeighborInfoConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {meshtastic.ModuleConfig.NeighborInfoConfig} message NeighborInfoConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NeighborInfoConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.updateInterval = 0;
                    object.transmitOverLora = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.updateInterval != null && message.hasOwnProperty("updateInterval"))
                    object.updateInterval = message.updateInterval;
                if (message.transmitOverLora != null && message.hasOwnProperty("transmitOverLora"))
                    object.transmitOverLora = message.transmitOverLora;
                return object;
            };

            /**
             * Converts this NeighborInfoConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NeighborInfoConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NeighborInfoConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.NeighborInfoConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NeighborInfoConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.NeighborInfoConfig";
            };

            return NeighborInfoConfig;
        })();

        ModuleConfig.DetectionSensorConfig = (function() {

            /**
             * Properties of a DetectionSensorConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IDetectionSensorConfig
             * @property {boolean|null} [enabled] DetectionSensorConfig enabled
             * @property {number|null} [minimumBroadcastSecs] DetectionSensorConfig minimumBroadcastSecs
             * @property {number|null} [stateBroadcastSecs] DetectionSensorConfig stateBroadcastSecs
             * @property {boolean|null} [sendBell] DetectionSensorConfig sendBell
             * @property {string|null} [name] DetectionSensorConfig name
             * @property {number|null} [monitorPin] DetectionSensorConfig monitorPin
             * @property {meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType|null} [detectionTriggerType] DetectionSensorConfig detectionTriggerType
             * @property {boolean|null} [usePullup] DetectionSensorConfig usePullup
             */

            /**
             * Constructs a new DetectionSensorConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a DetectionSensorConfig.
             * @implements IDetectionSensorConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IDetectionSensorConfig=} [properties] Properties to set
             */
            function DetectionSensorConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DetectionSensorConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.enabled = false;

            /**
             * DetectionSensorConfig minimumBroadcastSecs.
             * @member {number} minimumBroadcastSecs
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.minimumBroadcastSecs = 0;

            /**
             * DetectionSensorConfig stateBroadcastSecs.
             * @member {number} stateBroadcastSecs
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.stateBroadcastSecs = 0;

            /**
             * DetectionSensorConfig sendBell.
             * @member {boolean} sendBell
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.sendBell = false;

            /**
             * DetectionSensorConfig name.
             * @member {string} name
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.name = "";

            /**
             * DetectionSensorConfig monitorPin.
             * @member {number} monitorPin
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.monitorPin = 0;

            /**
             * DetectionSensorConfig detectionTriggerType.
             * @member {meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType} detectionTriggerType
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.detectionTriggerType = 0;

            /**
             * DetectionSensorConfig usePullup.
             * @member {boolean} usePullup
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             */
            DetectionSensorConfig.prototype.usePullup = false;

            /**
             * Creates a new DetectionSensorConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {meshtastic.ModuleConfig.IDetectionSensorConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.DetectionSensorConfig} DetectionSensorConfig instance
             */
            DetectionSensorConfig.create = function create(properties) {
                return new DetectionSensorConfig(properties);
            };

            /**
             * Encodes the specified DetectionSensorConfig message. Does not implicitly {@link meshtastic.ModuleConfig.DetectionSensorConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {meshtastic.ModuleConfig.IDetectionSensorConfig} message DetectionSensorConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DetectionSensorConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.minimumBroadcastSecs != null && Object.hasOwnProperty.call(message, "minimumBroadcastSecs"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.minimumBroadcastSecs);
                if (message.stateBroadcastSecs != null && Object.hasOwnProperty.call(message, "stateBroadcastSecs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.stateBroadcastSecs);
                if (message.sendBell != null && Object.hasOwnProperty.call(message, "sendBell"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.sendBell);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
                if (message.monitorPin != null && Object.hasOwnProperty.call(message, "monitorPin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.monitorPin);
                if (message.detectionTriggerType != null && Object.hasOwnProperty.call(message, "detectionTriggerType"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.detectionTriggerType);
                if (message.usePullup != null && Object.hasOwnProperty.call(message, "usePullup"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.usePullup);
                return writer;
            };

            /**
             * Encodes the specified DetectionSensorConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.DetectionSensorConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {meshtastic.ModuleConfig.IDetectionSensorConfig} message DetectionSensorConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DetectionSensorConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DetectionSensorConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.DetectionSensorConfig} DetectionSensorConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DetectionSensorConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.DetectionSensorConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.minimumBroadcastSecs = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.stateBroadcastSecs = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.sendBell = reader.bool();
                            break;
                        }
                    case 5: {
                            message.name = reader.string();
                            break;
                        }
                    case 6: {
                            message.monitorPin = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.detectionTriggerType = reader.int32();
                            break;
                        }
                    case 8: {
                            message.usePullup = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DetectionSensorConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.DetectionSensorConfig} DetectionSensorConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DetectionSensorConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DetectionSensorConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DetectionSensorConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.minimumBroadcastSecs != null && message.hasOwnProperty("minimumBroadcastSecs"))
                    if (!$util.isInteger(message.minimumBroadcastSecs))
                        return "minimumBroadcastSecs: integer expected";
                if (message.stateBroadcastSecs != null && message.hasOwnProperty("stateBroadcastSecs"))
                    if (!$util.isInteger(message.stateBroadcastSecs))
                        return "stateBroadcastSecs: integer expected";
                if (message.sendBell != null && message.hasOwnProperty("sendBell"))
                    if (typeof message.sendBell !== "boolean")
                        return "sendBell: boolean expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.monitorPin != null && message.hasOwnProperty("monitorPin"))
                    if (!$util.isInteger(message.monitorPin))
                        return "monitorPin: integer expected";
                if (message.detectionTriggerType != null && message.hasOwnProperty("detectionTriggerType"))
                    switch (message.detectionTriggerType) {
                    default:
                        return "detectionTriggerType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.usePullup != null && message.hasOwnProperty("usePullup"))
                    if (typeof message.usePullup !== "boolean")
                        return "usePullup: boolean expected";
                return null;
            };

            /**
             * Creates a DetectionSensorConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.DetectionSensorConfig} DetectionSensorConfig
             */
            DetectionSensorConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.DetectionSensorConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.DetectionSensorConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.minimumBroadcastSecs != null)
                    message.minimumBroadcastSecs = object.minimumBroadcastSecs >>> 0;
                if (object.stateBroadcastSecs != null)
                    message.stateBroadcastSecs = object.stateBroadcastSecs >>> 0;
                if (object.sendBell != null)
                    message.sendBell = Boolean(object.sendBell);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.monitorPin != null)
                    message.monitorPin = object.monitorPin >>> 0;
                switch (object.detectionTriggerType) {
                default:
                    if (typeof object.detectionTriggerType === "number") {
                        message.detectionTriggerType = object.detectionTriggerType;
                        break;
                    }
                    break;
                case "LOGIC_LOW":
                case 0:
                    message.detectionTriggerType = 0;
                    break;
                case "LOGIC_HIGH":
                case 1:
                    message.detectionTriggerType = 1;
                    break;
                case "FALLING_EDGE":
                case 2:
                    message.detectionTriggerType = 2;
                    break;
                case "RISING_EDGE":
                case 3:
                    message.detectionTriggerType = 3;
                    break;
                case "EITHER_EDGE_ACTIVE_LOW":
                case 4:
                    message.detectionTriggerType = 4;
                    break;
                case "EITHER_EDGE_ACTIVE_HIGH":
                case 5:
                    message.detectionTriggerType = 5;
                    break;
                }
                if (object.usePullup != null)
                    message.usePullup = Boolean(object.usePullup);
                return message;
            };

            /**
             * Creates a plain object from a DetectionSensorConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {meshtastic.ModuleConfig.DetectionSensorConfig} message DetectionSensorConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DetectionSensorConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.minimumBroadcastSecs = 0;
                    object.stateBroadcastSecs = 0;
                    object.sendBell = false;
                    object.name = "";
                    object.monitorPin = 0;
                    object.detectionTriggerType = options.enums === String ? "LOGIC_LOW" : 0;
                    object.usePullup = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.minimumBroadcastSecs != null && message.hasOwnProperty("minimumBroadcastSecs"))
                    object.minimumBroadcastSecs = message.minimumBroadcastSecs;
                if (message.stateBroadcastSecs != null && message.hasOwnProperty("stateBroadcastSecs"))
                    object.stateBroadcastSecs = message.stateBroadcastSecs;
                if (message.sendBell != null && message.hasOwnProperty("sendBell"))
                    object.sendBell = message.sendBell;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.monitorPin != null && message.hasOwnProperty("monitorPin"))
                    object.monitorPin = message.monitorPin;
                if (message.detectionTriggerType != null && message.hasOwnProperty("detectionTriggerType"))
                    object.detectionTriggerType = options.enums === String ? $root.meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType[message.detectionTriggerType] === undefined ? message.detectionTriggerType : $root.meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType[message.detectionTriggerType] : message.detectionTriggerType;
                if (message.usePullup != null && message.hasOwnProperty("usePullup"))
                    object.usePullup = message.usePullup;
                return object;
            };

            /**
             * Converts this DetectionSensorConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DetectionSensorConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DetectionSensorConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.DetectionSensorConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DetectionSensorConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.DetectionSensorConfig";
            };

            /**
             * TriggerType enum.
             * @name meshtastic.ModuleConfig.DetectionSensorConfig.TriggerType
             * @enum {number}
             * @property {number} LOGIC_LOW=0 LOGIC_LOW value
             * @property {number} LOGIC_HIGH=1 LOGIC_HIGH value
             * @property {number} FALLING_EDGE=2 FALLING_EDGE value
             * @property {number} RISING_EDGE=3 RISING_EDGE value
             * @property {number} EITHER_EDGE_ACTIVE_LOW=4 EITHER_EDGE_ACTIVE_LOW value
             * @property {number} EITHER_EDGE_ACTIVE_HIGH=5 EITHER_EDGE_ACTIVE_HIGH value
             */
            DetectionSensorConfig.TriggerType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LOGIC_LOW"] = 0;
                values[valuesById[1] = "LOGIC_HIGH"] = 1;
                values[valuesById[2] = "FALLING_EDGE"] = 2;
                values[valuesById[3] = "RISING_EDGE"] = 3;
                values[valuesById[4] = "EITHER_EDGE_ACTIVE_LOW"] = 4;
                values[valuesById[5] = "EITHER_EDGE_ACTIVE_HIGH"] = 5;
                return values;
            })();

            return DetectionSensorConfig;
        })();

        ModuleConfig.AudioConfig = (function() {

            /**
             * Properties of an AudioConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IAudioConfig
             * @property {boolean|null} [codec2Enabled] AudioConfig codec2Enabled
             * @property {number|null} [pttPin] AudioConfig pttPin
             * @property {meshtastic.ModuleConfig.AudioConfig.Audio_Baud|null} [bitrate] AudioConfig bitrate
             * @property {number|null} [i2sWs] AudioConfig i2sWs
             * @property {number|null} [i2sSd] AudioConfig i2sSd
             * @property {number|null} [i2sDin] AudioConfig i2sDin
             * @property {number|null} [i2sSck] AudioConfig i2sSck
             */

            /**
             * Constructs a new AudioConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents an AudioConfig.
             * @implements IAudioConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IAudioConfig=} [properties] Properties to set
             */
            function AudioConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AudioConfig codec2Enabled.
             * @member {boolean} codec2Enabled
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.codec2Enabled = false;

            /**
             * AudioConfig pttPin.
             * @member {number} pttPin
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.pttPin = 0;

            /**
             * AudioConfig bitrate.
             * @member {meshtastic.ModuleConfig.AudioConfig.Audio_Baud} bitrate
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.bitrate = 0;

            /**
             * AudioConfig i2sWs.
             * @member {number} i2sWs
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.i2sWs = 0;

            /**
             * AudioConfig i2sSd.
             * @member {number} i2sSd
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.i2sSd = 0;

            /**
             * AudioConfig i2sDin.
             * @member {number} i2sDin
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.i2sDin = 0;

            /**
             * AudioConfig i2sSck.
             * @member {number} i2sSck
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             */
            AudioConfig.prototype.i2sSck = 0;

            /**
             * Creates a new AudioConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAudioConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.AudioConfig} AudioConfig instance
             */
            AudioConfig.create = function create(properties) {
                return new AudioConfig(properties);
            };

            /**
             * Encodes the specified AudioConfig message. Does not implicitly {@link meshtastic.ModuleConfig.AudioConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAudioConfig} message AudioConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.codec2Enabled != null && Object.hasOwnProperty.call(message, "codec2Enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.codec2Enabled);
                if (message.pttPin != null && Object.hasOwnProperty.call(message, "pttPin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pttPin);
                if (message.bitrate != null && Object.hasOwnProperty.call(message, "bitrate"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bitrate);
                if (message.i2sWs != null && Object.hasOwnProperty.call(message, "i2sWs"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.i2sWs);
                if (message.i2sSd != null && Object.hasOwnProperty.call(message, "i2sSd"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.i2sSd);
                if (message.i2sDin != null && Object.hasOwnProperty.call(message, "i2sDin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.i2sDin);
                if (message.i2sSck != null && Object.hasOwnProperty.call(message, "i2sSck"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.i2sSck);
                return writer;
            };

            /**
             * Encodes the specified AudioConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.AudioConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAudioConfig} message AudioConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AudioConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AudioConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.AudioConfig} AudioConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.AudioConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.codec2Enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.pttPin = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.bitrate = reader.int32();
                            break;
                        }
                    case 4: {
                            message.i2sWs = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.i2sSd = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.i2sDin = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.i2sSck = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AudioConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.AudioConfig} AudioConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AudioConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AudioConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AudioConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.codec2Enabled != null && message.hasOwnProperty("codec2Enabled"))
                    if (typeof message.codec2Enabled !== "boolean")
                        return "codec2Enabled: boolean expected";
                if (message.pttPin != null && message.hasOwnProperty("pttPin"))
                    if (!$util.isInteger(message.pttPin))
                        return "pttPin: integer expected";
                if (message.bitrate != null && message.hasOwnProperty("bitrate"))
                    switch (message.bitrate) {
                    default:
                        return "bitrate: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.i2sWs != null && message.hasOwnProperty("i2sWs"))
                    if (!$util.isInteger(message.i2sWs))
                        return "i2sWs: integer expected";
                if (message.i2sSd != null && message.hasOwnProperty("i2sSd"))
                    if (!$util.isInteger(message.i2sSd))
                        return "i2sSd: integer expected";
                if (message.i2sDin != null && message.hasOwnProperty("i2sDin"))
                    if (!$util.isInteger(message.i2sDin))
                        return "i2sDin: integer expected";
                if (message.i2sSck != null && message.hasOwnProperty("i2sSck"))
                    if (!$util.isInteger(message.i2sSck))
                        return "i2sSck: integer expected";
                return null;
            };

            /**
             * Creates an AudioConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.AudioConfig} AudioConfig
             */
            AudioConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.AudioConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.AudioConfig();
                if (object.codec2Enabled != null)
                    message.codec2Enabled = Boolean(object.codec2Enabled);
                if (object.pttPin != null)
                    message.pttPin = object.pttPin >>> 0;
                switch (object.bitrate) {
                default:
                    if (typeof object.bitrate === "number") {
                        message.bitrate = object.bitrate;
                        break;
                    }
                    break;
                case "CODEC2_DEFAULT":
                case 0:
                    message.bitrate = 0;
                    break;
                case "CODEC2_3200":
                case 1:
                    message.bitrate = 1;
                    break;
                case "CODEC2_2400":
                case 2:
                    message.bitrate = 2;
                    break;
                case "CODEC2_1600":
                case 3:
                    message.bitrate = 3;
                    break;
                case "CODEC2_1400":
                case 4:
                    message.bitrate = 4;
                    break;
                case "CODEC2_1300":
                case 5:
                    message.bitrate = 5;
                    break;
                case "CODEC2_1200":
                case 6:
                    message.bitrate = 6;
                    break;
                case "CODEC2_700":
                case 7:
                    message.bitrate = 7;
                    break;
                case "CODEC2_700B":
                case 8:
                    message.bitrate = 8;
                    break;
                }
                if (object.i2sWs != null)
                    message.i2sWs = object.i2sWs >>> 0;
                if (object.i2sSd != null)
                    message.i2sSd = object.i2sSd >>> 0;
                if (object.i2sDin != null)
                    message.i2sDin = object.i2sDin >>> 0;
                if (object.i2sSck != null)
                    message.i2sSck = object.i2sSck >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AudioConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {meshtastic.ModuleConfig.AudioConfig} message AudioConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AudioConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.codec2Enabled = false;
                    object.pttPin = 0;
                    object.bitrate = options.enums === String ? "CODEC2_DEFAULT" : 0;
                    object.i2sWs = 0;
                    object.i2sSd = 0;
                    object.i2sDin = 0;
                    object.i2sSck = 0;
                }
                if (message.codec2Enabled != null && message.hasOwnProperty("codec2Enabled"))
                    object.codec2Enabled = message.codec2Enabled;
                if (message.pttPin != null && message.hasOwnProperty("pttPin"))
                    object.pttPin = message.pttPin;
                if (message.bitrate != null && message.hasOwnProperty("bitrate"))
                    object.bitrate = options.enums === String ? $root.meshtastic.ModuleConfig.AudioConfig.Audio_Baud[message.bitrate] === undefined ? message.bitrate : $root.meshtastic.ModuleConfig.AudioConfig.Audio_Baud[message.bitrate] : message.bitrate;
                if (message.i2sWs != null && message.hasOwnProperty("i2sWs"))
                    object.i2sWs = message.i2sWs;
                if (message.i2sSd != null && message.hasOwnProperty("i2sSd"))
                    object.i2sSd = message.i2sSd;
                if (message.i2sDin != null && message.hasOwnProperty("i2sDin"))
                    object.i2sDin = message.i2sDin;
                if (message.i2sSck != null && message.hasOwnProperty("i2sSck"))
                    object.i2sSck = message.i2sSck;
                return object;
            };

            /**
             * Converts this AudioConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AudioConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AudioConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.AudioConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AudioConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.AudioConfig";
            };

            /**
             * Audio_Baud enum.
             * @name meshtastic.ModuleConfig.AudioConfig.Audio_Baud
             * @enum {number}
             * @property {number} CODEC2_DEFAULT=0 CODEC2_DEFAULT value
             * @property {number} CODEC2_3200=1 CODEC2_3200 value
             * @property {number} CODEC2_2400=2 CODEC2_2400 value
             * @property {number} CODEC2_1600=3 CODEC2_1600 value
             * @property {number} CODEC2_1400=4 CODEC2_1400 value
             * @property {number} CODEC2_1300=5 CODEC2_1300 value
             * @property {number} CODEC2_1200=6 CODEC2_1200 value
             * @property {number} CODEC2_700=7 CODEC2_700 value
             * @property {number} CODEC2_700B=8 CODEC2_700B value
             */
            AudioConfig.Audio_Baud = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CODEC2_DEFAULT"] = 0;
                values[valuesById[1] = "CODEC2_3200"] = 1;
                values[valuesById[2] = "CODEC2_2400"] = 2;
                values[valuesById[3] = "CODEC2_1600"] = 3;
                values[valuesById[4] = "CODEC2_1400"] = 4;
                values[valuesById[5] = "CODEC2_1300"] = 5;
                values[valuesById[6] = "CODEC2_1200"] = 6;
                values[valuesById[7] = "CODEC2_700"] = 7;
                values[valuesById[8] = "CODEC2_700B"] = 8;
                return values;
            })();

            return AudioConfig;
        })();

        ModuleConfig.PaxcounterConfig = (function() {

            /**
             * Properties of a PaxcounterConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IPaxcounterConfig
             * @property {boolean|null} [enabled] PaxcounterConfig enabled
             * @property {number|null} [paxcounterUpdateInterval] PaxcounterConfig paxcounterUpdateInterval
             * @property {number|null} [wifiThreshold] PaxcounterConfig wifiThreshold
             * @property {number|null} [bleThreshold] PaxcounterConfig bleThreshold
             */

            /**
             * Constructs a new PaxcounterConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a PaxcounterConfig.
             * @implements IPaxcounterConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IPaxcounterConfig=} [properties] Properties to set
             */
            function PaxcounterConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PaxcounterConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @instance
             */
            PaxcounterConfig.prototype.enabled = false;

            /**
             * PaxcounterConfig paxcounterUpdateInterval.
             * @member {number} paxcounterUpdateInterval
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @instance
             */
            PaxcounterConfig.prototype.paxcounterUpdateInterval = 0;

            /**
             * PaxcounterConfig wifiThreshold.
             * @member {number} wifiThreshold
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @instance
             */
            PaxcounterConfig.prototype.wifiThreshold = 0;

            /**
             * PaxcounterConfig bleThreshold.
             * @member {number} bleThreshold
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @instance
             */
            PaxcounterConfig.prototype.bleThreshold = 0;

            /**
             * Creates a new PaxcounterConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {meshtastic.ModuleConfig.IPaxcounterConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.PaxcounterConfig} PaxcounterConfig instance
             */
            PaxcounterConfig.create = function create(properties) {
                return new PaxcounterConfig(properties);
            };

            /**
             * Encodes the specified PaxcounterConfig message. Does not implicitly {@link meshtastic.ModuleConfig.PaxcounterConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {meshtastic.ModuleConfig.IPaxcounterConfig} message PaxcounterConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PaxcounterConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.paxcounterUpdateInterval != null && Object.hasOwnProperty.call(message, "paxcounterUpdateInterval"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.paxcounterUpdateInterval);
                if (message.wifiThreshold != null && Object.hasOwnProperty.call(message, "wifiThreshold"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.wifiThreshold);
                if (message.bleThreshold != null && Object.hasOwnProperty.call(message, "bleThreshold"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bleThreshold);
                return writer;
            };

            /**
             * Encodes the specified PaxcounterConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.PaxcounterConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {meshtastic.ModuleConfig.IPaxcounterConfig} message PaxcounterConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PaxcounterConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PaxcounterConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.PaxcounterConfig} PaxcounterConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PaxcounterConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.PaxcounterConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.paxcounterUpdateInterval = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.wifiThreshold = reader.int32();
                            break;
                        }
                    case 4: {
                            message.bleThreshold = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PaxcounterConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.PaxcounterConfig} PaxcounterConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PaxcounterConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PaxcounterConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PaxcounterConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.paxcounterUpdateInterval != null && message.hasOwnProperty("paxcounterUpdateInterval"))
                    if (!$util.isInteger(message.paxcounterUpdateInterval))
                        return "paxcounterUpdateInterval: integer expected";
                if (message.wifiThreshold != null && message.hasOwnProperty("wifiThreshold"))
                    if (!$util.isInteger(message.wifiThreshold))
                        return "wifiThreshold: integer expected";
                if (message.bleThreshold != null && message.hasOwnProperty("bleThreshold"))
                    if (!$util.isInteger(message.bleThreshold))
                        return "bleThreshold: integer expected";
                return null;
            };

            /**
             * Creates a PaxcounterConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.PaxcounterConfig} PaxcounterConfig
             */
            PaxcounterConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.PaxcounterConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.PaxcounterConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.paxcounterUpdateInterval != null)
                    message.paxcounterUpdateInterval = object.paxcounterUpdateInterval >>> 0;
                if (object.wifiThreshold != null)
                    message.wifiThreshold = object.wifiThreshold | 0;
                if (object.bleThreshold != null)
                    message.bleThreshold = object.bleThreshold | 0;
                return message;
            };

            /**
             * Creates a plain object from a PaxcounterConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {meshtastic.ModuleConfig.PaxcounterConfig} message PaxcounterConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PaxcounterConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.paxcounterUpdateInterval = 0;
                    object.wifiThreshold = 0;
                    object.bleThreshold = 0;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.paxcounterUpdateInterval != null && message.hasOwnProperty("paxcounterUpdateInterval"))
                    object.paxcounterUpdateInterval = message.paxcounterUpdateInterval;
                if (message.wifiThreshold != null && message.hasOwnProperty("wifiThreshold"))
                    object.wifiThreshold = message.wifiThreshold;
                if (message.bleThreshold != null && message.hasOwnProperty("bleThreshold"))
                    object.bleThreshold = message.bleThreshold;
                return object;
            };

            /**
             * Converts this PaxcounterConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PaxcounterConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PaxcounterConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.PaxcounterConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PaxcounterConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.PaxcounterConfig";
            };

            return PaxcounterConfig;
        })();

        ModuleConfig.SerialConfig = (function() {

            /**
             * Properties of a SerialConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface ISerialConfig
             * @property {boolean|null} [enabled] SerialConfig enabled
             * @property {boolean|null} [echo] SerialConfig echo
             * @property {number|null} [rxd] SerialConfig rxd
             * @property {number|null} [txd] SerialConfig txd
             * @property {meshtastic.ModuleConfig.SerialConfig.Serial_Baud|null} [baud] SerialConfig baud
             * @property {number|null} [timeout] SerialConfig timeout
             * @property {meshtastic.ModuleConfig.SerialConfig.Serial_Mode|null} [mode] SerialConfig mode
             * @property {boolean|null} [overrideConsoleSerialPort] SerialConfig overrideConsoleSerialPort
             */

            /**
             * Constructs a new SerialConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a SerialConfig.
             * @implements ISerialConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.ISerialConfig=} [properties] Properties to set
             */
            function SerialConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SerialConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.enabled = false;

            /**
             * SerialConfig echo.
             * @member {boolean} echo
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.echo = false;

            /**
             * SerialConfig rxd.
             * @member {number} rxd
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.rxd = 0;

            /**
             * SerialConfig txd.
             * @member {number} txd
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.txd = 0;

            /**
             * SerialConfig baud.
             * @member {meshtastic.ModuleConfig.SerialConfig.Serial_Baud} baud
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.baud = 0;

            /**
             * SerialConfig timeout.
             * @member {number} timeout
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.timeout = 0;

            /**
             * SerialConfig mode.
             * @member {meshtastic.ModuleConfig.SerialConfig.Serial_Mode} mode
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.mode = 0;

            /**
             * SerialConfig overrideConsoleSerialPort.
             * @member {boolean} overrideConsoleSerialPort
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             */
            SerialConfig.prototype.overrideConsoleSerialPort = false;

            /**
             * Creates a new SerialConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {meshtastic.ModuleConfig.ISerialConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.SerialConfig} SerialConfig instance
             */
            SerialConfig.create = function create(properties) {
                return new SerialConfig(properties);
            };

            /**
             * Encodes the specified SerialConfig message. Does not implicitly {@link meshtastic.ModuleConfig.SerialConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {meshtastic.ModuleConfig.ISerialConfig} message SerialConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerialConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.echo != null && Object.hasOwnProperty.call(message, "echo"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.echo);
                if (message.rxd != null && Object.hasOwnProperty.call(message, "rxd"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.rxd);
                if (message.txd != null && Object.hasOwnProperty.call(message, "txd"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.txd);
                if (message.baud != null && Object.hasOwnProperty.call(message, "baud"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.baud);
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.timeout);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.mode);
                if (message.overrideConsoleSerialPort != null && Object.hasOwnProperty.call(message, "overrideConsoleSerialPort"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.overrideConsoleSerialPort);
                return writer;
            };

            /**
             * Encodes the specified SerialConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.SerialConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {meshtastic.ModuleConfig.ISerialConfig} message SerialConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerialConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SerialConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.SerialConfig} SerialConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerialConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.SerialConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.echo = reader.bool();
                            break;
                        }
                    case 3: {
                            message.rxd = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.txd = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.baud = reader.int32();
                            break;
                        }
                    case 6: {
                            message.timeout = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.mode = reader.int32();
                            break;
                        }
                    case 8: {
                            message.overrideConsoleSerialPort = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SerialConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.SerialConfig} SerialConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerialConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SerialConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerialConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.echo != null && message.hasOwnProperty("echo"))
                    if (typeof message.echo !== "boolean")
                        return "echo: boolean expected";
                if (message.rxd != null && message.hasOwnProperty("rxd"))
                    if (!$util.isInteger(message.rxd))
                        return "rxd: integer expected";
                if (message.txd != null && message.hasOwnProperty("txd"))
                    if (!$util.isInteger(message.txd))
                        return "txd: integer expected";
                if (message.baud != null && message.hasOwnProperty("baud"))
                    switch (message.baud) {
                    default:
                        return "baud: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout))
                        return "timeout: integer expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.overrideConsoleSerialPort != null && message.hasOwnProperty("overrideConsoleSerialPort"))
                    if (typeof message.overrideConsoleSerialPort !== "boolean")
                        return "overrideConsoleSerialPort: boolean expected";
                return null;
            };

            /**
             * Creates a SerialConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.SerialConfig} SerialConfig
             */
            SerialConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.SerialConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.SerialConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.echo != null)
                    message.echo = Boolean(object.echo);
                if (object.rxd != null)
                    message.rxd = object.rxd >>> 0;
                if (object.txd != null)
                    message.txd = object.txd >>> 0;
                switch (object.baud) {
                default:
                    if (typeof object.baud === "number") {
                        message.baud = object.baud;
                        break;
                    }
                    break;
                case "BAUD_DEFAULT":
                case 0:
                    message.baud = 0;
                    break;
                case "BAUD_110":
                case 1:
                    message.baud = 1;
                    break;
                case "BAUD_300":
                case 2:
                    message.baud = 2;
                    break;
                case "BAUD_600":
                case 3:
                    message.baud = 3;
                    break;
                case "BAUD_1200":
                case 4:
                    message.baud = 4;
                    break;
                case "BAUD_2400":
                case 5:
                    message.baud = 5;
                    break;
                case "BAUD_4800":
                case 6:
                    message.baud = 6;
                    break;
                case "BAUD_9600":
                case 7:
                    message.baud = 7;
                    break;
                case "BAUD_19200":
                case 8:
                    message.baud = 8;
                    break;
                case "BAUD_38400":
                case 9:
                    message.baud = 9;
                    break;
                case "BAUD_57600":
                case 10:
                    message.baud = 10;
                    break;
                case "BAUD_115200":
                case 11:
                    message.baud = 11;
                    break;
                case "BAUD_230400":
                case 12:
                    message.baud = 12;
                    break;
                case "BAUD_460800":
                case 13:
                    message.baud = 13;
                    break;
                case "BAUD_576000":
                case 14:
                    message.baud = 14;
                    break;
                case "BAUD_921600":
                case 15:
                    message.baud = 15;
                    break;
                }
                if (object.timeout != null)
                    message.timeout = object.timeout >>> 0;
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "DEFAULT":
                case 0:
                    message.mode = 0;
                    break;
                case "SIMPLE":
                case 1:
                    message.mode = 1;
                    break;
                case "PROTO":
                case 2:
                    message.mode = 2;
                    break;
                case "TEXTMSG":
                case 3:
                    message.mode = 3;
                    break;
                case "NMEA":
                case 4:
                    message.mode = 4;
                    break;
                case "CALTOPO":
                case 5:
                    message.mode = 5;
                    break;
                case "WS85":
                case 6:
                    message.mode = 6;
                    break;
                case "VE_DIRECT":
                case 7:
                    message.mode = 7;
                    break;
                case "MS_CONFIG":
                case 8:
                    message.mode = 8;
                    break;
                }
                if (object.overrideConsoleSerialPort != null)
                    message.overrideConsoleSerialPort = Boolean(object.overrideConsoleSerialPort);
                return message;
            };

            /**
             * Creates a plain object from a SerialConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {meshtastic.ModuleConfig.SerialConfig} message SerialConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerialConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.echo = false;
                    object.rxd = 0;
                    object.txd = 0;
                    object.baud = options.enums === String ? "BAUD_DEFAULT" : 0;
                    object.timeout = 0;
                    object.mode = options.enums === String ? "DEFAULT" : 0;
                    object.overrideConsoleSerialPort = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.echo != null && message.hasOwnProperty("echo"))
                    object.echo = message.echo;
                if (message.rxd != null && message.hasOwnProperty("rxd"))
                    object.rxd = message.rxd;
                if (message.txd != null && message.hasOwnProperty("txd"))
                    object.txd = message.txd;
                if (message.baud != null && message.hasOwnProperty("baud"))
                    object.baud = options.enums === String ? $root.meshtastic.ModuleConfig.SerialConfig.Serial_Baud[message.baud] === undefined ? message.baud : $root.meshtastic.ModuleConfig.SerialConfig.Serial_Baud[message.baud] : message.baud;
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.meshtastic.ModuleConfig.SerialConfig.Serial_Mode[message.mode] === undefined ? message.mode : $root.meshtastic.ModuleConfig.SerialConfig.Serial_Mode[message.mode] : message.mode;
                if (message.overrideConsoleSerialPort != null && message.hasOwnProperty("overrideConsoleSerialPort"))
                    object.overrideConsoleSerialPort = message.overrideConsoleSerialPort;
                return object;
            };

            /**
             * Converts this SerialConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerialConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SerialConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.SerialConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SerialConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.SerialConfig";
            };

            /**
             * Serial_Baud enum.
             * @name meshtastic.ModuleConfig.SerialConfig.Serial_Baud
             * @enum {number}
             * @property {number} BAUD_DEFAULT=0 BAUD_DEFAULT value
             * @property {number} BAUD_110=1 BAUD_110 value
             * @property {number} BAUD_300=2 BAUD_300 value
             * @property {number} BAUD_600=3 BAUD_600 value
             * @property {number} BAUD_1200=4 BAUD_1200 value
             * @property {number} BAUD_2400=5 BAUD_2400 value
             * @property {number} BAUD_4800=6 BAUD_4800 value
             * @property {number} BAUD_9600=7 BAUD_9600 value
             * @property {number} BAUD_19200=8 BAUD_19200 value
             * @property {number} BAUD_38400=9 BAUD_38400 value
             * @property {number} BAUD_57600=10 BAUD_57600 value
             * @property {number} BAUD_115200=11 BAUD_115200 value
             * @property {number} BAUD_230400=12 BAUD_230400 value
             * @property {number} BAUD_460800=13 BAUD_460800 value
             * @property {number} BAUD_576000=14 BAUD_576000 value
             * @property {number} BAUD_921600=15 BAUD_921600 value
             */
            SerialConfig.Serial_Baud = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BAUD_DEFAULT"] = 0;
                values[valuesById[1] = "BAUD_110"] = 1;
                values[valuesById[2] = "BAUD_300"] = 2;
                values[valuesById[3] = "BAUD_600"] = 3;
                values[valuesById[4] = "BAUD_1200"] = 4;
                values[valuesById[5] = "BAUD_2400"] = 5;
                values[valuesById[6] = "BAUD_4800"] = 6;
                values[valuesById[7] = "BAUD_9600"] = 7;
                values[valuesById[8] = "BAUD_19200"] = 8;
                values[valuesById[9] = "BAUD_38400"] = 9;
                values[valuesById[10] = "BAUD_57600"] = 10;
                values[valuesById[11] = "BAUD_115200"] = 11;
                values[valuesById[12] = "BAUD_230400"] = 12;
                values[valuesById[13] = "BAUD_460800"] = 13;
                values[valuesById[14] = "BAUD_576000"] = 14;
                values[valuesById[15] = "BAUD_921600"] = 15;
                return values;
            })();

            /**
             * Serial_Mode enum.
             * @name meshtastic.ModuleConfig.SerialConfig.Serial_Mode
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} SIMPLE=1 SIMPLE value
             * @property {number} PROTO=2 PROTO value
             * @property {number} TEXTMSG=3 TEXTMSG value
             * @property {number} NMEA=4 NMEA value
             * @property {number} CALTOPO=5 CALTOPO value
             * @property {number} WS85=6 WS85 value
             * @property {number} VE_DIRECT=7 VE_DIRECT value
             * @property {number} MS_CONFIG=8 MS_CONFIG value
             */
            SerialConfig.Serial_Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "SIMPLE"] = 1;
                values[valuesById[2] = "PROTO"] = 2;
                values[valuesById[3] = "TEXTMSG"] = 3;
                values[valuesById[4] = "NMEA"] = 4;
                values[valuesById[5] = "CALTOPO"] = 5;
                values[valuesById[6] = "WS85"] = 6;
                values[valuesById[7] = "VE_DIRECT"] = 7;
                values[valuesById[8] = "MS_CONFIG"] = 8;
                return values;
            })();

            return SerialConfig;
        })();

        ModuleConfig.ExternalNotificationConfig = (function() {

            /**
             * Properties of an ExternalNotificationConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IExternalNotificationConfig
             * @property {boolean|null} [enabled] ExternalNotificationConfig enabled
             * @property {number|null} [outputMs] ExternalNotificationConfig outputMs
             * @property {number|null} [output] ExternalNotificationConfig output
             * @property {number|null} [outputVibra] ExternalNotificationConfig outputVibra
             * @property {number|null} [outputBuzzer] ExternalNotificationConfig outputBuzzer
             * @property {boolean|null} [active] ExternalNotificationConfig active
             * @property {boolean|null} [alertMessage] ExternalNotificationConfig alertMessage
             * @property {boolean|null} [alertMessageVibra] ExternalNotificationConfig alertMessageVibra
             * @property {boolean|null} [alertMessageBuzzer] ExternalNotificationConfig alertMessageBuzzer
             * @property {boolean|null} [alertBell] ExternalNotificationConfig alertBell
             * @property {boolean|null} [alertBellVibra] ExternalNotificationConfig alertBellVibra
             * @property {boolean|null} [alertBellBuzzer] ExternalNotificationConfig alertBellBuzzer
             * @property {boolean|null} [usePwm] ExternalNotificationConfig usePwm
             * @property {number|null} [nagTimeout] ExternalNotificationConfig nagTimeout
             * @property {boolean|null} [useI2sAsBuzzer] ExternalNotificationConfig useI2sAsBuzzer
             */

            /**
             * Constructs a new ExternalNotificationConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents an ExternalNotificationConfig.
             * @implements IExternalNotificationConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IExternalNotificationConfig=} [properties] Properties to set
             */
            function ExternalNotificationConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExternalNotificationConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.enabled = false;

            /**
             * ExternalNotificationConfig outputMs.
             * @member {number} outputMs
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.outputMs = 0;

            /**
             * ExternalNotificationConfig output.
             * @member {number} output
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.output = 0;

            /**
             * ExternalNotificationConfig outputVibra.
             * @member {number} outputVibra
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.outputVibra = 0;

            /**
             * ExternalNotificationConfig outputBuzzer.
             * @member {number} outputBuzzer
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.outputBuzzer = 0;

            /**
             * ExternalNotificationConfig active.
             * @member {boolean} active
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.active = false;

            /**
             * ExternalNotificationConfig alertMessage.
             * @member {boolean} alertMessage
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertMessage = false;

            /**
             * ExternalNotificationConfig alertMessageVibra.
             * @member {boolean} alertMessageVibra
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertMessageVibra = false;

            /**
             * ExternalNotificationConfig alertMessageBuzzer.
             * @member {boolean} alertMessageBuzzer
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertMessageBuzzer = false;

            /**
             * ExternalNotificationConfig alertBell.
             * @member {boolean} alertBell
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertBell = false;

            /**
             * ExternalNotificationConfig alertBellVibra.
             * @member {boolean} alertBellVibra
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertBellVibra = false;

            /**
             * ExternalNotificationConfig alertBellBuzzer.
             * @member {boolean} alertBellBuzzer
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.alertBellBuzzer = false;

            /**
             * ExternalNotificationConfig usePwm.
             * @member {boolean} usePwm
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.usePwm = false;

            /**
             * ExternalNotificationConfig nagTimeout.
             * @member {number} nagTimeout
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.nagTimeout = 0;

            /**
             * ExternalNotificationConfig useI2sAsBuzzer.
             * @member {boolean} useI2sAsBuzzer
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             */
            ExternalNotificationConfig.prototype.useI2sAsBuzzer = false;

            /**
             * Creates a new ExternalNotificationConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {meshtastic.ModuleConfig.IExternalNotificationConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.ExternalNotificationConfig} ExternalNotificationConfig instance
             */
            ExternalNotificationConfig.create = function create(properties) {
                return new ExternalNotificationConfig(properties);
            };

            /**
             * Encodes the specified ExternalNotificationConfig message. Does not implicitly {@link meshtastic.ModuleConfig.ExternalNotificationConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {meshtastic.ModuleConfig.IExternalNotificationConfig} message ExternalNotificationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalNotificationConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.outputMs != null && Object.hasOwnProperty.call(message, "outputMs"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.outputMs);
                if (message.output != null && Object.hasOwnProperty.call(message, "output"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.output);
                if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.active);
                if (message.alertMessage != null && Object.hasOwnProperty.call(message, "alertMessage"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.alertMessage);
                if (message.alertBell != null && Object.hasOwnProperty.call(message, "alertBell"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.alertBell);
                if (message.usePwm != null && Object.hasOwnProperty.call(message, "usePwm"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.usePwm);
                if (message.outputVibra != null && Object.hasOwnProperty.call(message, "outputVibra"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.outputVibra);
                if (message.outputBuzzer != null && Object.hasOwnProperty.call(message, "outputBuzzer"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.outputBuzzer);
                if (message.alertMessageVibra != null && Object.hasOwnProperty.call(message, "alertMessageVibra"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.alertMessageVibra);
                if (message.alertMessageBuzzer != null && Object.hasOwnProperty.call(message, "alertMessageBuzzer"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.alertMessageBuzzer);
                if (message.alertBellVibra != null && Object.hasOwnProperty.call(message, "alertBellVibra"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.alertBellVibra);
                if (message.alertBellBuzzer != null && Object.hasOwnProperty.call(message, "alertBellBuzzer"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.alertBellBuzzer);
                if (message.nagTimeout != null && Object.hasOwnProperty.call(message, "nagTimeout"))
                    writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.nagTimeout);
                if (message.useI2sAsBuzzer != null && Object.hasOwnProperty.call(message, "useI2sAsBuzzer"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.useI2sAsBuzzer);
                return writer;
            };

            /**
             * Encodes the specified ExternalNotificationConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.ExternalNotificationConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {meshtastic.ModuleConfig.IExternalNotificationConfig} message ExternalNotificationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalNotificationConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExternalNotificationConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.ExternalNotificationConfig} ExternalNotificationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalNotificationConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.ExternalNotificationConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.outputMs = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.output = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.outputVibra = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.outputBuzzer = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.active = reader.bool();
                            break;
                        }
                    case 5: {
                            message.alertMessage = reader.bool();
                            break;
                        }
                    case 10: {
                            message.alertMessageVibra = reader.bool();
                            break;
                        }
                    case 11: {
                            message.alertMessageBuzzer = reader.bool();
                            break;
                        }
                    case 6: {
                            message.alertBell = reader.bool();
                            break;
                        }
                    case 12: {
                            message.alertBellVibra = reader.bool();
                            break;
                        }
                    case 13: {
                            message.alertBellBuzzer = reader.bool();
                            break;
                        }
                    case 7: {
                            message.usePwm = reader.bool();
                            break;
                        }
                    case 14: {
                            message.nagTimeout = reader.uint32();
                            break;
                        }
                    case 15: {
                            message.useI2sAsBuzzer = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExternalNotificationConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.ExternalNotificationConfig} ExternalNotificationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalNotificationConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExternalNotificationConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExternalNotificationConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.outputMs != null && message.hasOwnProperty("outputMs"))
                    if (!$util.isInteger(message.outputMs))
                        return "outputMs: integer expected";
                if (message.output != null && message.hasOwnProperty("output"))
                    if (!$util.isInteger(message.output))
                        return "output: integer expected";
                if (message.outputVibra != null && message.hasOwnProperty("outputVibra"))
                    if (!$util.isInteger(message.outputVibra))
                        return "outputVibra: integer expected";
                if (message.outputBuzzer != null && message.hasOwnProperty("outputBuzzer"))
                    if (!$util.isInteger(message.outputBuzzer))
                        return "outputBuzzer: integer expected";
                if (message.active != null && message.hasOwnProperty("active"))
                    if (typeof message.active !== "boolean")
                        return "active: boolean expected";
                if (message.alertMessage != null && message.hasOwnProperty("alertMessage"))
                    if (typeof message.alertMessage !== "boolean")
                        return "alertMessage: boolean expected";
                if (message.alertMessageVibra != null && message.hasOwnProperty("alertMessageVibra"))
                    if (typeof message.alertMessageVibra !== "boolean")
                        return "alertMessageVibra: boolean expected";
                if (message.alertMessageBuzzer != null && message.hasOwnProperty("alertMessageBuzzer"))
                    if (typeof message.alertMessageBuzzer !== "boolean")
                        return "alertMessageBuzzer: boolean expected";
                if (message.alertBell != null && message.hasOwnProperty("alertBell"))
                    if (typeof message.alertBell !== "boolean")
                        return "alertBell: boolean expected";
                if (message.alertBellVibra != null && message.hasOwnProperty("alertBellVibra"))
                    if (typeof message.alertBellVibra !== "boolean")
                        return "alertBellVibra: boolean expected";
                if (message.alertBellBuzzer != null && message.hasOwnProperty("alertBellBuzzer"))
                    if (typeof message.alertBellBuzzer !== "boolean")
                        return "alertBellBuzzer: boolean expected";
                if (message.usePwm != null && message.hasOwnProperty("usePwm"))
                    if (typeof message.usePwm !== "boolean")
                        return "usePwm: boolean expected";
                if (message.nagTimeout != null && message.hasOwnProperty("nagTimeout"))
                    if (!$util.isInteger(message.nagTimeout))
                        return "nagTimeout: integer expected";
                if (message.useI2sAsBuzzer != null && message.hasOwnProperty("useI2sAsBuzzer"))
                    if (typeof message.useI2sAsBuzzer !== "boolean")
                        return "useI2sAsBuzzer: boolean expected";
                return null;
            };

            /**
             * Creates an ExternalNotificationConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.ExternalNotificationConfig} ExternalNotificationConfig
             */
            ExternalNotificationConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.ExternalNotificationConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.ExternalNotificationConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.outputMs != null)
                    message.outputMs = object.outputMs >>> 0;
                if (object.output != null)
                    message.output = object.output >>> 0;
                if (object.outputVibra != null)
                    message.outputVibra = object.outputVibra >>> 0;
                if (object.outputBuzzer != null)
                    message.outputBuzzer = object.outputBuzzer >>> 0;
                if (object.active != null)
                    message.active = Boolean(object.active);
                if (object.alertMessage != null)
                    message.alertMessage = Boolean(object.alertMessage);
                if (object.alertMessageVibra != null)
                    message.alertMessageVibra = Boolean(object.alertMessageVibra);
                if (object.alertMessageBuzzer != null)
                    message.alertMessageBuzzer = Boolean(object.alertMessageBuzzer);
                if (object.alertBell != null)
                    message.alertBell = Boolean(object.alertBell);
                if (object.alertBellVibra != null)
                    message.alertBellVibra = Boolean(object.alertBellVibra);
                if (object.alertBellBuzzer != null)
                    message.alertBellBuzzer = Boolean(object.alertBellBuzzer);
                if (object.usePwm != null)
                    message.usePwm = Boolean(object.usePwm);
                if (object.nagTimeout != null)
                    message.nagTimeout = object.nagTimeout >>> 0;
                if (object.useI2sAsBuzzer != null)
                    message.useI2sAsBuzzer = Boolean(object.useI2sAsBuzzer);
                return message;
            };

            /**
             * Creates a plain object from an ExternalNotificationConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {meshtastic.ModuleConfig.ExternalNotificationConfig} message ExternalNotificationConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExternalNotificationConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.outputMs = 0;
                    object.output = 0;
                    object.active = false;
                    object.alertMessage = false;
                    object.alertBell = false;
                    object.usePwm = false;
                    object.outputVibra = 0;
                    object.outputBuzzer = 0;
                    object.alertMessageVibra = false;
                    object.alertMessageBuzzer = false;
                    object.alertBellVibra = false;
                    object.alertBellBuzzer = false;
                    object.nagTimeout = 0;
                    object.useI2sAsBuzzer = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.outputMs != null && message.hasOwnProperty("outputMs"))
                    object.outputMs = message.outputMs;
                if (message.output != null && message.hasOwnProperty("output"))
                    object.output = message.output;
                if (message.active != null && message.hasOwnProperty("active"))
                    object.active = message.active;
                if (message.alertMessage != null && message.hasOwnProperty("alertMessage"))
                    object.alertMessage = message.alertMessage;
                if (message.alertBell != null && message.hasOwnProperty("alertBell"))
                    object.alertBell = message.alertBell;
                if (message.usePwm != null && message.hasOwnProperty("usePwm"))
                    object.usePwm = message.usePwm;
                if (message.outputVibra != null && message.hasOwnProperty("outputVibra"))
                    object.outputVibra = message.outputVibra;
                if (message.outputBuzzer != null && message.hasOwnProperty("outputBuzzer"))
                    object.outputBuzzer = message.outputBuzzer;
                if (message.alertMessageVibra != null && message.hasOwnProperty("alertMessageVibra"))
                    object.alertMessageVibra = message.alertMessageVibra;
                if (message.alertMessageBuzzer != null && message.hasOwnProperty("alertMessageBuzzer"))
                    object.alertMessageBuzzer = message.alertMessageBuzzer;
                if (message.alertBellVibra != null && message.hasOwnProperty("alertBellVibra"))
                    object.alertBellVibra = message.alertBellVibra;
                if (message.alertBellBuzzer != null && message.hasOwnProperty("alertBellBuzzer"))
                    object.alertBellBuzzer = message.alertBellBuzzer;
                if (message.nagTimeout != null && message.hasOwnProperty("nagTimeout"))
                    object.nagTimeout = message.nagTimeout;
                if (message.useI2sAsBuzzer != null && message.hasOwnProperty("useI2sAsBuzzer"))
                    object.useI2sAsBuzzer = message.useI2sAsBuzzer;
                return object;
            };

            /**
             * Converts this ExternalNotificationConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExternalNotificationConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExternalNotificationConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.ExternalNotificationConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExternalNotificationConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.ExternalNotificationConfig";
            };

            return ExternalNotificationConfig;
        })();

        ModuleConfig.StoreForwardConfig = (function() {

            /**
             * Properties of a StoreForwardConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IStoreForwardConfig
             * @property {boolean|null} [enabled] StoreForwardConfig enabled
             * @property {boolean|null} [heartbeat] StoreForwardConfig heartbeat
             * @property {number|null} [records] StoreForwardConfig records
             * @property {number|null} [historyReturnMax] StoreForwardConfig historyReturnMax
             * @property {number|null} [historyReturnWindow] StoreForwardConfig historyReturnWindow
             * @property {boolean|null} [isServer] StoreForwardConfig isServer
             */

            /**
             * Constructs a new StoreForwardConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a StoreForwardConfig.
             * @implements IStoreForwardConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IStoreForwardConfig=} [properties] Properties to set
             */
            function StoreForwardConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreForwardConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.enabled = false;

            /**
             * StoreForwardConfig heartbeat.
             * @member {boolean} heartbeat
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.heartbeat = false;

            /**
             * StoreForwardConfig records.
             * @member {number} records
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.records = 0;

            /**
             * StoreForwardConfig historyReturnMax.
             * @member {number} historyReturnMax
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.historyReturnMax = 0;

            /**
             * StoreForwardConfig historyReturnWindow.
             * @member {number} historyReturnWindow
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.historyReturnWindow = 0;

            /**
             * StoreForwardConfig isServer.
             * @member {boolean} isServer
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             */
            StoreForwardConfig.prototype.isServer = false;

            /**
             * Creates a new StoreForwardConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {meshtastic.ModuleConfig.IStoreForwardConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.StoreForwardConfig} StoreForwardConfig instance
             */
            StoreForwardConfig.create = function create(properties) {
                return new StoreForwardConfig(properties);
            };

            /**
             * Encodes the specified StoreForwardConfig message. Does not implicitly {@link meshtastic.ModuleConfig.StoreForwardConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {meshtastic.ModuleConfig.IStoreForwardConfig} message StoreForwardConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreForwardConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.heartbeat != null && Object.hasOwnProperty.call(message, "heartbeat"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.heartbeat);
                if (message.records != null && Object.hasOwnProperty.call(message, "records"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.records);
                if (message.historyReturnMax != null && Object.hasOwnProperty.call(message, "historyReturnMax"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.historyReturnMax);
                if (message.historyReturnWindow != null && Object.hasOwnProperty.call(message, "historyReturnWindow"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.historyReturnWindow);
                if (message.isServer != null && Object.hasOwnProperty.call(message, "isServer"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isServer);
                return writer;
            };

            /**
             * Encodes the specified StoreForwardConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.StoreForwardConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {meshtastic.ModuleConfig.IStoreForwardConfig} message StoreForwardConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreForwardConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreForwardConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.StoreForwardConfig} StoreForwardConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreForwardConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.StoreForwardConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.heartbeat = reader.bool();
                            break;
                        }
                    case 3: {
                            message.records = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.historyReturnMax = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.historyReturnWindow = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.isServer = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreForwardConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.StoreForwardConfig} StoreForwardConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreForwardConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreForwardConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoreForwardConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.heartbeat != null && message.hasOwnProperty("heartbeat"))
                    if (typeof message.heartbeat !== "boolean")
                        return "heartbeat: boolean expected";
                if (message.records != null && message.hasOwnProperty("records"))
                    if (!$util.isInteger(message.records))
                        return "records: integer expected";
                if (message.historyReturnMax != null && message.hasOwnProperty("historyReturnMax"))
                    if (!$util.isInteger(message.historyReturnMax))
                        return "historyReturnMax: integer expected";
                if (message.historyReturnWindow != null && message.hasOwnProperty("historyReturnWindow"))
                    if (!$util.isInteger(message.historyReturnWindow))
                        return "historyReturnWindow: integer expected";
                if (message.isServer != null && message.hasOwnProperty("isServer"))
                    if (typeof message.isServer !== "boolean")
                        return "isServer: boolean expected";
                return null;
            };

            /**
             * Creates a StoreForwardConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.StoreForwardConfig} StoreForwardConfig
             */
            StoreForwardConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.StoreForwardConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.StoreForwardConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.heartbeat != null)
                    message.heartbeat = Boolean(object.heartbeat);
                if (object.records != null)
                    message.records = object.records >>> 0;
                if (object.historyReturnMax != null)
                    message.historyReturnMax = object.historyReturnMax >>> 0;
                if (object.historyReturnWindow != null)
                    message.historyReturnWindow = object.historyReturnWindow >>> 0;
                if (object.isServer != null)
                    message.isServer = Boolean(object.isServer);
                return message;
            };

            /**
             * Creates a plain object from a StoreForwardConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {meshtastic.ModuleConfig.StoreForwardConfig} message StoreForwardConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreForwardConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.heartbeat = false;
                    object.records = 0;
                    object.historyReturnMax = 0;
                    object.historyReturnWindow = 0;
                    object.isServer = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.heartbeat != null && message.hasOwnProperty("heartbeat"))
                    object.heartbeat = message.heartbeat;
                if (message.records != null && message.hasOwnProperty("records"))
                    object.records = message.records;
                if (message.historyReturnMax != null && message.hasOwnProperty("historyReturnMax"))
                    object.historyReturnMax = message.historyReturnMax;
                if (message.historyReturnWindow != null && message.hasOwnProperty("historyReturnWindow"))
                    object.historyReturnWindow = message.historyReturnWindow;
                if (message.isServer != null && message.hasOwnProperty("isServer"))
                    object.isServer = message.isServer;
                return object;
            };

            /**
             * Converts this StoreForwardConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoreForwardConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StoreForwardConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.StoreForwardConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StoreForwardConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.StoreForwardConfig";
            };

            return StoreForwardConfig;
        })();

        ModuleConfig.RangeTestConfig = (function() {

            /**
             * Properties of a RangeTestConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IRangeTestConfig
             * @property {boolean|null} [enabled] RangeTestConfig enabled
             * @property {number|null} [sender] RangeTestConfig sender
             * @property {boolean|null} [save] RangeTestConfig save
             * @property {boolean|null} [clearOnReboot] RangeTestConfig clearOnReboot
             */

            /**
             * Constructs a new RangeTestConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a RangeTestConfig.
             * @implements IRangeTestConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IRangeTestConfig=} [properties] Properties to set
             */
            function RangeTestConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RangeTestConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @instance
             */
            RangeTestConfig.prototype.enabled = false;

            /**
             * RangeTestConfig sender.
             * @member {number} sender
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @instance
             */
            RangeTestConfig.prototype.sender = 0;

            /**
             * RangeTestConfig save.
             * @member {boolean} save
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @instance
             */
            RangeTestConfig.prototype.save = false;

            /**
             * RangeTestConfig clearOnReboot.
             * @member {boolean} clearOnReboot
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @instance
             */
            RangeTestConfig.prototype.clearOnReboot = false;

            /**
             * Creates a new RangeTestConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRangeTestConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.RangeTestConfig} RangeTestConfig instance
             */
            RangeTestConfig.create = function create(properties) {
                return new RangeTestConfig(properties);
            };

            /**
             * Encodes the specified RangeTestConfig message. Does not implicitly {@link meshtastic.ModuleConfig.RangeTestConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRangeTestConfig} message RangeTestConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeTestConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.sender);
                if (message.save != null && Object.hasOwnProperty.call(message, "save"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.save);
                if (message.clearOnReboot != null && Object.hasOwnProperty.call(message, "clearOnReboot"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.clearOnReboot);
                return writer;
            };

            /**
             * Encodes the specified RangeTestConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.RangeTestConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {meshtastic.ModuleConfig.IRangeTestConfig} message RangeTestConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeTestConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RangeTestConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.RangeTestConfig} RangeTestConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeTestConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.RangeTestConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.sender = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.save = reader.bool();
                            break;
                        }
                    case 4: {
                            message.clearOnReboot = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RangeTestConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.RangeTestConfig} RangeTestConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeTestConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RangeTestConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RangeTestConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.sender != null && message.hasOwnProperty("sender"))
                    if (!$util.isInteger(message.sender))
                        return "sender: integer expected";
                if (message.save != null && message.hasOwnProperty("save"))
                    if (typeof message.save !== "boolean")
                        return "save: boolean expected";
                if (message.clearOnReboot != null && message.hasOwnProperty("clearOnReboot"))
                    if (typeof message.clearOnReboot !== "boolean")
                        return "clearOnReboot: boolean expected";
                return null;
            };

            /**
             * Creates a RangeTestConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.RangeTestConfig} RangeTestConfig
             */
            RangeTestConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.RangeTestConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.RangeTestConfig();
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.sender != null)
                    message.sender = object.sender >>> 0;
                if (object.save != null)
                    message.save = Boolean(object.save);
                if (object.clearOnReboot != null)
                    message.clearOnReboot = Boolean(object.clearOnReboot);
                return message;
            };

            /**
             * Creates a plain object from a RangeTestConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {meshtastic.ModuleConfig.RangeTestConfig} message RangeTestConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeTestConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.enabled = false;
                    object.sender = 0;
                    object.save = false;
                    object.clearOnReboot = false;
                }
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = message.sender;
                if (message.save != null && message.hasOwnProperty("save"))
                    object.save = message.save;
                if (message.clearOnReboot != null && message.hasOwnProperty("clearOnReboot"))
                    object.clearOnReboot = message.clearOnReboot;
                return object;
            };

            /**
             * Converts this RangeTestConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RangeTestConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RangeTestConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.RangeTestConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RangeTestConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.RangeTestConfig";
            };

            return RangeTestConfig;
        })();

        ModuleConfig.TelemetryConfig = (function() {

            /**
             * Properties of a TelemetryConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface ITelemetryConfig
             * @property {number|null} [deviceUpdateInterval] TelemetryConfig deviceUpdateInterval
             * @property {number|null} [environmentUpdateInterval] TelemetryConfig environmentUpdateInterval
             * @property {boolean|null} [environmentMeasurementEnabled] TelemetryConfig environmentMeasurementEnabled
             * @property {boolean|null} [environmentScreenEnabled] TelemetryConfig environmentScreenEnabled
             * @property {boolean|null} [environmentDisplayFahrenheit] TelemetryConfig environmentDisplayFahrenheit
             * @property {boolean|null} [airQualityEnabled] TelemetryConfig airQualityEnabled
             * @property {number|null} [airQualityInterval] TelemetryConfig airQualityInterval
             * @property {boolean|null} [powerMeasurementEnabled] TelemetryConfig powerMeasurementEnabled
             * @property {number|null} [powerUpdateInterval] TelemetryConfig powerUpdateInterval
             * @property {boolean|null} [powerScreenEnabled] TelemetryConfig powerScreenEnabled
             * @property {boolean|null} [healthMeasurementEnabled] TelemetryConfig healthMeasurementEnabled
             * @property {number|null} [healthUpdateInterval] TelemetryConfig healthUpdateInterval
             * @property {boolean|null} [healthScreenEnabled] TelemetryConfig healthScreenEnabled
             * @property {boolean|null} [deviceTelemetryEnabled] TelemetryConfig deviceTelemetryEnabled
             */

            /**
             * Constructs a new TelemetryConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a TelemetryConfig.
             * @implements ITelemetryConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.ITelemetryConfig=} [properties] Properties to set
             */
            function TelemetryConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TelemetryConfig deviceUpdateInterval.
             * @member {number} deviceUpdateInterval
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.deviceUpdateInterval = 0;

            /**
             * TelemetryConfig environmentUpdateInterval.
             * @member {number} environmentUpdateInterval
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.environmentUpdateInterval = 0;

            /**
             * TelemetryConfig environmentMeasurementEnabled.
             * @member {boolean} environmentMeasurementEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.environmentMeasurementEnabled = false;

            /**
             * TelemetryConfig environmentScreenEnabled.
             * @member {boolean} environmentScreenEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.environmentScreenEnabled = false;

            /**
             * TelemetryConfig environmentDisplayFahrenheit.
             * @member {boolean} environmentDisplayFahrenheit
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.environmentDisplayFahrenheit = false;

            /**
             * TelemetryConfig airQualityEnabled.
             * @member {boolean} airQualityEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.airQualityEnabled = false;

            /**
             * TelemetryConfig airQualityInterval.
             * @member {number} airQualityInterval
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.airQualityInterval = 0;

            /**
             * TelemetryConfig powerMeasurementEnabled.
             * @member {boolean} powerMeasurementEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.powerMeasurementEnabled = false;

            /**
             * TelemetryConfig powerUpdateInterval.
             * @member {number} powerUpdateInterval
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.powerUpdateInterval = 0;

            /**
             * TelemetryConfig powerScreenEnabled.
             * @member {boolean} powerScreenEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.powerScreenEnabled = false;

            /**
             * TelemetryConfig healthMeasurementEnabled.
             * @member {boolean} healthMeasurementEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.healthMeasurementEnabled = false;

            /**
             * TelemetryConfig healthUpdateInterval.
             * @member {number} healthUpdateInterval
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.healthUpdateInterval = 0;

            /**
             * TelemetryConfig healthScreenEnabled.
             * @member {boolean} healthScreenEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.healthScreenEnabled = false;

            /**
             * TelemetryConfig deviceTelemetryEnabled.
             * @member {boolean} deviceTelemetryEnabled
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             */
            TelemetryConfig.prototype.deviceTelemetryEnabled = false;

            /**
             * Creates a new TelemetryConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {meshtastic.ModuleConfig.ITelemetryConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.TelemetryConfig} TelemetryConfig instance
             */
            TelemetryConfig.create = function create(properties) {
                return new TelemetryConfig(properties);
            };

            /**
             * Encodes the specified TelemetryConfig message. Does not implicitly {@link meshtastic.ModuleConfig.TelemetryConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {meshtastic.ModuleConfig.ITelemetryConfig} message TelemetryConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TelemetryConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deviceUpdateInterval != null && Object.hasOwnProperty.call(message, "deviceUpdateInterval"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.deviceUpdateInterval);
                if (message.environmentUpdateInterval != null && Object.hasOwnProperty.call(message, "environmentUpdateInterval"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.environmentUpdateInterval);
                if (message.environmentMeasurementEnabled != null && Object.hasOwnProperty.call(message, "environmentMeasurementEnabled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.environmentMeasurementEnabled);
                if (message.environmentScreenEnabled != null && Object.hasOwnProperty.call(message, "environmentScreenEnabled"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.environmentScreenEnabled);
                if (message.environmentDisplayFahrenheit != null && Object.hasOwnProperty.call(message, "environmentDisplayFahrenheit"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.environmentDisplayFahrenheit);
                if (message.airQualityEnabled != null && Object.hasOwnProperty.call(message, "airQualityEnabled"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.airQualityEnabled);
                if (message.airQualityInterval != null && Object.hasOwnProperty.call(message, "airQualityInterval"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.airQualityInterval);
                if (message.powerMeasurementEnabled != null && Object.hasOwnProperty.call(message, "powerMeasurementEnabled"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.powerMeasurementEnabled);
                if (message.powerUpdateInterval != null && Object.hasOwnProperty.call(message, "powerUpdateInterval"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.powerUpdateInterval);
                if (message.powerScreenEnabled != null && Object.hasOwnProperty.call(message, "powerScreenEnabled"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.powerScreenEnabled);
                if (message.healthMeasurementEnabled != null && Object.hasOwnProperty.call(message, "healthMeasurementEnabled"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.healthMeasurementEnabled);
                if (message.healthUpdateInterval != null && Object.hasOwnProperty.call(message, "healthUpdateInterval"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.healthUpdateInterval);
                if (message.healthScreenEnabled != null && Object.hasOwnProperty.call(message, "healthScreenEnabled"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.healthScreenEnabled);
                if (message.deviceTelemetryEnabled != null && Object.hasOwnProperty.call(message, "deviceTelemetryEnabled"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.deviceTelemetryEnabled);
                return writer;
            };

            /**
             * Encodes the specified TelemetryConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.TelemetryConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {meshtastic.ModuleConfig.ITelemetryConfig} message TelemetryConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TelemetryConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TelemetryConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.TelemetryConfig} TelemetryConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TelemetryConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.TelemetryConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.deviceUpdateInterval = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.environmentUpdateInterval = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.environmentMeasurementEnabled = reader.bool();
                            break;
                        }
                    case 4: {
                            message.environmentScreenEnabled = reader.bool();
                            break;
                        }
                    case 5: {
                            message.environmentDisplayFahrenheit = reader.bool();
                            break;
                        }
                    case 6: {
                            message.airQualityEnabled = reader.bool();
                            break;
                        }
                    case 7: {
                            message.airQualityInterval = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.powerMeasurementEnabled = reader.bool();
                            break;
                        }
                    case 9: {
                            message.powerUpdateInterval = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.powerScreenEnabled = reader.bool();
                            break;
                        }
                    case 11: {
                            message.healthMeasurementEnabled = reader.bool();
                            break;
                        }
                    case 12: {
                            message.healthUpdateInterval = reader.uint32();
                            break;
                        }
                    case 13: {
                            message.healthScreenEnabled = reader.bool();
                            break;
                        }
                    case 14: {
                            message.deviceTelemetryEnabled = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TelemetryConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.TelemetryConfig} TelemetryConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TelemetryConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TelemetryConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TelemetryConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deviceUpdateInterval != null && message.hasOwnProperty("deviceUpdateInterval"))
                    if (!$util.isInteger(message.deviceUpdateInterval))
                        return "deviceUpdateInterval: integer expected";
                if (message.environmentUpdateInterval != null && message.hasOwnProperty("environmentUpdateInterval"))
                    if (!$util.isInteger(message.environmentUpdateInterval))
                        return "environmentUpdateInterval: integer expected";
                if (message.environmentMeasurementEnabled != null && message.hasOwnProperty("environmentMeasurementEnabled"))
                    if (typeof message.environmentMeasurementEnabled !== "boolean")
                        return "environmentMeasurementEnabled: boolean expected";
                if (message.environmentScreenEnabled != null && message.hasOwnProperty("environmentScreenEnabled"))
                    if (typeof message.environmentScreenEnabled !== "boolean")
                        return "environmentScreenEnabled: boolean expected";
                if (message.environmentDisplayFahrenheit != null && message.hasOwnProperty("environmentDisplayFahrenheit"))
                    if (typeof message.environmentDisplayFahrenheit !== "boolean")
                        return "environmentDisplayFahrenheit: boolean expected";
                if (message.airQualityEnabled != null && message.hasOwnProperty("airQualityEnabled"))
                    if (typeof message.airQualityEnabled !== "boolean")
                        return "airQualityEnabled: boolean expected";
                if (message.airQualityInterval != null && message.hasOwnProperty("airQualityInterval"))
                    if (!$util.isInteger(message.airQualityInterval))
                        return "airQualityInterval: integer expected";
                if (message.powerMeasurementEnabled != null && message.hasOwnProperty("powerMeasurementEnabled"))
                    if (typeof message.powerMeasurementEnabled !== "boolean")
                        return "powerMeasurementEnabled: boolean expected";
                if (message.powerUpdateInterval != null && message.hasOwnProperty("powerUpdateInterval"))
                    if (!$util.isInteger(message.powerUpdateInterval))
                        return "powerUpdateInterval: integer expected";
                if (message.powerScreenEnabled != null && message.hasOwnProperty("powerScreenEnabled"))
                    if (typeof message.powerScreenEnabled !== "boolean")
                        return "powerScreenEnabled: boolean expected";
                if (message.healthMeasurementEnabled != null && message.hasOwnProperty("healthMeasurementEnabled"))
                    if (typeof message.healthMeasurementEnabled !== "boolean")
                        return "healthMeasurementEnabled: boolean expected";
                if (message.healthUpdateInterval != null && message.hasOwnProperty("healthUpdateInterval"))
                    if (!$util.isInteger(message.healthUpdateInterval))
                        return "healthUpdateInterval: integer expected";
                if (message.healthScreenEnabled != null && message.hasOwnProperty("healthScreenEnabled"))
                    if (typeof message.healthScreenEnabled !== "boolean")
                        return "healthScreenEnabled: boolean expected";
                if (message.deviceTelemetryEnabled != null && message.hasOwnProperty("deviceTelemetryEnabled"))
                    if (typeof message.deviceTelemetryEnabled !== "boolean")
                        return "deviceTelemetryEnabled: boolean expected";
                return null;
            };

            /**
             * Creates a TelemetryConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.TelemetryConfig} TelemetryConfig
             */
            TelemetryConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.TelemetryConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.TelemetryConfig();
                if (object.deviceUpdateInterval != null)
                    message.deviceUpdateInterval = object.deviceUpdateInterval >>> 0;
                if (object.environmentUpdateInterval != null)
                    message.environmentUpdateInterval = object.environmentUpdateInterval >>> 0;
                if (object.environmentMeasurementEnabled != null)
                    message.environmentMeasurementEnabled = Boolean(object.environmentMeasurementEnabled);
                if (object.environmentScreenEnabled != null)
                    message.environmentScreenEnabled = Boolean(object.environmentScreenEnabled);
                if (object.environmentDisplayFahrenheit != null)
                    message.environmentDisplayFahrenheit = Boolean(object.environmentDisplayFahrenheit);
                if (object.airQualityEnabled != null)
                    message.airQualityEnabled = Boolean(object.airQualityEnabled);
                if (object.airQualityInterval != null)
                    message.airQualityInterval = object.airQualityInterval >>> 0;
                if (object.powerMeasurementEnabled != null)
                    message.powerMeasurementEnabled = Boolean(object.powerMeasurementEnabled);
                if (object.powerUpdateInterval != null)
                    message.powerUpdateInterval = object.powerUpdateInterval >>> 0;
                if (object.powerScreenEnabled != null)
                    message.powerScreenEnabled = Boolean(object.powerScreenEnabled);
                if (object.healthMeasurementEnabled != null)
                    message.healthMeasurementEnabled = Boolean(object.healthMeasurementEnabled);
                if (object.healthUpdateInterval != null)
                    message.healthUpdateInterval = object.healthUpdateInterval >>> 0;
                if (object.healthScreenEnabled != null)
                    message.healthScreenEnabled = Boolean(object.healthScreenEnabled);
                if (object.deviceTelemetryEnabled != null)
                    message.deviceTelemetryEnabled = Boolean(object.deviceTelemetryEnabled);
                return message;
            };

            /**
             * Creates a plain object from a TelemetryConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {meshtastic.ModuleConfig.TelemetryConfig} message TelemetryConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TelemetryConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.deviceUpdateInterval = 0;
                    object.environmentUpdateInterval = 0;
                    object.environmentMeasurementEnabled = false;
                    object.environmentScreenEnabled = false;
                    object.environmentDisplayFahrenheit = false;
                    object.airQualityEnabled = false;
                    object.airQualityInterval = 0;
                    object.powerMeasurementEnabled = false;
                    object.powerUpdateInterval = 0;
                    object.powerScreenEnabled = false;
                    object.healthMeasurementEnabled = false;
                    object.healthUpdateInterval = 0;
                    object.healthScreenEnabled = false;
                    object.deviceTelemetryEnabled = false;
                }
                if (message.deviceUpdateInterval != null && message.hasOwnProperty("deviceUpdateInterval"))
                    object.deviceUpdateInterval = message.deviceUpdateInterval;
                if (message.environmentUpdateInterval != null && message.hasOwnProperty("environmentUpdateInterval"))
                    object.environmentUpdateInterval = message.environmentUpdateInterval;
                if (message.environmentMeasurementEnabled != null && message.hasOwnProperty("environmentMeasurementEnabled"))
                    object.environmentMeasurementEnabled = message.environmentMeasurementEnabled;
                if (message.environmentScreenEnabled != null && message.hasOwnProperty("environmentScreenEnabled"))
                    object.environmentScreenEnabled = message.environmentScreenEnabled;
                if (message.environmentDisplayFahrenheit != null && message.hasOwnProperty("environmentDisplayFahrenheit"))
                    object.environmentDisplayFahrenheit = message.environmentDisplayFahrenheit;
                if (message.airQualityEnabled != null && message.hasOwnProperty("airQualityEnabled"))
                    object.airQualityEnabled = message.airQualityEnabled;
                if (message.airQualityInterval != null && message.hasOwnProperty("airQualityInterval"))
                    object.airQualityInterval = message.airQualityInterval;
                if (message.powerMeasurementEnabled != null && message.hasOwnProperty("powerMeasurementEnabled"))
                    object.powerMeasurementEnabled = message.powerMeasurementEnabled;
                if (message.powerUpdateInterval != null && message.hasOwnProperty("powerUpdateInterval"))
                    object.powerUpdateInterval = message.powerUpdateInterval;
                if (message.powerScreenEnabled != null && message.hasOwnProperty("powerScreenEnabled"))
                    object.powerScreenEnabled = message.powerScreenEnabled;
                if (message.healthMeasurementEnabled != null && message.hasOwnProperty("healthMeasurementEnabled"))
                    object.healthMeasurementEnabled = message.healthMeasurementEnabled;
                if (message.healthUpdateInterval != null && message.hasOwnProperty("healthUpdateInterval"))
                    object.healthUpdateInterval = message.healthUpdateInterval;
                if (message.healthScreenEnabled != null && message.hasOwnProperty("healthScreenEnabled"))
                    object.healthScreenEnabled = message.healthScreenEnabled;
                if (message.deviceTelemetryEnabled != null && message.hasOwnProperty("deviceTelemetryEnabled"))
                    object.deviceTelemetryEnabled = message.deviceTelemetryEnabled;
                return object;
            };

            /**
             * Converts this TelemetryConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TelemetryConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TelemetryConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.TelemetryConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TelemetryConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.TelemetryConfig";
            };

            return TelemetryConfig;
        })();

        ModuleConfig.CannedMessageConfig = (function() {

            /**
             * Properties of a CannedMessageConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface ICannedMessageConfig
             * @property {boolean|null} [rotary1Enabled] CannedMessageConfig rotary1Enabled
             * @property {number|null} [inputbrokerPinA] CannedMessageConfig inputbrokerPinA
             * @property {number|null} [inputbrokerPinB] CannedMessageConfig inputbrokerPinB
             * @property {number|null} [inputbrokerPinPress] CannedMessageConfig inputbrokerPinPress
             * @property {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar|null} [inputbrokerEventCw] CannedMessageConfig inputbrokerEventCw
             * @property {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar|null} [inputbrokerEventCcw] CannedMessageConfig inputbrokerEventCcw
             * @property {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar|null} [inputbrokerEventPress] CannedMessageConfig inputbrokerEventPress
             * @property {boolean|null} [updown1Enabled] CannedMessageConfig updown1Enabled
             * @property {boolean|null} [enabled] CannedMessageConfig enabled
             * @property {string|null} [allowInputSource] CannedMessageConfig allowInputSource
             * @property {boolean|null} [sendBell] CannedMessageConfig sendBell
             */

            /**
             * Constructs a new CannedMessageConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents a CannedMessageConfig.
             * @implements ICannedMessageConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.ICannedMessageConfig=} [properties] Properties to set
             */
            function CannedMessageConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CannedMessageConfig rotary1Enabled.
             * @member {boolean} rotary1Enabled
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.rotary1Enabled = false;

            /**
             * CannedMessageConfig inputbrokerPinA.
             * @member {number} inputbrokerPinA
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerPinA = 0;

            /**
             * CannedMessageConfig inputbrokerPinB.
             * @member {number} inputbrokerPinB
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerPinB = 0;

            /**
             * CannedMessageConfig inputbrokerPinPress.
             * @member {number} inputbrokerPinPress
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerPinPress = 0;

            /**
             * CannedMessageConfig inputbrokerEventCw.
             * @member {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar} inputbrokerEventCw
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerEventCw = 0;

            /**
             * CannedMessageConfig inputbrokerEventCcw.
             * @member {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar} inputbrokerEventCcw
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerEventCcw = 0;

            /**
             * CannedMessageConfig inputbrokerEventPress.
             * @member {meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar} inputbrokerEventPress
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.inputbrokerEventPress = 0;

            /**
             * CannedMessageConfig updown1Enabled.
             * @member {boolean} updown1Enabled
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.updown1Enabled = false;

            /**
             * CannedMessageConfig enabled.
             * @member {boolean} enabled
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.enabled = false;

            /**
             * CannedMessageConfig allowInputSource.
             * @member {string} allowInputSource
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.allowInputSource = "";

            /**
             * CannedMessageConfig sendBell.
             * @member {boolean} sendBell
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             */
            CannedMessageConfig.prototype.sendBell = false;

            /**
             * Creates a new CannedMessageConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {meshtastic.ModuleConfig.ICannedMessageConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.CannedMessageConfig} CannedMessageConfig instance
             */
            CannedMessageConfig.create = function create(properties) {
                return new CannedMessageConfig(properties);
            };

            /**
             * Encodes the specified CannedMessageConfig message. Does not implicitly {@link meshtastic.ModuleConfig.CannedMessageConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {meshtastic.ModuleConfig.ICannedMessageConfig} message CannedMessageConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CannedMessageConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rotary1Enabled != null && Object.hasOwnProperty.call(message, "rotary1Enabled"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.rotary1Enabled);
                if (message.inputbrokerPinA != null && Object.hasOwnProperty.call(message, "inputbrokerPinA"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.inputbrokerPinA);
                if (message.inputbrokerPinB != null && Object.hasOwnProperty.call(message, "inputbrokerPinB"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.inputbrokerPinB);
                if (message.inputbrokerPinPress != null && Object.hasOwnProperty.call(message, "inputbrokerPinPress"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.inputbrokerPinPress);
                if (message.inputbrokerEventCw != null && Object.hasOwnProperty.call(message, "inputbrokerEventCw"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.inputbrokerEventCw);
                if (message.inputbrokerEventCcw != null && Object.hasOwnProperty.call(message, "inputbrokerEventCcw"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.inputbrokerEventCcw);
                if (message.inputbrokerEventPress != null && Object.hasOwnProperty.call(message, "inputbrokerEventPress"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.inputbrokerEventPress);
                if (message.updown1Enabled != null && Object.hasOwnProperty.call(message, "updown1Enabled"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.updown1Enabled);
                if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.enabled);
                if (message.allowInputSource != null && Object.hasOwnProperty.call(message, "allowInputSource"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.allowInputSource);
                if (message.sendBell != null && Object.hasOwnProperty.call(message, "sendBell"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.sendBell);
                return writer;
            };

            /**
             * Encodes the specified CannedMessageConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.CannedMessageConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {meshtastic.ModuleConfig.ICannedMessageConfig} message CannedMessageConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CannedMessageConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CannedMessageConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.CannedMessageConfig} CannedMessageConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CannedMessageConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.CannedMessageConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.rotary1Enabled = reader.bool();
                            break;
                        }
                    case 2: {
                            message.inputbrokerPinA = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.inputbrokerPinB = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.inputbrokerPinPress = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.inputbrokerEventCw = reader.int32();
                            break;
                        }
                    case 6: {
                            message.inputbrokerEventCcw = reader.int32();
                            break;
                        }
                    case 7: {
                            message.inputbrokerEventPress = reader.int32();
                            break;
                        }
                    case 8: {
                            message.updown1Enabled = reader.bool();
                            break;
                        }
                    case 9: {
                            message.enabled = reader.bool();
                            break;
                        }
                    case 10: {
                            message.allowInputSource = reader.string();
                            break;
                        }
                    case 11: {
                            message.sendBell = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CannedMessageConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.CannedMessageConfig} CannedMessageConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CannedMessageConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CannedMessageConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CannedMessageConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rotary1Enabled != null && message.hasOwnProperty("rotary1Enabled"))
                    if (typeof message.rotary1Enabled !== "boolean")
                        return "rotary1Enabled: boolean expected";
                if (message.inputbrokerPinA != null && message.hasOwnProperty("inputbrokerPinA"))
                    if (!$util.isInteger(message.inputbrokerPinA))
                        return "inputbrokerPinA: integer expected";
                if (message.inputbrokerPinB != null && message.hasOwnProperty("inputbrokerPinB"))
                    if (!$util.isInteger(message.inputbrokerPinB))
                        return "inputbrokerPinB: integer expected";
                if (message.inputbrokerPinPress != null && message.hasOwnProperty("inputbrokerPinPress"))
                    if (!$util.isInteger(message.inputbrokerPinPress))
                        return "inputbrokerPinPress: integer expected";
                if (message.inputbrokerEventCw != null && message.hasOwnProperty("inputbrokerEventCw"))
                    switch (message.inputbrokerEventCw) {
                    default:
                        return "inputbrokerEventCw: enum value expected";
                    case 0:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 10:
                    case 27:
                    case 24:
                        break;
                    }
                if (message.inputbrokerEventCcw != null && message.hasOwnProperty("inputbrokerEventCcw"))
                    switch (message.inputbrokerEventCcw) {
                    default:
                        return "inputbrokerEventCcw: enum value expected";
                    case 0:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 10:
                    case 27:
                    case 24:
                        break;
                    }
                if (message.inputbrokerEventPress != null && message.hasOwnProperty("inputbrokerEventPress"))
                    switch (message.inputbrokerEventPress) {
                    default:
                        return "inputbrokerEventPress: enum value expected";
                    case 0:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 10:
                    case 27:
                    case 24:
                        break;
                    }
                if (message.updown1Enabled != null && message.hasOwnProperty("updown1Enabled"))
                    if (typeof message.updown1Enabled !== "boolean")
                        return "updown1Enabled: boolean expected";
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    if (typeof message.enabled !== "boolean")
                        return "enabled: boolean expected";
                if (message.allowInputSource != null && message.hasOwnProperty("allowInputSource"))
                    if (!$util.isString(message.allowInputSource))
                        return "allowInputSource: string expected";
                if (message.sendBell != null && message.hasOwnProperty("sendBell"))
                    if (typeof message.sendBell !== "boolean")
                        return "sendBell: boolean expected";
                return null;
            };

            /**
             * Creates a CannedMessageConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.CannedMessageConfig} CannedMessageConfig
             */
            CannedMessageConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.CannedMessageConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.CannedMessageConfig();
                if (object.rotary1Enabled != null)
                    message.rotary1Enabled = Boolean(object.rotary1Enabled);
                if (object.inputbrokerPinA != null)
                    message.inputbrokerPinA = object.inputbrokerPinA >>> 0;
                if (object.inputbrokerPinB != null)
                    message.inputbrokerPinB = object.inputbrokerPinB >>> 0;
                if (object.inputbrokerPinPress != null)
                    message.inputbrokerPinPress = object.inputbrokerPinPress >>> 0;
                switch (object.inputbrokerEventCw) {
                default:
                    if (typeof object.inputbrokerEventCw === "number") {
                        message.inputbrokerEventCw = object.inputbrokerEventCw;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.inputbrokerEventCw = 0;
                    break;
                case "UP":
                case 17:
                    message.inputbrokerEventCw = 17;
                    break;
                case "DOWN":
                case 18:
                    message.inputbrokerEventCw = 18;
                    break;
                case "LEFT":
                case 19:
                    message.inputbrokerEventCw = 19;
                    break;
                case "RIGHT":
                case 20:
                    message.inputbrokerEventCw = 20;
                    break;
                case "SELECT":
                case 10:
                    message.inputbrokerEventCw = 10;
                    break;
                case "BACK":
                case 27:
                    message.inputbrokerEventCw = 27;
                    break;
                case "CANCEL":
                case 24:
                    message.inputbrokerEventCw = 24;
                    break;
                }
                switch (object.inputbrokerEventCcw) {
                default:
                    if (typeof object.inputbrokerEventCcw === "number") {
                        message.inputbrokerEventCcw = object.inputbrokerEventCcw;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.inputbrokerEventCcw = 0;
                    break;
                case "UP":
                case 17:
                    message.inputbrokerEventCcw = 17;
                    break;
                case "DOWN":
                case 18:
                    message.inputbrokerEventCcw = 18;
                    break;
                case "LEFT":
                case 19:
                    message.inputbrokerEventCcw = 19;
                    break;
                case "RIGHT":
                case 20:
                    message.inputbrokerEventCcw = 20;
                    break;
                case "SELECT":
                case 10:
                    message.inputbrokerEventCcw = 10;
                    break;
                case "BACK":
                case 27:
                    message.inputbrokerEventCcw = 27;
                    break;
                case "CANCEL":
                case 24:
                    message.inputbrokerEventCcw = 24;
                    break;
                }
                switch (object.inputbrokerEventPress) {
                default:
                    if (typeof object.inputbrokerEventPress === "number") {
                        message.inputbrokerEventPress = object.inputbrokerEventPress;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.inputbrokerEventPress = 0;
                    break;
                case "UP":
                case 17:
                    message.inputbrokerEventPress = 17;
                    break;
                case "DOWN":
                case 18:
                    message.inputbrokerEventPress = 18;
                    break;
                case "LEFT":
                case 19:
                    message.inputbrokerEventPress = 19;
                    break;
                case "RIGHT":
                case 20:
                    message.inputbrokerEventPress = 20;
                    break;
                case "SELECT":
                case 10:
                    message.inputbrokerEventPress = 10;
                    break;
                case "BACK":
                case 27:
                    message.inputbrokerEventPress = 27;
                    break;
                case "CANCEL":
                case 24:
                    message.inputbrokerEventPress = 24;
                    break;
                }
                if (object.updown1Enabled != null)
                    message.updown1Enabled = Boolean(object.updown1Enabled);
                if (object.enabled != null)
                    message.enabled = Boolean(object.enabled);
                if (object.allowInputSource != null)
                    message.allowInputSource = String(object.allowInputSource);
                if (object.sendBell != null)
                    message.sendBell = Boolean(object.sendBell);
                return message;
            };

            /**
             * Creates a plain object from a CannedMessageConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {meshtastic.ModuleConfig.CannedMessageConfig} message CannedMessageConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CannedMessageConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.rotary1Enabled = false;
                    object.inputbrokerPinA = 0;
                    object.inputbrokerPinB = 0;
                    object.inputbrokerPinPress = 0;
                    object.inputbrokerEventCw = options.enums === String ? "NONE" : 0;
                    object.inputbrokerEventCcw = options.enums === String ? "NONE" : 0;
                    object.inputbrokerEventPress = options.enums === String ? "NONE" : 0;
                    object.updown1Enabled = false;
                    object.enabled = false;
                    object.allowInputSource = "";
                    object.sendBell = false;
                }
                if (message.rotary1Enabled != null && message.hasOwnProperty("rotary1Enabled"))
                    object.rotary1Enabled = message.rotary1Enabled;
                if (message.inputbrokerPinA != null && message.hasOwnProperty("inputbrokerPinA"))
                    object.inputbrokerPinA = message.inputbrokerPinA;
                if (message.inputbrokerPinB != null && message.hasOwnProperty("inputbrokerPinB"))
                    object.inputbrokerPinB = message.inputbrokerPinB;
                if (message.inputbrokerPinPress != null && message.hasOwnProperty("inputbrokerPinPress"))
                    object.inputbrokerPinPress = message.inputbrokerPinPress;
                if (message.inputbrokerEventCw != null && message.hasOwnProperty("inputbrokerEventCw"))
                    object.inputbrokerEventCw = options.enums === String ? $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventCw] === undefined ? message.inputbrokerEventCw : $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventCw] : message.inputbrokerEventCw;
                if (message.inputbrokerEventCcw != null && message.hasOwnProperty("inputbrokerEventCcw"))
                    object.inputbrokerEventCcw = options.enums === String ? $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventCcw] === undefined ? message.inputbrokerEventCcw : $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventCcw] : message.inputbrokerEventCcw;
                if (message.inputbrokerEventPress != null && message.hasOwnProperty("inputbrokerEventPress"))
                    object.inputbrokerEventPress = options.enums === String ? $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventPress] === undefined ? message.inputbrokerEventPress : $root.meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar[message.inputbrokerEventPress] : message.inputbrokerEventPress;
                if (message.updown1Enabled != null && message.hasOwnProperty("updown1Enabled"))
                    object.updown1Enabled = message.updown1Enabled;
                if (message.enabled != null && message.hasOwnProperty("enabled"))
                    object.enabled = message.enabled;
                if (message.allowInputSource != null && message.hasOwnProperty("allowInputSource"))
                    object.allowInputSource = message.allowInputSource;
                if (message.sendBell != null && message.hasOwnProperty("sendBell"))
                    object.sendBell = message.sendBell;
                return object;
            };

            /**
             * Converts this CannedMessageConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CannedMessageConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CannedMessageConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.CannedMessageConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CannedMessageConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.CannedMessageConfig";
            };

            /**
             * InputEventChar enum.
             * @name meshtastic.ModuleConfig.CannedMessageConfig.InputEventChar
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} UP=17 UP value
             * @property {number} DOWN=18 DOWN value
             * @property {number} LEFT=19 LEFT value
             * @property {number} RIGHT=20 RIGHT value
             * @property {number} SELECT=10 SELECT value
             * @property {number} BACK=27 BACK value
             * @property {number} CANCEL=24 CANCEL value
             */
            CannedMessageConfig.InputEventChar = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[17] = "UP"] = 17;
                values[valuesById[18] = "DOWN"] = 18;
                values[valuesById[19] = "LEFT"] = 19;
                values[valuesById[20] = "RIGHT"] = 20;
                values[valuesById[10] = "SELECT"] = 10;
                values[valuesById[27] = "BACK"] = 27;
                values[valuesById[24] = "CANCEL"] = 24;
                return values;
            })();

            return CannedMessageConfig;
        })();

        ModuleConfig.AmbientLightingConfig = (function() {

            /**
             * Properties of an AmbientLightingConfig.
             * @memberof meshtastic.ModuleConfig
             * @interface IAmbientLightingConfig
             * @property {boolean|null} [ledState] AmbientLightingConfig ledState
             * @property {number|null} [current] AmbientLightingConfig current
             * @property {number|null} [red] AmbientLightingConfig red
             * @property {number|null} [green] AmbientLightingConfig green
             * @property {number|null} [blue] AmbientLightingConfig blue
             */

            /**
             * Constructs a new AmbientLightingConfig.
             * @memberof meshtastic.ModuleConfig
             * @classdesc Represents an AmbientLightingConfig.
             * @implements IAmbientLightingConfig
             * @constructor
             * @param {meshtastic.ModuleConfig.IAmbientLightingConfig=} [properties] Properties to set
             */
            function AmbientLightingConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AmbientLightingConfig ledState.
             * @member {boolean} ledState
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             */
            AmbientLightingConfig.prototype.ledState = false;

            /**
             * AmbientLightingConfig current.
             * @member {number} current
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             */
            AmbientLightingConfig.prototype.current = 0;

            /**
             * AmbientLightingConfig red.
             * @member {number} red
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             */
            AmbientLightingConfig.prototype.red = 0;

            /**
             * AmbientLightingConfig green.
             * @member {number} green
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             */
            AmbientLightingConfig.prototype.green = 0;

            /**
             * AmbientLightingConfig blue.
             * @member {number} blue
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             */
            AmbientLightingConfig.prototype.blue = 0;

            /**
             * Creates a new AmbientLightingConfig instance using the specified properties.
             * @function create
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAmbientLightingConfig=} [properties] Properties to set
             * @returns {meshtastic.ModuleConfig.AmbientLightingConfig} AmbientLightingConfig instance
             */
            AmbientLightingConfig.create = function create(properties) {
                return new AmbientLightingConfig(properties);
            };

            /**
             * Encodes the specified AmbientLightingConfig message. Does not implicitly {@link meshtastic.ModuleConfig.AmbientLightingConfig.verify|verify} messages.
             * @function encode
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAmbientLightingConfig} message AmbientLightingConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AmbientLightingConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ledState != null && Object.hasOwnProperty.call(message, "ledState"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ledState);
                if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.current);
                if (message.red != null && Object.hasOwnProperty.call(message, "red"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.red);
                if (message.green != null && Object.hasOwnProperty.call(message, "green"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.green);
                if (message.blue != null && Object.hasOwnProperty.call(message, "blue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.blue);
                return writer;
            };

            /**
             * Encodes the specified AmbientLightingConfig message, length delimited. Does not implicitly {@link meshtastic.ModuleConfig.AmbientLightingConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {meshtastic.ModuleConfig.IAmbientLightingConfig} message AmbientLightingConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AmbientLightingConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AmbientLightingConfig message from the specified reader or buffer.
             * @function decode
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {meshtastic.ModuleConfig.AmbientLightingConfig} AmbientLightingConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AmbientLightingConfig.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.ModuleConfig.AmbientLightingConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.ledState = reader.bool();
                            break;
                        }
                    case 2: {
                            message.current = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.red = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.green = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.blue = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AmbientLightingConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {meshtastic.ModuleConfig.AmbientLightingConfig} AmbientLightingConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AmbientLightingConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AmbientLightingConfig message.
             * @function verify
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AmbientLightingConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ledState != null && message.hasOwnProperty("ledState"))
                    if (typeof message.ledState !== "boolean")
                        return "ledState: boolean expected";
                if (message.current != null && message.hasOwnProperty("current"))
                    if (!$util.isInteger(message.current))
                        return "current: integer expected";
                if (message.red != null && message.hasOwnProperty("red"))
                    if (!$util.isInteger(message.red))
                        return "red: integer expected";
                if (message.green != null && message.hasOwnProperty("green"))
                    if (!$util.isInteger(message.green))
                        return "green: integer expected";
                if (message.blue != null && message.hasOwnProperty("blue"))
                    if (!$util.isInteger(message.blue))
                        return "blue: integer expected";
                return null;
            };

            /**
             * Creates an AmbientLightingConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {meshtastic.ModuleConfig.AmbientLightingConfig} AmbientLightingConfig
             */
            AmbientLightingConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.meshtastic.ModuleConfig.AmbientLightingConfig)
                    return object;
                var message = new $root.meshtastic.ModuleConfig.AmbientLightingConfig();
                if (object.ledState != null)
                    message.ledState = Boolean(object.ledState);
                if (object.current != null)
                    message.current = object.current >>> 0;
                if (object.red != null)
                    message.red = object.red >>> 0;
                if (object.green != null)
                    message.green = object.green >>> 0;
                if (object.blue != null)
                    message.blue = object.blue >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an AmbientLightingConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {meshtastic.ModuleConfig.AmbientLightingConfig} message AmbientLightingConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AmbientLightingConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ledState = false;
                    object.current = 0;
                    object.red = 0;
                    object.green = 0;
                    object.blue = 0;
                }
                if (message.ledState != null && message.hasOwnProperty("ledState"))
                    object.ledState = message.ledState;
                if (message.current != null && message.hasOwnProperty("current"))
                    object.current = message.current;
                if (message.red != null && message.hasOwnProperty("red"))
                    object.red = message.red;
                if (message.green != null && message.hasOwnProperty("green"))
                    object.green = message.green;
                if (message.blue != null && message.hasOwnProperty("blue"))
                    object.blue = message.blue;
                return object;
            };

            /**
             * Converts this AmbientLightingConfig to JSON.
             * @function toJSON
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AmbientLightingConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AmbientLightingConfig
             * @function getTypeUrl
             * @memberof meshtastic.ModuleConfig.AmbientLightingConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AmbientLightingConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/meshtastic.ModuleConfig.AmbientLightingConfig";
            };

            return AmbientLightingConfig;
        })();

        return ModuleConfig;
    })();

    meshtastic.RemoteHardwarePin = (function() {

        /**
         * Properties of a RemoteHardwarePin.
         * @memberof meshtastic
         * @interface IRemoteHardwarePin
         * @property {number|null} [gpioPin] RemoteHardwarePin gpioPin
         * @property {string|null} [name] RemoteHardwarePin name
         * @property {meshtastic.RemoteHardwarePinType|null} [type] RemoteHardwarePin type
         */

        /**
         * Constructs a new RemoteHardwarePin.
         * @memberof meshtastic
         * @classdesc Represents a RemoteHardwarePin.
         * @implements IRemoteHardwarePin
         * @constructor
         * @param {meshtastic.IRemoteHardwarePin=} [properties] Properties to set
         */
        function RemoteHardwarePin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoteHardwarePin gpioPin.
         * @member {number} gpioPin
         * @memberof meshtastic.RemoteHardwarePin
         * @instance
         */
        RemoteHardwarePin.prototype.gpioPin = 0;

        /**
         * RemoteHardwarePin name.
         * @member {string} name
         * @memberof meshtastic.RemoteHardwarePin
         * @instance
         */
        RemoteHardwarePin.prototype.name = "";

        /**
         * RemoteHardwarePin type.
         * @member {meshtastic.RemoteHardwarePinType} type
         * @memberof meshtastic.RemoteHardwarePin
         * @instance
         */
        RemoteHardwarePin.prototype.type = 0;

        /**
         * Creates a new RemoteHardwarePin instance using the specified properties.
         * @function create
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {meshtastic.IRemoteHardwarePin=} [properties] Properties to set
         * @returns {meshtastic.RemoteHardwarePin} RemoteHardwarePin instance
         */
        RemoteHardwarePin.create = function create(properties) {
            return new RemoteHardwarePin(properties);
        };

        /**
         * Encodes the specified RemoteHardwarePin message. Does not implicitly {@link meshtastic.RemoteHardwarePin.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {meshtastic.IRemoteHardwarePin} message RemoteHardwarePin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoteHardwarePin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gpioPin != null && Object.hasOwnProperty.call(message, "gpioPin"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.gpioPin);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified RemoteHardwarePin message, length delimited. Does not implicitly {@link meshtastic.RemoteHardwarePin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {meshtastic.IRemoteHardwarePin} message RemoteHardwarePin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoteHardwarePin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoteHardwarePin message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.RemoteHardwarePin} RemoteHardwarePin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoteHardwarePin.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.RemoteHardwarePin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.gpioPin = reader.uint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoteHardwarePin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.RemoteHardwarePin} RemoteHardwarePin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoteHardwarePin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoteHardwarePin message.
         * @function verify
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoteHardwarePin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gpioPin != null && message.hasOwnProperty("gpioPin"))
                if (!$util.isInteger(message.gpioPin))
                    return "gpioPin: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RemoteHardwarePin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.RemoteHardwarePin} RemoteHardwarePin
         */
        RemoteHardwarePin.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.RemoteHardwarePin)
                return object;
            var message = new $root.meshtastic.RemoteHardwarePin();
            if (object.gpioPin != null)
                message.gpioPin = object.gpioPin >>> 0;
            if (object.name != null)
                message.name = String(object.name);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "DIGITAL_READ":
            case 1:
                message.type = 1;
                break;
            case "DIGITAL_WRITE":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RemoteHardwarePin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {meshtastic.RemoteHardwarePin} message RemoteHardwarePin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoteHardwarePin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gpioPin = 0;
                object.name = "";
                object.type = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.gpioPin != null && message.hasOwnProperty("gpioPin"))
                object.gpioPin = message.gpioPin;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.meshtastic.RemoteHardwarePinType[message.type] === undefined ? message.type : $root.meshtastic.RemoteHardwarePinType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this RemoteHardwarePin to JSON.
         * @function toJSON
         * @memberof meshtastic.RemoteHardwarePin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoteHardwarePin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RemoteHardwarePin
         * @function getTypeUrl
         * @memberof meshtastic.RemoteHardwarePin
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RemoteHardwarePin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.RemoteHardwarePin";
        };

        return RemoteHardwarePin;
    })();

    /**
     * RemoteHardwarePinType enum.
     * @name meshtastic.RemoteHardwarePinType
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} DIGITAL_READ=1 DIGITAL_READ value
     * @property {number} DIGITAL_WRITE=2 DIGITAL_WRITE value
     */
    meshtastic.RemoteHardwarePinType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "DIGITAL_READ"] = 1;
        values[valuesById[2] = "DIGITAL_WRITE"] = 2;
        return values;
    })();

    /**
     * PortNum enum.
     * @name meshtastic.PortNum
     * @enum {number}
     * @property {number} UNKNOWN_APP=0 UNKNOWN_APP value
     * @property {number} TEXT_MESSAGE_APP=1 TEXT_MESSAGE_APP value
     * @property {number} REMOTE_HARDWARE_APP=2 REMOTE_HARDWARE_APP value
     * @property {number} POSITION_APP=3 POSITION_APP value
     * @property {number} NODEINFO_APP=4 NODEINFO_APP value
     * @property {number} ROUTING_APP=5 ROUTING_APP value
     * @property {number} ADMIN_APP=6 ADMIN_APP value
     * @property {number} TEXT_MESSAGE_COMPRESSED_APP=7 TEXT_MESSAGE_COMPRESSED_APP value
     * @property {number} WAYPOINT_APP=8 WAYPOINT_APP value
     * @property {number} AUDIO_APP=9 AUDIO_APP value
     * @property {number} DETECTION_SENSOR_APP=10 DETECTION_SENSOR_APP value
     * @property {number} ALERT_APP=11 ALERT_APP value
     * @property {number} KEY_VERIFICATION_APP=12 KEY_VERIFICATION_APP value
     * @property {number} REPLY_APP=32 REPLY_APP value
     * @property {number} IP_TUNNEL_APP=33 IP_TUNNEL_APP value
     * @property {number} PAXCOUNTER_APP=34 PAXCOUNTER_APP value
     * @property {number} SERIAL_APP=64 SERIAL_APP value
     * @property {number} STORE_FORWARD_APP=65 STORE_FORWARD_APP value
     * @property {number} RANGE_TEST_APP=66 RANGE_TEST_APP value
     * @property {number} TELEMETRY_APP=67 TELEMETRY_APP value
     * @property {number} ZPS_APP=68 ZPS_APP value
     * @property {number} SIMULATOR_APP=69 SIMULATOR_APP value
     * @property {number} TRACEROUTE_APP=70 TRACEROUTE_APP value
     * @property {number} NEIGHBORINFO_APP=71 NEIGHBORINFO_APP value
     * @property {number} ATAK_PLUGIN=72 ATAK_PLUGIN value
     * @property {number} MAP_REPORT_APP=73 MAP_REPORT_APP value
     * @property {number} POWERSTRESS_APP=74 POWERSTRESS_APP value
     * @property {number} RETICULUM_TUNNEL_APP=76 RETICULUM_TUNNEL_APP value
     * @property {number} CAYENNE_APP=77 CAYENNE_APP value
     * @property {number} PRIVATE_APP=256 PRIVATE_APP value
     * @property {number} ATAK_FORWARDER=257 ATAK_FORWARDER value
     * @property {number} MAX=511 MAX value
     */
    meshtastic.PortNum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_APP"] = 0;
        values[valuesById[1] = "TEXT_MESSAGE_APP"] = 1;
        values[valuesById[2] = "REMOTE_HARDWARE_APP"] = 2;
        values[valuesById[3] = "POSITION_APP"] = 3;
        values[valuesById[4] = "NODEINFO_APP"] = 4;
        values[valuesById[5] = "ROUTING_APP"] = 5;
        values[valuesById[6] = "ADMIN_APP"] = 6;
        values[valuesById[7] = "TEXT_MESSAGE_COMPRESSED_APP"] = 7;
        values[valuesById[8] = "WAYPOINT_APP"] = 8;
        values[valuesById[9] = "AUDIO_APP"] = 9;
        values[valuesById[10] = "DETECTION_SENSOR_APP"] = 10;
        values[valuesById[11] = "ALERT_APP"] = 11;
        values[valuesById[12] = "KEY_VERIFICATION_APP"] = 12;
        values[valuesById[32] = "REPLY_APP"] = 32;
        values[valuesById[33] = "IP_TUNNEL_APP"] = 33;
        values[valuesById[34] = "PAXCOUNTER_APP"] = 34;
        values[valuesById[64] = "SERIAL_APP"] = 64;
        values[valuesById[65] = "STORE_FORWARD_APP"] = 65;
        values[valuesById[66] = "RANGE_TEST_APP"] = 66;
        values[valuesById[67] = "TELEMETRY_APP"] = 67;
        values[valuesById[68] = "ZPS_APP"] = 68;
        values[valuesById[69] = "SIMULATOR_APP"] = 69;
        values[valuesById[70] = "TRACEROUTE_APP"] = 70;
        values[valuesById[71] = "NEIGHBORINFO_APP"] = 71;
        values[valuesById[72] = "ATAK_PLUGIN"] = 72;
        values[valuesById[73] = "MAP_REPORT_APP"] = 73;
        values[valuesById[74] = "POWERSTRESS_APP"] = 74;
        values[valuesById[76] = "RETICULUM_TUNNEL_APP"] = 76;
        values[valuesById[77] = "CAYENNE_APP"] = 77;
        values[valuesById[256] = "PRIVATE_APP"] = 256;
        values[valuesById[257] = "ATAK_FORWARDER"] = 257;
        values[valuesById[511] = "MAX"] = 511;
        return values;
    })();

    meshtastic.DeviceMetrics = (function() {

        /**
         * Properties of a DeviceMetrics.
         * @memberof meshtastic
         * @interface IDeviceMetrics
         * @property {number|null} [batteryLevel] DeviceMetrics batteryLevel
         * @property {number|null} [voltage] DeviceMetrics voltage
         * @property {number|null} [channelUtilization] DeviceMetrics channelUtilization
         * @property {number|null} [airUtilTx] DeviceMetrics airUtilTx
         * @property {number|null} [uptimeSeconds] DeviceMetrics uptimeSeconds
         */

        /**
         * Constructs a new DeviceMetrics.
         * @memberof meshtastic
         * @classdesc Represents a DeviceMetrics.
         * @implements IDeviceMetrics
         * @constructor
         * @param {meshtastic.IDeviceMetrics=} [properties] Properties to set
         */
        function DeviceMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceMetrics batteryLevel.
         * @member {number|null|undefined} batteryLevel
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        DeviceMetrics.prototype.batteryLevel = null;

        /**
         * DeviceMetrics voltage.
         * @member {number|null|undefined} voltage
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        DeviceMetrics.prototype.voltage = null;

        /**
         * DeviceMetrics channelUtilization.
         * @member {number|null|undefined} channelUtilization
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        DeviceMetrics.prototype.channelUtilization = null;

        /**
         * DeviceMetrics airUtilTx.
         * @member {number|null|undefined} airUtilTx
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        DeviceMetrics.prototype.airUtilTx = null;

        /**
         * DeviceMetrics uptimeSeconds.
         * @member {number|null|undefined} uptimeSeconds
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        DeviceMetrics.prototype.uptimeSeconds = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * DeviceMetrics _batteryLevel.
         * @member {"batteryLevel"|undefined} _batteryLevel
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        Object.defineProperty(DeviceMetrics.prototype, "_batteryLevel", {
            get: $util.oneOfGetter($oneOfFields = ["batteryLevel"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * DeviceMetrics _voltage.
         * @member {"voltage"|undefined} _voltage
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        Object.defineProperty(DeviceMetrics.prototype, "_voltage", {
            get: $util.oneOfGetter($oneOfFields = ["voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * DeviceMetrics _channelUtilization.
         * @member {"channelUtilization"|undefined} _channelUtilization
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        Object.defineProperty(DeviceMetrics.prototype, "_channelUtilization", {
            get: $util.oneOfGetter($oneOfFields = ["channelUtilization"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * DeviceMetrics _airUtilTx.
         * @member {"airUtilTx"|undefined} _airUtilTx
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        Object.defineProperty(DeviceMetrics.prototype, "_airUtilTx", {
            get: $util.oneOfGetter($oneOfFields = ["airUtilTx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * DeviceMetrics _uptimeSeconds.
         * @member {"uptimeSeconds"|undefined} _uptimeSeconds
         * @memberof meshtastic.DeviceMetrics
         * @instance
         */
        Object.defineProperty(DeviceMetrics.prototype, "_uptimeSeconds", {
            get: $util.oneOfGetter($oneOfFields = ["uptimeSeconds"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new DeviceMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {meshtastic.IDeviceMetrics=} [properties] Properties to set
         * @returns {meshtastic.DeviceMetrics} DeviceMetrics instance
         */
        DeviceMetrics.create = function create(properties) {
            return new DeviceMetrics(properties);
        };

        /**
         * Encodes the specified DeviceMetrics message. Does not implicitly {@link meshtastic.DeviceMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {meshtastic.IDeviceMetrics} message DeviceMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.batteryLevel != null && Object.hasOwnProperty.call(message, "batteryLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.batteryLevel);
            if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.voltage);
            if (message.channelUtilization != null && Object.hasOwnProperty.call(message, "channelUtilization"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.channelUtilization);
            if (message.airUtilTx != null && Object.hasOwnProperty.call(message, "airUtilTx"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.airUtilTx);
            if (message.uptimeSeconds != null && Object.hasOwnProperty.call(message, "uptimeSeconds"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uptimeSeconds);
            return writer;
        };

        /**
         * Encodes the specified DeviceMetrics message, length delimited. Does not implicitly {@link meshtastic.DeviceMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {meshtastic.IDeviceMetrics} message DeviceMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.DeviceMetrics} DeviceMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.DeviceMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.batteryLevel = reader.uint32();
                        break;
                    }
                case 2: {
                        message.voltage = reader.float();
                        break;
                    }
                case 3: {
                        message.channelUtilization = reader.float();
                        break;
                    }
                case 4: {
                        message.airUtilTx = reader.float();
                        break;
                    }
                case 5: {
                        message.uptimeSeconds = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.DeviceMetrics} DeviceMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceMetrics message.
         * @function verify
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel")) {
                properties._batteryLevel = 1;
                if (!$util.isInteger(message.batteryLevel))
                    return "batteryLevel: integer expected";
            }
            if (message.voltage != null && message.hasOwnProperty("voltage")) {
                properties._voltage = 1;
                if (typeof message.voltage !== "number")
                    return "voltage: number expected";
            }
            if (message.channelUtilization != null && message.hasOwnProperty("channelUtilization")) {
                properties._channelUtilization = 1;
                if (typeof message.channelUtilization !== "number")
                    return "channelUtilization: number expected";
            }
            if (message.airUtilTx != null && message.hasOwnProperty("airUtilTx")) {
                properties._airUtilTx = 1;
                if (typeof message.airUtilTx !== "number")
                    return "airUtilTx: number expected";
            }
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds")) {
                properties._uptimeSeconds = 1;
                if (!$util.isInteger(message.uptimeSeconds))
                    return "uptimeSeconds: integer expected";
            }
            return null;
        };

        /**
         * Creates a DeviceMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.DeviceMetrics} DeviceMetrics
         */
        DeviceMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.DeviceMetrics)
                return object;
            var message = new $root.meshtastic.DeviceMetrics();
            if (object.batteryLevel != null)
                message.batteryLevel = object.batteryLevel >>> 0;
            if (object.voltage != null)
                message.voltage = Number(object.voltage);
            if (object.channelUtilization != null)
                message.channelUtilization = Number(object.channelUtilization);
            if (object.airUtilTx != null)
                message.airUtilTx = Number(object.airUtilTx);
            if (object.uptimeSeconds != null)
                message.uptimeSeconds = object.uptimeSeconds >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DeviceMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {meshtastic.DeviceMetrics} message DeviceMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel")) {
                object.batteryLevel = message.batteryLevel;
                if (options.oneofs)
                    object._batteryLevel = "batteryLevel";
            }
            if (message.voltage != null && message.hasOwnProperty("voltage")) {
                object.voltage = options.json && !isFinite(message.voltage) ? String(message.voltage) : message.voltage;
                if (options.oneofs)
                    object._voltage = "voltage";
            }
            if (message.channelUtilization != null && message.hasOwnProperty("channelUtilization")) {
                object.channelUtilization = options.json && !isFinite(message.channelUtilization) ? String(message.channelUtilization) : message.channelUtilization;
                if (options.oneofs)
                    object._channelUtilization = "channelUtilization";
            }
            if (message.airUtilTx != null && message.hasOwnProperty("airUtilTx")) {
                object.airUtilTx = options.json && !isFinite(message.airUtilTx) ? String(message.airUtilTx) : message.airUtilTx;
                if (options.oneofs)
                    object._airUtilTx = "airUtilTx";
            }
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds")) {
                object.uptimeSeconds = message.uptimeSeconds;
                if (options.oneofs)
                    object._uptimeSeconds = "uptimeSeconds";
            }
            return object;
        };

        /**
         * Converts this DeviceMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.DeviceMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeviceMetrics
         * @function getTypeUrl
         * @memberof meshtastic.DeviceMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeviceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.DeviceMetrics";
        };

        return DeviceMetrics;
    })();

    meshtastic.EnvironmentMetrics = (function() {

        /**
         * Properties of an EnvironmentMetrics.
         * @memberof meshtastic
         * @interface IEnvironmentMetrics
         * @property {number|null} [temperature] EnvironmentMetrics temperature
         * @property {number|null} [relativeHumidity] EnvironmentMetrics relativeHumidity
         * @property {number|null} [barometricPressure] EnvironmentMetrics barometricPressure
         * @property {number|null} [gasResistance] EnvironmentMetrics gasResistance
         * @property {number|null} [voltage] EnvironmentMetrics voltage
         * @property {number|null} [current] EnvironmentMetrics current
         * @property {number|null} [iaq] EnvironmentMetrics iaq
         * @property {number|null} [distance] EnvironmentMetrics distance
         * @property {number|null} [lux] EnvironmentMetrics lux
         * @property {number|null} [whiteLux] EnvironmentMetrics whiteLux
         * @property {number|null} [irLux] EnvironmentMetrics irLux
         * @property {number|null} [uvLux] EnvironmentMetrics uvLux
         * @property {number|null} [windDirection] EnvironmentMetrics windDirection
         * @property {number|null} [windSpeed] EnvironmentMetrics windSpeed
         * @property {number|null} [weight] EnvironmentMetrics weight
         * @property {number|null} [windGust] EnvironmentMetrics windGust
         * @property {number|null} [windLull] EnvironmentMetrics windLull
         * @property {number|null} [radiation] EnvironmentMetrics radiation
         * @property {number|null} [rainfall_1h] EnvironmentMetrics rainfall_1h
         * @property {number|null} [rainfall_24h] EnvironmentMetrics rainfall_24h
         * @property {number|null} [soilMoisture] EnvironmentMetrics soilMoisture
         * @property {number|null} [soilTemperature] EnvironmentMetrics soilTemperature
         */

        /**
         * Constructs a new EnvironmentMetrics.
         * @memberof meshtastic
         * @classdesc Represents an EnvironmentMetrics.
         * @implements IEnvironmentMetrics
         * @constructor
         * @param {meshtastic.IEnvironmentMetrics=} [properties] Properties to set
         */
        function EnvironmentMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnvironmentMetrics temperature.
         * @member {number|null|undefined} temperature
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.temperature = null;

        /**
         * EnvironmentMetrics relativeHumidity.
         * @member {number|null|undefined} relativeHumidity
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.relativeHumidity = null;

        /**
         * EnvironmentMetrics barometricPressure.
         * @member {number|null|undefined} barometricPressure
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.barometricPressure = null;

        /**
         * EnvironmentMetrics gasResistance.
         * @member {number|null|undefined} gasResistance
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.gasResistance = null;

        /**
         * EnvironmentMetrics voltage.
         * @member {number|null|undefined} voltage
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.voltage = null;

        /**
         * EnvironmentMetrics current.
         * @member {number|null|undefined} current
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.current = null;

        /**
         * EnvironmentMetrics iaq.
         * @member {number|null|undefined} iaq
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.iaq = null;

        /**
         * EnvironmentMetrics distance.
         * @member {number|null|undefined} distance
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.distance = null;

        /**
         * EnvironmentMetrics lux.
         * @member {number|null|undefined} lux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.lux = null;

        /**
         * EnvironmentMetrics whiteLux.
         * @member {number|null|undefined} whiteLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.whiteLux = null;

        /**
         * EnvironmentMetrics irLux.
         * @member {number|null|undefined} irLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.irLux = null;

        /**
         * EnvironmentMetrics uvLux.
         * @member {number|null|undefined} uvLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.uvLux = null;

        /**
         * EnvironmentMetrics windDirection.
         * @member {number|null|undefined} windDirection
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.windDirection = null;

        /**
         * EnvironmentMetrics windSpeed.
         * @member {number|null|undefined} windSpeed
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.windSpeed = null;

        /**
         * EnvironmentMetrics weight.
         * @member {number|null|undefined} weight
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.weight = null;

        /**
         * EnvironmentMetrics windGust.
         * @member {number|null|undefined} windGust
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.windGust = null;

        /**
         * EnvironmentMetrics windLull.
         * @member {number|null|undefined} windLull
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.windLull = null;

        /**
         * EnvironmentMetrics radiation.
         * @member {number|null|undefined} radiation
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.radiation = null;

        /**
         * EnvironmentMetrics rainfall_1h.
         * @member {number|null|undefined} rainfall_1h
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.rainfall_1h = null;

        /**
         * EnvironmentMetrics rainfall_24h.
         * @member {number|null|undefined} rainfall_24h
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.rainfall_24h = null;

        /**
         * EnvironmentMetrics soilMoisture.
         * @member {number|null|undefined} soilMoisture
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.soilMoisture = null;

        /**
         * EnvironmentMetrics soilTemperature.
         * @member {number|null|undefined} soilTemperature
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        EnvironmentMetrics.prototype.soilTemperature = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * EnvironmentMetrics _temperature.
         * @member {"temperature"|undefined} _temperature
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_temperature", {
            get: $util.oneOfGetter($oneOfFields = ["temperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _relativeHumidity.
         * @member {"relativeHumidity"|undefined} _relativeHumidity
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_relativeHumidity", {
            get: $util.oneOfGetter($oneOfFields = ["relativeHumidity"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _barometricPressure.
         * @member {"barometricPressure"|undefined} _barometricPressure
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_barometricPressure", {
            get: $util.oneOfGetter($oneOfFields = ["barometricPressure"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _gasResistance.
         * @member {"gasResistance"|undefined} _gasResistance
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_gasResistance", {
            get: $util.oneOfGetter($oneOfFields = ["gasResistance"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _voltage.
         * @member {"voltage"|undefined} _voltage
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_voltage", {
            get: $util.oneOfGetter($oneOfFields = ["voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _current.
         * @member {"current"|undefined} _current
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_current", {
            get: $util.oneOfGetter($oneOfFields = ["current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _iaq.
         * @member {"iaq"|undefined} _iaq
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_iaq", {
            get: $util.oneOfGetter($oneOfFields = ["iaq"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _distance.
         * @member {"distance"|undefined} _distance
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_distance", {
            get: $util.oneOfGetter($oneOfFields = ["distance"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _lux.
         * @member {"lux"|undefined} _lux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_lux", {
            get: $util.oneOfGetter($oneOfFields = ["lux"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _whiteLux.
         * @member {"whiteLux"|undefined} _whiteLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_whiteLux", {
            get: $util.oneOfGetter($oneOfFields = ["whiteLux"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _irLux.
         * @member {"irLux"|undefined} _irLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_irLux", {
            get: $util.oneOfGetter($oneOfFields = ["irLux"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _uvLux.
         * @member {"uvLux"|undefined} _uvLux
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_uvLux", {
            get: $util.oneOfGetter($oneOfFields = ["uvLux"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _windDirection.
         * @member {"windDirection"|undefined} _windDirection
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_windDirection", {
            get: $util.oneOfGetter($oneOfFields = ["windDirection"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _windSpeed.
         * @member {"windSpeed"|undefined} _windSpeed
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_windSpeed", {
            get: $util.oneOfGetter($oneOfFields = ["windSpeed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _weight.
         * @member {"weight"|undefined} _weight
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_weight", {
            get: $util.oneOfGetter($oneOfFields = ["weight"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _windGust.
         * @member {"windGust"|undefined} _windGust
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_windGust", {
            get: $util.oneOfGetter($oneOfFields = ["windGust"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _windLull.
         * @member {"windLull"|undefined} _windLull
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_windLull", {
            get: $util.oneOfGetter($oneOfFields = ["windLull"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _radiation.
         * @member {"radiation"|undefined} _radiation
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_radiation", {
            get: $util.oneOfGetter($oneOfFields = ["radiation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _rainfall_1h.
         * @member {"rainfall_1h"|undefined} _rainfall_1h
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_rainfall_1h", {
            get: $util.oneOfGetter($oneOfFields = ["rainfall_1h"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _rainfall_24h.
         * @member {"rainfall_24h"|undefined} _rainfall_24h
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_rainfall_24h", {
            get: $util.oneOfGetter($oneOfFields = ["rainfall_24h"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _soilMoisture.
         * @member {"soilMoisture"|undefined} _soilMoisture
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_soilMoisture", {
            get: $util.oneOfGetter($oneOfFields = ["soilMoisture"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * EnvironmentMetrics _soilTemperature.
         * @member {"soilTemperature"|undefined} _soilTemperature
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         */
        Object.defineProperty(EnvironmentMetrics.prototype, "_soilTemperature", {
            get: $util.oneOfGetter($oneOfFields = ["soilTemperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EnvironmentMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {meshtastic.IEnvironmentMetrics=} [properties] Properties to set
         * @returns {meshtastic.EnvironmentMetrics} EnvironmentMetrics instance
         */
        EnvironmentMetrics.create = function create(properties) {
            return new EnvironmentMetrics(properties);
        };

        /**
         * Encodes the specified EnvironmentMetrics message. Does not implicitly {@link meshtastic.EnvironmentMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {meshtastic.IEnvironmentMetrics} message EnvironmentMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvironmentMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.temperature);
            if (message.relativeHumidity != null && Object.hasOwnProperty.call(message, "relativeHumidity"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.relativeHumidity);
            if (message.barometricPressure != null && Object.hasOwnProperty.call(message, "barometricPressure"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.barometricPressure);
            if (message.gasResistance != null && Object.hasOwnProperty.call(message, "gasResistance"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.gasResistance);
            if (message.voltage != null && Object.hasOwnProperty.call(message, "voltage"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.voltage);
            if (message.current != null && Object.hasOwnProperty.call(message, "current"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.current);
            if (message.iaq != null && Object.hasOwnProperty.call(message, "iaq"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.iaq);
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.distance);
            if (message.lux != null && Object.hasOwnProperty.call(message, "lux"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.lux);
            if (message.whiteLux != null && Object.hasOwnProperty.call(message, "whiteLux"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.whiteLux);
            if (message.irLux != null && Object.hasOwnProperty.call(message, "irLux"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.irLux);
            if (message.uvLux != null && Object.hasOwnProperty.call(message, "uvLux"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.uvLux);
            if (message.windDirection != null && Object.hasOwnProperty.call(message, "windDirection"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.windDirection);
            if (message.windSpeed != null && Object.hasOwnProperty.call(message, "windSpeed"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.windSpeed);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.weight);
            if (message.windGust != null && Object.hasOwnProperty.call(message, "windGust"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.windGust);
            if (message.windLull != null && Object.hasOwnProperty.call(message, "windLull"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.windLull);
            if (message.radiation != null && Object.hasOwnProperty.call(message, "radiation"))
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.radiation);
            if (message.rainfall_1h != null && Object.hasOwnProperty.call(message, "rainfall_1h"))
                writer.uint32(/* id 19, wireType 5 =*/157).float(message.rainfall_1h);
            if (message.rainfall_24h != null && Object.hasOwnProperty.call(message, "rainfall_24h"))
                writer.uint32(/* id 20, wireType 5 =*/165).float(message.rainfall_24h);
            if (message.soilMoisture != null && Object.hasOwnProperty.call(message, "soilMoisture"))
                writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.soilMoisture);
            if (message.soilTemperature != null && Object.hasOwnProperty.call(message, "soilTemperature"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.soilTemperature);
            return writer;
        };

        /**
         * Encodes the specified EnvironmentMetrics message, length delimited. Does not implicitly {@link meshtastic.EnvironmentMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {meshtastic.IEnvironmentMetrics} message EnvironmentMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvironmentMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnvironmentMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.EnvironmentMetrics} EnvironmentMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvironmentMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.EnvironmentMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.temperature = reader.float();
                        break;
                    }
                case 2: {
                        message.relativeHumidity = reader.float();
                        break;
                    }
                case 3: {
                        message.barometricPressure = reader.float();
                        break;
                    }
                case 4: {
                        message.gasResistance = reader.float();
                        break;
                    }
                case 5: {
                        message.voltage = reader.float();
                        break;
                    }
                case 6: {
                        message.current = reader.float();
                        break;
                    }
                case 7: {
                        message.iaq = reader.uint32();
                        break;
                    }
                case 8: {
                        message.distance = reader.float();
                        break;
                    }
                case 9: {
                        message.lux = reader.float();
                        break;
                    }
                case 10: {
                        message.whiteLux = reader.float();
                        break;
                    }
                case 11: {
                        message.irLux = reader.float();
                        break;
                    }
                case 12: {
                        message.uvLux = reader.float();
                        break;
                    }
                case 13: {
                        message.windDirection = reader.uint32();
                        break;
                    }
                case 14: {
                        message.windSpeed = reader.float();
                        break;
                    }
                case 15: {
                        message.weight = reader.float();
                        break;
                    }
                case 16: {
                        message.windGust = reader.float();
                        break;
                    }
                case 17: {
                        message.windLull = reader.float();
                        break;
                    }
                case 18: {
                        message.radiation = reader.float();
                        break;
                    }
                case 19: {
                        message.rainfall_1h = reader.float();
                        break;
                    }
                case 20: {
                        message.rainfall_24h = reader.float();
                        break;
                    }
                case 21: {
                        message.soilMoisture = reader.uint32();
                        break;
                    }
                case 22: {
                        message.soilTemperature = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnvironmentMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.EnvironmentMetrics} EnvironmentMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvironmentMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnvironmentMetrics message.
         * @function verify
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnvironmentMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                properties._temperature = 1;
                if (typeof message.temperature !== "number")
                    return "temperature: number expected";
            }
            if (message.relativeHumidity != null && message.hasOwnProperty("relativeHumidity")) {
                properties._relativeHumidity = 1;
                if (typeof message.relativeHumidity !== "number")
                    return "relativeHumidity: number expected";
            }
            if (message.barometricPressure != null && message.hasOwnProperty("barometricPressure")) {
                properties._barometricPressure = 1;
                if (typeof message.barometricPressure !== "number")
                    return "barometricPressure: number expected";
            }
            if (message.gasResistance != null && message.hasOwnProperty("gasResistance")) {
                properties._gasResistance = 1;
                if (typeof message.gasResistance !== "number")
                    return "gasResistance: number expected";
            }
            if (message.voltage != null && message.hasOwnProperty("voltage")) {
                properties._voltage = 1;
                if (typeof message.voltage !== "number")
                    return "voltage: number expected";
            }
            if (message.current != null && message.hasOwnProperty("current")) {
                properties._current = 1;
                if (typeof message.current !== "number")
                    return "current: number expected";
            }
            if (message.iaq != null && message.hasOwnProperty("iaq")) {
                properties._iaq = 1;
                if (!$util.isInteger(message.iaq))
                    return "iaq: integer expected";
            }
            if (message.distance != null && message.hasOwnProperty("distance")) {
                properties._distance = 1;
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            }
            if (message.lux != null && message.hasOwnProperty("lux")) {
                properties._lux = 1;
                if (typeof message.lux !== "number")
                    return "lux: number expected";
            }
            if (message.whiteLux != null && message.hasOwnProperty("whiteLux")) {
                properties._whiteLux = 1;
                if (typeof message.whiteLux !== "number")
                    return "whiteLux: number expected";
            }
            if (message.irLux != null && message.hasOwnProperty("irLux")) {
                properties._irLux = 1;
                if (typeof message.irLux !== "number")
                    return "irLux: number expected";
            }
            if (message.uvLux != null && message.hasOwnProperty("uvLux")) {
                properties._uvLux = 1;
                if (typeof message.uvLux !== "number")
                    return "uvLux: number expected";
            }
            if (message.windDirection != null && message.hasOwnProperty("windDirection")) {
                properties._windDirection = 1;
                if (!$util.isInteger(message.windDirection))
                    return "windDirection: integer expected";
            }
            if (message.windSpeed != null && message.hasOwnProperty("windSpeed")) {
                properties._windSpeed = 1;
                if (typeof message.windSpeed !== "number")
                    return "windSpeed: number expected";
            }
            if (message.weight != null && message.hasOwnProperty("weight")) {
                properties._weight = 1;
                if (typeof message.weight !== "number")
                    return "weight: number expected";
            }
            if (message.windGust != null && message.hasOwnProperty("windGust")) {
                properties._windGust = 1;
                if (typeof message.windGust !== "number")
                    return "windGust: number expected";
            }
            if (message.windLull != null && message.hasOwnProperty("windLull")) {
                properties._windLull = 1;
                if (typeof message.windLull !== "number")
                    return "windLull: number expected";
            }
            if (message.radiation != null && message.hasOwnProperty("radiation")) {
                properties._radiation = 1;
                if (typeof message.radiation !== "number")
                    return "radiation: number expected";
            }
            if (message.rainfall_1h != null && message.hasOwnProperty("rainfall_1h")) {
                properties._rainfall_1h = 1;
                if (typeof message.rainfall_1h !== "number")
                    return "rainfall_1h: number expected";
            }
            if (message.rainfall_24h != null && message.hasOwnProperty("rainfall_24h")) {
                properties._rainfall_24h = 1;
                if (typeof message.rainfall_24h !== "number")
                    return "rainfall_24h: number expected";
            }
            if (message.soilMoisture != null && message.hasOwnProperty("soilMoisture")) {
                properties._soilMoisture = 1;
                if (!$util.isInteger(message.soilMoisture))
                    return "soilMoisture: integer expected";
            }
            if (message.soilTemperature != null && message.hasOwnProperty("soilTemperature")) {
                properties._soilTemperature = 1;
                if (typeof message.soilTemperature !== "number")
                    return "soilTemperature: number expected";
            }
            return null;
        };

        /**
         * Creates an EnvironmentMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.EnvironmentMetrics} EnvironmentMetrics
         */
        EnvironmentMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.EnvironmentMetrics)
                return object;
            var message = new $root.meshtastic.EnvironmentMetrics();
            if (object.temperature != null)
                message.temperature = Number(object.temperature);
            if (object.relativeHumidity != null)
                message.relativeHumidity = Number(object.relativeHumidity);
            if (object.barometricPressure != null)
                message.barometricPressure = Number(object.barometricPressure);
            if (object.gasResistance != null)
                message.gasResistance = Number(object.gasResistance);
            if (object.voltage != null)
                message.voltage = Number(object.voltage);
            if (object.current != null)
                message.current = Number(object.current);
            if (object.iaq != null)
                message.iaq = object.iaq >>> 0;
            if (object.distance != null)
                message.distance = Number(object.distance);
            if (object.lux != null)
                message.lux = Number(object.lux);
            if (object.whiteLux != null)
                message.whiteLux = Number(object.whiteLux);
            if (object.irLux != null)
                message.irLux = Number(object.irLux);
            if (object.uvLux != null)
                message.uvLux = Number(object.uvLux);
            if (object.windDirection != null)
                message.windDirection = object.windDirection >>> 0;
            if (object.windSpeed != null)
                message.windSpeed = Number(object.windSpeed);
            if (object.weight != null)
                message.weight = Number(object.weight);
            if (object.windGust != null)
                message.windGust = Number(object.windGust);
            if (object.windLull != null)
                message.windLull = Number(object.windLull);
            if (object.radiation != null)
                message.radiation = Number(object.radiation);
            if (object.rainfall_1h != null)
                message.rainfall_1h = Number(object.rainfall_1h);
            if (object.rainfall_24h != null)
                message.rainfall_24h = Number(object.rainfall_24h);
            if (object.soilMoisture != null)
                message.soilMoisture = object.soilMoisture >>> 0;
            if (object.soilTemperature != null)
                message.soilTemperature = Number(object.soilTemperature);
            return message;
        };

        /**
         * Creates a plain object from an EnvironmentMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {meshtastic.EnvironmentMetrics} message EnvironmentMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnvironmentMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                if (options.oneofs)
                    object._temperature = "temperature";
            }
            if (message.relativeHumidity != null && message.hasOwnProperty("relativeHumidity")) {
                object.relativeHumidity = options.json && !isFinite(message.relativeHumidity) ? String(message.relativeHumidity) : message.relativeHumidity;
                if (options.oneofs)
                    object._relativeHumidity = "relativeHumidity";
            }
            if (message.barometricPressure != null && message.hasOwnProperty("barometricPressure")) {
                object.barometricPressure = options.json && !isFinite(message.barometricPressure) ? String(message.barometricPressure) : message.barometricPressure;
                if (options.oneofs)
                    object._barometricPressure = "barometricPressure";
            }
            if (message.gasResistance != null && message.hasOwnProperty("gasResistance")) {
                object.gasResistance = options.json && !isFinite(message.gasResistance) ? String(message.gasResistance) : message.gasResistance;
                if (options.oneofs)
                    object._gasResistance = "gasResistance";
            }
            if (message.voltage != null && message.hasOwnProperty("voltage")) {
                object.voltage = options.json && !isFinite(message.voltage) ? String(message.voltage) : message.voltage;
                if (options.oneofs)
                    object._voltage = "voltage";
            }
            if (message.current != null && message.hasOwnProperty("current")) {
                object.current = options.json && !isFinite(message.current) ? String(message.current) : message.current;
                if (options.oneofs)
                    object._current = "current";
            }
            if (message.iaq != null && message.hasOwnProperty("iaq")) {
                object.iaq = message.iaq;
                if (options.oneofs)
                    object._iaq = "iaq";
            }
            if (message.distance != null && message.hasOwnProperty("distance")) {
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                if (options.oneofs)
                    object._distance = "distance";
            }
            if (message.lux != null && message.hasOwnProperty("lux")) {
                object.lux = options.json && !isFinite(message.lux) ? String(message.lux) : message.lux;
                if (options.oneofs)
                    object._lux = "lux";
            }
            if (message.whiteLux != null && message.hasOwnProperty("whiteLux")) {
                object.whiteLux = options.json && !isFinite(message.whiteLux) ? String(message.whiteLux) : message.whiteLux;
                if (options.oneofs)
                    object._whiteLux = "whiteLux";
            }
            if (message.irLux != null && message.hasOwnProperty("irLux")) {
                object.irLux = options.json && !isFinite(message.irLux) ? String(message.irLux) : message.irLux;
                if (options.oneofs)
                    object._irLux = "irLux";
            }
            if (message.uvLux != null && message.hasOwnProperty("uvLux")) {
                object.uvLux = options.json && !isFinite(message.uvLux) ? String(message.uvLux) : message.uvLux;
                if (options.oneofs)
                    object._uvLux = "uvLux";
            }
            if (message.windDirection != null && message.hasOwnProperty("windDirection")) {
                object.windDirection = message.windDirection;
                if (options.oneofs)
                    object._windDirection = "windDirection";
            }
            if (message.windSpeed != null && message.hasOwnProperty("windSpeed")) {
                object.windSpeed = options.json && !isFinite(message.windSpeed) ? String(message.windSpeed) : message.windSpeed;
                if (options.oneofs)
                    object._windSpeed = "windSpeed";
            }
            if (message.weight != null && message.hasOwnProperty("weight")) {
                object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                if (options.oneofs)
                    object._weight = "weight";
            }
            if (message.windGust != null && message.hasOwnProperty("windGust")) {
                object.windGust = options.json && !isFinite(message.windGust) ? String(message.windGust) : message.windGust;
                if (options.oneofs)
                    object._windGust = "windGust";
            }
            if (message.windLull != null && message.hasOwnProperty("windLull")) {
                object.windLull = options.json && !isFinite(message.windLull) ? String(message.windLull) : message.windLull;
                if (options.oneofs)
                    object._windLull = "windLull";
            }
            if (message.radiation != null && message.hasOwnProperty("radiation")) {
                object.radiation = options.json && !isFinite(message.radiation) ? String(message.radiation) : message.radiation;
                if (options.oneofs)
                    object._radiation = "radiation";
            }
            if (message.rainfall_1h != null && message.hasOwnProperty("rainfall_1h")) {
                object.rainfall_1h = options.json && !isFinite(message.rainfall_1h) ? String(message.rainfall_1h) : message.rainfall_1h;
                if (options.oneofs)
                    object._rainfall_1h = "rainfall_1h";
            }
            if (message.rainfall_24h != null && message.hasOwnProperty("rainfall_24h")) {
                object.rainfall_24h = options.json && !isFinite(message.rainfall_24h) ? String(message.rainfall_24h) : message.rainfall_24h;
                if (options.oneofs)
                    object._rainfall_24h = "rainfall_24h";
            }
            if (message.soilMoisture != null && message.hasOwnProperty("soilMoisture")) {
                object.soilMoisture = message.soilMoisture;
                if (options.oneofs)
                    object._soilMoisture = "soilMoisture";
            }
            if (message.soilTemperature != null && message.hasOwnProperty("soilTemperature")) {
                object.soilTemperature = options.json && !isFinite(message.soilTemperature) ? String(message.soilTemperature) : message.soilTemperature;
                if (options.oneofs)
                    object._soilTemperature = "soilTemperature";
            }
            return object;
        };

        /**
         * Converts this EnvironmentMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.EnvironmentMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnvironmentMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EnvironmentMetrics
         * @function getTypeUrl
         * @memberof meshtastic.EnvironmentMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EnvironmentMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.EnvironmentMetrics";
        };

        return EnvironmentMetrics;
    })();

    meshtastic.PowerMetrics = (function() {

        /**
         * Properties of a PowerMetrics.
         * @memberof meshtastic
         * @interface IPowerMetrics
         * @property {number|null} [ch1Voltage] PowerMetrics ch1Voltage
         * @property {number|null} [ch1Current] PowerMetrics ch1Current
         * @property {number|null} [ch2Voltage] PowerMetrics ch2Voltage
         * @property {number|null} [ch2Current] PowerMetrics ch2Current
         * @property {number|null} [ch3Voltage] PowerMetrics ch3Voltage
         * @property {number|null} [ch3Current] PowerMetrics ch3Current
         * @property {number|null} [ch4Voltage] PowerMetrics ch4Voltage
         * @property {number|null} [ch4Current] PowerMetrics ch4Current
         * @property {number|null} [ch5Voltage] PowerMetrics ch5Voltage
         * @property {number|null} [ch5Current] PowerMetrics ch5Current
         * @property {number|null} [ch6Voltage] PowerMetrics ch6Voltage
         * @property {number|null} [ch6Current] PowerMetrics ch6Current
         * @property {number|null} [ch7Voltage] PowerMetrics ch7Voltage
         * @property {number|null} [ch7Current] PowerMetrics ch7Current
         * @property {number|null} [ch8Voltage] PowerMetrics ch8Voltage
         * @property {number|null} [ch8Current] PowerMetrics ch8Current
         */

        /**
         * Constructs a new PowerMetrics.
         * @memberof meshtastic
         * @classdesc Represents a PowerMetrics.
         * @implements IPowerMetrics
         * @constructor
         * @param {meshtastic.IPowerMetrics=} [properties] Properties to set
         */
        function PowerMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PowerMetrics ch1Voltage.
         * @member {number|null|undefined} ch1Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch1Voltage = null;

        /**
         * PowerMetrics ch1Current.
         * @member {number|null|undefined} ch1Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch1Current = null;

        /**
         * PowerMetrics ch2Voltage.
         * @member {number|null|undefined} ch2Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch2Voltage = null;

        /**
         * PowerMetrics ch2Current.
         * @member {number|null|undefined} ch2Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch2Current = null;

        /**
         * PowerMetrics ch3Voltage.
         * @member {number|null|undefined} ch3Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch3Voltage = null;

        /**
         * PowerMetrics ch3Current.
         * @member {number|null|undefined} ch3Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch3Current = null;

        /**
         * PowerMetrics ch4Voltage.
         * @member {number|null|undefined} ch4Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch4Voltage = null;

        /**
         * PowerMetrics ch4Current.
         * @member {number|null|undefined} ch4Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch4Current = null;

        /**
         * PowerMetrics ch5Voltage.
         * @member {number|null|undefined} ch5Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch5Voltage = null;

        /**
         * PowerMetrics ch5Current.
         * @member {number|null|undefined} ch5Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch5Current = null;

        /**
         * PowerMetrics ch6Voltage.
         * @member {number|null|undefined} ch6Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch6Voltage = null;

        /**
         * PowerMetrics ch6Current.
         * @member {number|null|undefined} ch6Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch6Current = null;

        /**
         * PowerMetrics ch7Voltage.
         * @member {number|null|undefined} ch7Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch7Voltage = null;

        /**
         * PowerMetrics ch7Current.
         * @member {number|null|undefined} ch7Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch7Current = null;

        /**
         * PowerMetrics ch8Voltage.
         * @member {number|null|undefined} ch8Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch8Voltage = null;

        /**
         * PowerMetrics ch8Current.
         * @member {number|null|undefined} ch8Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        PowerMetrics.prototype.ch8Current = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PowerMetrics _ch1Voltage.
         * @member {"ch1Voltage"|undefined} _ch1Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch1Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch1Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch1Current.
         * @member {"ch1Current"|undefined} _ch1Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch1Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch1Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch2Voltage.
         * @member {"ch2Voltage"|undefined} _ch2Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch2Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch2Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch2Current.
         * @member {"ch2Current"|undefined} _ch2Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch2Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch2Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch3Voltage.
         * @member {"ch3Voltage"|undefined} _ch3Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch3Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch3Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch3Current.
         * @member {"ch3Current"|undefined} _ch3Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch3Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch3Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch4Voltage.
         * @member {"ch4Voltage"|undefined} _ch4Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch4Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch4Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch4Current.
         * @member {"ch4Current"|undefined} _ch4Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch4Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch4Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch5Voltage.
         * @member {"ch5Voltage"|undefined} _ch5Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch5Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch5Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch5Current.
         * @member {"ch5Current"|undefined} _ch5Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch5Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch5Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch6Voltage.
         * @member {"ch6Voltage"|undefined} _ch6Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch6Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch6Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch6Current.
         * @member {"ch6Current"|undefined} _ch6Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch6Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch6Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch7Voltage.
         * @member {"ch7Voltage"|undefined} _ch7Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch7Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch7Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch7Current.
         * @member {"ch7Current"|undefined} _ch7Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch7Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch7Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch8Voltage.
         * @member {"ch8Voltage"|undefined} _ch8Voltage
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch8Voltage", {
            get: $util.oneOfGetter($oneOfFields = ["ch8Voltage"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PowerMetrics _ch8Current.
         * @member {"ch8Current"|undefined} _ch8Current
         * @memberof meshtastic.PowerMetrics
         * @instance
         */
        Object.defineProperty(PowerMetrics.prototype, "_ch8Current", {
            get: $util.oneOfGetter($oneOfFields = ["ch8Current"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PowerMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {meshtastic.IPowerMetrics=} [properties] Properties to set
         * @returns {meshtastic.PowerMetrics} PowerMetrics instance
         */
        PowerMetrics.create = function create(properties) {
            return new PowerMetrics(properties);
        };

        /**
         * Encodes the specified PowerMetrics message. Does not implicitly {@link meshtastic.PowerMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {meshtastic.IPowerMetrics} message PowerMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PowerMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ch1Voltage != null && Object.hasOwnProperty.call(message, "ch1Voltage"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.ch1Voltage);
            if (message.ch1Current != null && Object.hasOwnProperty.call(message, "ch1Current"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.ch1Current);
            if (message.ch2Voltage != null && Object.hasOwnProperty.call(message, "ch2Voltage"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.ch2Voltage);
            if (message.ch2Current != null && Object.hasOwnProperty.call(message, "ch2Current"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.ch2Current);
            if (message.ch3Voltage != null && Object.hasOwnProperty.call(message, "ch3Voltage"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.ch3Voltage);
            if (message.ch3Current != null && Object.hasOwnProperty.call(message, "ch3Current"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.ch3Current);
            if (message.ch4Voltage != null && Object.hasOwnProperty.call(message, "ch4Voltage"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.ch4Voltage);
            if (message.ch4Current != null && Object.hasOwnProperty.call(message, "ch4Current"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.ch4Current);
            if (message.ch5Voltage != null && Object.hasOwnProperty.call(message, "ch5Voltage"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.ch5Voltage);
            if (message.ch5Current != null && Object.hasOwnProperty.call(message, "ch5Current"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.ch5Current);
            if (message.ch6Voltage != null && Object.hasOwnProperty.call(message, "ch6Voltage"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.ch6Voltage);
            if (message.ch6Current != null && Object.hasOwnProperty.call(message, "ch6Current"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.ch6Current);
            if (message.ch7Voltage != null && Object.hasOwnProperty.call(message, "ch7Voltage"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.ch7Voltage);
            if (message.ch7Current != null && Object.hasOwnProperty.call(message, "ch7Current"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.ch7Current);
            if (message.ch8Voltage != null && Object.hasOwnProperty.call(message, "ch8Voltage"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.ch8Voltage);
            if (message.ch8Current != null && Object.hasOwnProperty.call(message, "ch8Current"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.ch8Current);
            return writer;
        };

        /**
         * Encodes the specified PowerMetrics message, length delimited. Does not implicitly {@link meshtastic.PowerMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {meshtastic.IPowerMetrics} message PowerMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PowerMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PowerMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.PowerMetrics} PowerMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PowerMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.PowerMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ch1Voltage = reader.float();
                        break;
                    }
                case 2: {
                        message.ch1Current = reader.float();
                        break;
                    }
                case 3: {
                        message.ch2Voltage = reader.float();
                        break;
                    }
                case 4: {
                        message.ch2Current = reader.float();
                        break;
                    }
                case 5: {
                        message.ch3Voltage = reader.float();
                        break;
                    }
                case 6: {
                        message.ch3Current = reader.float();
                        break;
                    }
                case 7: {
                        message.ch4Voltage = reader.float();
                        break;
                    }
                case 8: {
                        message.ch4Current = reader.float();
                        break;
                    }
                case 9: {
                        message.ch5Voltage = reader.float();
                        break;
                    }
                case 10: {
                        message.ch5Current = reader.float();
                        break;
                    }
                case 11: {
                        message.ch6Voltage = reader.float();
                        break;
                    }
                case 12: {
                        message.ch6Current = reader.float();
                        break;
                    }
                case 13: {
                        message.ch7Voltage = reader.float();
                        break;
                    }
                case 14: {
                        message.ch7Current = reader.float();
                        break;
                    }
                case 15: {
                        message.ch8Voltage = reader.float();
                        break;
                    }
                case 16: {
                        message.ch8Current = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PowerMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.PowerMetrics} PowerMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PowerMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PowerMetrics message.
         * @function verify
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PowerMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ch1Voltage != null && message.hasOwnProperty("ch1Voltage")) {
                properties._ch1Voltage = 1;
                if (typeof message.ch1Voltage !== "number")
                    return "ch1Voltage: number expected";
            }
            if (message.ch1Current != null && message.hasOwnProperty("ch1Current")) {
                properties._ch1Current = 1;
                if (typeof message.ch1Current !== "number")
                    return "ch1Current: number expected";
            }
            if (message.ch2Voltage != null && message.hasOwnProperty("ch2Voltage")) {
                properties._ch2Voltage = 1;
                if (typeof message.ch2Voltage !== "number")
                    return "ch2Voltage: number expected";
            }
            if (message.ch2Current != null && message.hasOwnProperty("ch2Current")) {
                properties._ch2Current = 1;
                if (typeof message.ch2Current !== "number")
                    return "ch2Current: number expected";
            }
            if (message.ch3Voltage != null && message.hasOwnProperty("ch3Voltage")) {
                properties._ch3Voltage = 1;
                if (typeof message.ch3Voltage !== "number")
                    return "ch3Voltage: number expected";
            }
            if (message.ch3Current != null && message.hasOwnProperty("ch3Current")) {
                properties._ch3Current = 1;
                if (typeof message.ch3Current !== "number")
                    return "ch3Current: number expected";
            }
            if (message.ch4Voltage != null && message.hasOwnProperty("ch4Voltage")) {
                properties._ch4Voltage = 1;
                if (typeof message.ch4Voltage !== "number")
                    return "ch4Voltage: number expected";
            }
            if (message.ch4Current != null && message.hasOwnProperty("ch4Current")) {
                properties._ch4Current = 1;
                if (typeof message.ch4Current !== "number")
                    return "ch4Current: number expected";
            }
            if (message.ch5Voltage != null && message.hasOwnProperty("ch5Voltage")) {
                properties._ch5Voltage = 1;
                if (typeof message.ch5Voltage !== "number")
                    return "ch5Voltage: number expected";
            }
            if (message.ch5Current != null && message.hasOwnProperty("ch5Current")) {
                properties._ch5Current = 1;
                if (typeof message.ch5Current !== "number")
                    return "ch5Current: number expected";
            }
            if (message.ch6Voltage != null && message.hasOwnProperty("ch6Voltage")) {
                properties._ch6Voltage = 1;
                if (typeof message.ch6Voltage !== "number")
                    return "ch6Voltage: number expected";
            }
            if (message.ch6Current != null && message.hasOwnProperty("ch6Current")) {
                properties._ch6Current = 1;
                if (typeof message.ch6Current !== "number")
                    return "ch6Current: number expected";
            }
            if (message.ch7Voltage != null && message.hasOwnProperty("ch7Voltage")) {
                properties._ch7Voltage = 1;
                if (typeof message.ch7Voltage !== "number")
                    return "ch7Voltage: number expected";
            }
            if (message.ch7Current != null && message.hasOwnProperty("ch7Current")) {
                properties._ch7Current = 1;
                if (typeof message.ch7Current !== "number")
                    return "ch7Current: number expected";
            }
            if (message.ch8Voltage != null && message.hasOwnProperty("ch8Voltage")) {
                properties._ch8Voltage = 1;
                if (typeof message.ch8Voltage !== "number")
                    return "ch8Voltage: number expected";
            }
            if (message.ch8Current != null && message.hasOwnProperty("ch8Current")) {
                properties._ch8Current = 1;
                if (typeof message.ch8Current !== "number")
                    return "ch8Current: number expected";
            }
            return null;
        };

        /**
         * Creates a PowerMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.PowerMetrics} PowerMetrics
         */
        PowerMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.PowerMetrics)
                return object;
            var message = new $root.meshtastic.PowerMetrics();
            if (object.ch1Voltage != null)
                message.ch1Voltage = Number(object.ch1Voltage);
            if (object.ch1Current != null)
                message.ch1Current = Number(object.ch1Current);
            if (object.ch2Voltage != null)
                message.ch2Voltage = Number(object.ch2Voltage);
            if (object.ch2Current != null)
                message.ch2Current = Number(object.ch2Current);
            if (object.ch3Voltage != null)
                message.ch3Voltage = Number(object.ch3Voltage);
            if (object.ch3Current != null)
                message.ch3Current = Number(object.ch3Current);
            if (object.ch4Voltage != null)
                message.ch4Voltage = Number(object.ch4Voltage);
            if (object.ch4Current != null)
                message.ch4Current = Number(object.ch4Current);
            if (object.ch5Voltage != null)
                message.ch5Voltage = Number(object.ch5Voltage);
            if (object.ch5Current != null)
                message.ch5Current = Number(object.ch5Current);
            if (object.ch6Voltage != null)
                message.ch6Voltage = Number(object.ch6Voltage);
            if (object.ch6Current != null)
                message.ch6Current = Number(object.ch6Current);
            if (object.ch7Voltage != null)
                message.ch7Voltage = Number(object.ch7Voltage);
            if (object.ch7Current != null)
                message.ch7Current = Number(object.ch7Current);
            if (object.ch8Voltage != null)
                message.ch8Voltage = Number(object.ch8Voltage);
            if (object.ch8Current != null)
                message.ch8Current = Number(object.ch8Current);
            return message;
        };

        /**
         * Creates a plain object from a PowerMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {meshtastic.PowerMetrics} message PowerMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PowerMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ch1Voltage != null && message.hasOwnProperty("ch1Voltage")) {
                object.ch1Voltage = options.json && !isFinite(message.ch1Voltage) ? String(message.ch1Voltage) : message.ch1Voltage;
                if (options.oneofs)
                    object._ch1Voltage = "ch1Voltage";
            }
            if (message.ch1Current != null && message.hasOwnProperty("ch1Current")) {
                object.ch1Current = options.json && !isFinite(message.ch1Current) ? String(message.ch1Current) : message.ch1Current;
                if (options.oneofs)
                    object._ch1Current = "ch1Current";
            }
            if (message.ch2Voltage != null && message.hasOwnProperty("ch2Voltage")) {
                object.ch2Voltage = options.json && !isFinite(message.ch2Voltage) ? String(message.ch2Voltage) : message.ch2Voltage;
                if (options.oneofs)
                    object._ch2Voltage = "ch2Voltage";
            }
            if (message.ch2Current != null && message.hasOwnProperty("ch2Current")) {
                object.ch2Current = options.json && !isFinite(message.ch2Current) ? String(message.ch2Current) : message.ch2Current;
                if (options.oneofs)
                    object._ch2Current = "ch2Current";
            }
            if (message.ch3Voltage != null && message.hasOwnProperty("ch3Voltage")) {
                object.ch3Voltage = options.json && !isFinite(message.ch3Voltage) ? String(message.ch3Voltage) : message.ch3Voltage;
                if (options.oneofs)
                    object._ch3Voltage = "ch3Voltage";
            }
            if (message.ch3Current != null && message.hasOwnProperty("ch3Current")) {
                object.ch3Current = options.json && !isFinite(message.ch3Current) ? String(message.ch3Current) : message.ch3Current;
                if (options.oneofs)
                    object._ch3Current = "ch3Current";
            }
            if (message.ch4Voltage != null && message.hasOwnProperty("ch4Voltage")) {
                object.ch4Voltage = options.json && !isFinite(message.ch4Voltage) ? String(message.ch4Voltage) : message.ch4Voltage;
                if (options.oneofs)
                    object._ch4Voltage = "ch4Voltage";
            }
            if (message.ch4Current != null && message.hasOwnProperty("ch4Current")) {
                object.ch4Current = options.json && !isFinite(message.ch4Current) ? String(message.ch4Current) : message.ch4Current;
                if (options.oneofs)
                    object._ch4Current = "ch4Current";
            }
            if (message.ch5Voltage != null && message.hasOwnProperty("ch5Voltage")) {
                object.ch5Voltage = options.json && !isFinite(message.ch5Voltage) ? String(message.ch5Voltage) : message.ch5Voltage;
                if (options.oneofs)
                    object._ch5Voltage = "ch5Voltage";
            }
            if (message.ch5Current != null && message.hasOwnProperty("ch5Current")) {
                object.ch5Current = options.json && !isFinite(message.ch5Current) ? String(message.ch5Current) : message.ch5Current;
                if (options.oneofs)
                    object._ch5Current = "ch5Current";
            }
            if (message.ch6Voltage != null && message.hasOwnProperty("ch6Voltage")) {
                object.ch6Voltage = options.json && !isFinite(message.ch6Voltage) ? String(message.ch6Voltage) : message.ch6Voltage;
                if (options.oneofs)
                    object._ch6Voltage = "ch6Voltage";
            }
            if (message.ch6Current != null && message.hasOwnProperty("ch6Current")) {
                object.ch6Current = options.json && !isFinite(message.ch6Current) ? String(message.ch6Current) : message.ch6Current;
                if (options.oneofs)
                    object._ch6Current = "ch6Current";
            }
            if (message.ch7Voltage != null && message.hasOwnProperty("ch7Voltage")) {
                object.ch7Voltage = options.json && !isFinite(message.ch7Voltage) ? String(message.ch7Voltage) : message.ch7Voltage;
                if (options.oneofs)
                    object._ch7Voltage = "ch7Voltage";
            }
            if (message.ch7Current != null && message.hasOwnProperty("ch7Current")) {
                object.ch7Current = options.json && !isFinite(message.ch7Current) ? String(message.ch7Current) : message.ch7Current;
                if (options.oneofs)
                    object._ch7Current = "ch7Current";
            }
            if (message.ch8Voltage != null && message.hasOwnProperty("ch8Voltage")) {
                object.ch8Voltage = options.json && !isFinite(message.ch8Voltage) ? String(message.ch8Voltage) : message.ch8Voltage;
                if (options.oneofs)
                    object._ch8Voltage = "ch8Voltage";
            }
            if (message.ch8Current != null && message.hasOwnProperty("ch8Current")) {
                object.ch8Current = options.json && !isFinite(message.ch8Current) ? String(message.ch8Current) : message.ch8Current;
                if (options.oneofs)
                    object._ch8Current = "ch8Current";
            }
            return object;
        };

        /**
         * Converts this PowerMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.PowerMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PowerMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PowerMetrics
         * @function getTypeUrl
         * @memberof meshtastic.PowerMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PowerMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.PowerMetrics";
        };

        return PowerMetrics;
    })();

    meshtastic.AirQualityMetrics = (function() {

        /**
         * Properties of an AirQualityMetrics.
         * @memberof meshtastic
         * @interface IAirQualityMetrics
         * @property {number|null} [pm10Standard] AirQualityMetrics pm10Standard
         * @property {number|null} [pm25Standard] AirQualityMetrics pm25Standard
         * @property {number|null} [pm100Standard] AirQualityMetrics pm100Standard
         * @property {number|null} [pm10Environmental] AirQualityMetrics pm10Environmental
         * @property {number|null} [pm25Environmental] AirQualityMetrics pm25Environmental
         * @property {number|null} [pm100Environmental] AirQualityMetrics pm100Environmental
         * @property {number|null} [particles_03um] AirQualityMetrics particles_03um
         * @property {number|null} [particles_05um] AirQualityMetrics particles_05um
         * @property {number|null} [particles_10um] AirQualityMetrics particles_10um
         * @property {number|null} [particles_25um] AirQualityMetrics particles_25um
         * @property {number|null} [particles_50um] AirQualityMetrics particles_50um
         * @property {number|null} [particles_100um] AirQualityMetrics particles_100um
         * @property {number|null} [co2] AirQualityMetrics co2
         * @property {number|null} [co2Temperature] AirQualityMetrics co2Temperature
         * @property {number|null} [co2Humidity] AirQualityMetrics co2Humidity
         * @property {number|null} [formFormaldehyde] AirQualityMetrics formFormaldehyde
         * @property {number|null} [formHumidity] AirQualityMetrics formHumidity
         * @property {number|null} [formTemperature] AirQualityMetrics formTemperature
         * @property {number|null} [pm40Standard] AirQualityMetrics pm40Standard
         * @property {number|null} [particles_40um] AirQualityMetrics particles_40um
         * @property {number|null} [pmTemperature] AirQualityMetrics pmTemperature
         * @property {number|null} [pmHumidity] AirQualityMetrics pmHumidity
         * @property {number|null} [pmVocIdx] AirQualityMetrics pmVocIdx
         * @property {number|null} [pmNoxIdx] AirQualityMetrics pmNoxIdx
         * @property {number|null} [particlesTps] AirQualityMetrics particlesTps
         */

        /**
         * Constructs a new AirQualityMetrics.
         * @memberof meshtastic
         * @classdesc Represents an AirQualityMetrics.
         * @implements IAirQualityMetrics
         * @constructor
         * @param {meshtastic.IAirQualityMetrics=} [properties] Properties to set
         */
        function AirQualityMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AirQualityMetrics pm10Standard.
         * @member {number|null|undefined} pm10Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm10Standard = null;

        /**
         * AirQualityMetrics pm25Standard.
         * @member {number|null|undefined} pm25Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm25Standard = null;

        /**
         * AirQualityMetrics pm100Standard.
         * @member {number|null|undefined} pm100Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm100Standard = null;

        /**
         * AirQualityMetrics pm10Environmental.
         * @member {number|null|undefined} pm10Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm10Environmental = null;

        /**
         * AirQualityMetrics pm25Environmental.
         * @member {number|null|undefined} pm25Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm25Environmental = null;

        /**
         * AirQualityMetrics pm100Environmental.
         * @member {number|null|undefined} pm100Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm100Environmental = null;

        /**
         * AirQualityMetrics particles_03um.
         * @member {number|null|undefined} particles_03um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_03um = null;

        /**
         * AirQualityMetrics particles_05um.
         * @member {number|null|undefined} particles_05um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_05um = null;

        /**
         * AirQualityMetrics particles_10um.
         * @member {number|null|undefined} particles_10um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_10um = null;

        /**
         * AirQualityMetrics particles_25um.
         * @member {number|null|undefined} particles_25um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_25um = null;

        /**
         * AirQualityMetrics particles_50um.
         * @member {number|null|undefined} particles_50um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_50um = null;

        /**
         * AirQualityMetrics particles_100um.
         * @member {number|null|undefined} particles_100um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_100um = null;

        /**
         * AirQualityMetrics co2.
         * @member {number|null|undefined} co2
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.co2 = null;

        /**
         * AirQualityMetrics co2Temperature.
         * @member {number|null|undefined} co2Temperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.co2Temperature = null;

        /**
         * AirQualityMetrics co2Humidity.
         * @member {number|null|undefined} co2Humidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.co2Humidity = null;

        /**
         * AirQualityMetrics formFormaldehyde.
         * @member {number|null|undefined} formFormaldehyde
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.formFormaldehyde = null;

        /**
         * AirQualityMetrics formHumidity.
         * @member {number|null|undefined} formHumidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.formHumidity = null;

        /**
         * AirQualityMetrics formTemperature.
         * @member {number|null|undefined} formTemperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.formTemperature = null;

        /**
         * AirQualityMetrics pm40Standard.
         * @member {number|null|undefined} pm40Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pm40Standard = null;

        /**
         * AirQualityMetrics particles_40um.
         * @member {number|null|undefined} particles_40um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particles_40um = null;

        /**
         * AirQualityMetrics pmTemperature.
         * @member {number|null|undefined} pmTemperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pmTemperature = null;

        /**
         * AirQualityMetrics pmHumidity.
         * @member {number|null|undefined} pmHumidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pmHumidity = null;

        /**
         * AirQualityMetrics pmVocIdx.
         * @member {number|null|undefined} pmVocIdx
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pmVocIdx = null;

        /**
         * AirQualityMetrics pmNoxIdx.
         * @member {number|null|undefined} pmNoxIdx
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.pmNoxIdx = null;

        /**
         * AirQualityMetrics particlesTps.
         * @member {number|null|undefined} particlesTps
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        AirQualityMetrics.prototype.particlesTps = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AirQualityMetrics _pm10Standard.
         * @member {"pm10Standard"|undefined} _pm10Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm10Standard", {
            get: $util.oneOfGetter($oneOfFields = ["pm10Standard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm25Standard.
         * @member {"pm25Standard"|undefined} _pm25Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm25Standard", {
            get: $util.oneOfGetter($oneOfFields = ["pm25Standard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm100Standard.
         * @member {"pm100Standard"|undefined} _pm100Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm100Standard", {
            get: $util.oneOfGetter($oneOfFields = ["pm100Standard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm10Environmental.
         * @member {"pm10Environmental"|undefined} _pm10Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm10Environmental", {
            get: $util.oneOfGetter($oneOfFields = ["pm10Environmental"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm25Environmental.
         * @member {"pm25Environmental"|undefined} _pm25Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm25Environmental", {
            get: $util.oneOfGetter($oneOfFields = ["pm25Environmental"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm100Environmental.
         * @member {"pm100Environmental"|undefined} _pm100Environmental
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm100Environmental", {
            get: $util.oneOfGetter($oneOfFields = ["pm100Environmental"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_03um.
         * @member {"particles_03um"|undefined} _particles_03um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_03um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_03um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_05um.
         * @member {"particles_05um"|undefined} _particles_05um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_05um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_05um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_10um.
         * @member {"particles_10um"|undefined} _particles_10um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_10um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_10um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_25um.
         * @member {"particles_25um"|undefined} _particles_25um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_25um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_25um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_50um.
         * @member {"particles_50um"|undefined} _particles_50um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_50um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_50um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_100um.
         * @member {"particles_100um"|undefined} _particles_100um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_100um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_100um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _co2.
         * @member {"co2"|undefined} _co2
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_co2", {
            get: $util.oneOfGetter($oneOfFields = ["co2"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _co2Temperature.
         * @member {"co2Temperature"|undefined} _co2Temperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_co2Temperature", {
            get: $util.oneOfGetter($oneOfFields = ["co2Temperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _co2Humidity.
         * @member {"co2Humidity"|undefined} _co2Humidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_co2Humidity", {
            get: $util.oneOfGetter($oneOfFields = ["co2Humidity"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _formFormaldehyde.
         * @member {"formFormaldehyde"|undefined} _formFormaldehyde
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_formFormaldehyde", {
            get: $util.oneOfGetter($oneOfFields = ["formFormaldehyde"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _formHumidity.
         * @member {"formHumidity"|undefined} _formHumidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_formHumidity", {
            get: $util.oneOfGetter($oneOfFields = ["formHumidity"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _formTemperature.
         * @member {"formTemperature"|undefined} _formTemperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_formTemperature", {
            get: $util.oneOfGetter($oneOfFields = ["formTemperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pm40Standard.
         * @member {"pm40Standard"|undefined} _pm40Standard
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pm40Standard", {
            get: $util.oneOfGetter($oneOfFields = ["pm40Standard"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particles_40um.
         * @member {"particles_40um"|undefined} _particles_40um
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particles_40um", {
            get: $util.oneOfGetter($oneOfFields = ["particles_40um"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pmTemperature.
         * @member {"pmTemperature"|undefined} _pmTemperature
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pmTemperature", {
            get: $util.oneOfGetter($oneOfFields = ["pmTemperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pmHumidity.
         * @member {"pmHumidity"|undefined} _pmHumidity
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pmHumidity", {
            get: $util.oneOfGetter($oneOfFields = ["pmHumidity"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pmVocIdx.
         * @member {"pmVocIdx"|undefined} _pmVocIdx
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pmVocIdx", {
            get: $util.oneOfGetter($oneOfFields = ["pmVocIdx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _pmNoxIdx.
         * @member {"pmNoxIdx"|undefined} _pmNoxIdx
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_pmNoxIdx", {
            get: $util.oneOfGetter($oneOfFields = ["pmNoxIdx"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * AirQualityMetrics _particlesTps.
         * @member {"particlesTps"|undefined} _particlesTps
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         */
        Object.defineProperty(AirQualityMetrics.prototype, "_particlesTps", {
            get: $util.oneOfGetter($oneOfFields = ["particlesTps"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AirQualityMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {meshtastic.IAirQualityMetrics=} [properties] Properties to set
         * @returns {meshtastic.AirQualityMetrics} AirQualityMetrics instance
         */
        AirQualityMetrics.create = function create(properties) {
            return new AirQualityMetrics(properties);
        };

        /**
         * Encodes the specified AirQualityMetrics message. Does not implicitly {@link meshtastic.AirQualityMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {meshtastic.IAirQualityMetrics} message AirQualityMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AirQualityMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pm10Standard != null && Object.hasOwnProperty.call(message, "pm10Standard"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.pm10Standard);
            if (message.pm25Standard != null && Object.hasOwnProperty.call(message, "pm25Standard"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pm25Standard);
            if (message.pm100Standard != null && Object.hasOwnProperty.call(message, "pm100Standard"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.pm100Standard);
            if (message.pm10Environmental != null && Object.hasOwnProperty.call(message, "pm10Environmental"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.pm10Environmental);
            if (message.pm25Environmental != null && Object.hasOwnProperty.call(message, "pm25Environmental"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.pm25Environmental);
            if (message.pm100Environmental != null && Object.hasOwnProperty.call(message, "pm100Environmental"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.pm100Environmental);
            if (message.particles_03um != null && Object.hasOwnProperty.call(message, "particles_03um"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.particles_03um);
            if (message.particles_05um != null && Object.hasOwnProperty.call(message, "particles_05um"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.particles_05um);
            if (message.particles_10um != null && Object.hasOwnProperty.call(message, "particles_10um"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.particles_10um);
            if (message.particles_25um != null && Object.hasOwnProperty.call(message, "particles_25um"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.particles_25um);
            if (message.particles_50um != null && Object.hasOwnProperty.call(message, "particles_50um"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.particles_50um);
            if (message.particles_100um != null && Object.hasOwnProperty.call(message, "particles_100um"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.particles_100um);
            if (message.co2 != null && Object.hasOwnProperty.call(message, "co2"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.co2);
            if (message.co2Temperature != null && Object.hasOwnProperty.call(message, "co2Temperature"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.co2Temperature);
            if (message.co2Humidity != null && Object.hasOwnProperty.call(message, "co2Humidity"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.co2Humidity);
            if (message.formFormaldehyde != null && Object.hasOwnProperty.call(message, "formFormaldehyde"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.formFormaldehyde);
            if (message.formHumidity != null && Object.hasOwnProperty.call(message, "formHumidity"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.formHumidity);
            if (message.formTemperature != null && Object.hasOwnProperty.call(message, "formTemperature"))
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.formTemperature);
            if (message.pm40Standard != null && Object.hasOwnProperty.call(message, "pm40Standard"))
                writer.uint32(/* id 19, wireType 0 =*/152).uint32(message.pm40Standard);
            if (message.particles_40um != null && Object.hasOwnProperty.call(message, "particles_40um"))
                writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.particles_40um);
            if (message.pmTemperature != null && Object.hasOwnProperty.call(message, "pmTemperature"))
                writer.uint32(/* id 21, wireType 5 =*/173).float(message.pmTemperature);
            if (message.pmHumidity != null && Object.hasOwnProperty.call(message, "pmHumidity"))
                writer.uint32(/* id 22, wireType 5 =*/181).float(message.pmHumidity);
            if (message.pmVocIdx != null && Object.hasOwnProperty.call(message, "pmVocIdx"))
                writer.uint32(/* id 23, wireType 5 =*/189).float(message.pmVocIdx);
            if (message.pmNoxIdx != null && Object.hasOwnProperty.call(message, "pmNoxIdx"))
                writer.uint32(/* id 24, wireType 5 =*/197).float(message.pmNoxIdx);
            if (message.particlesTps != null && Object.hasOwnProperty.call(message, "particlesTps"))
                writer.uint32(/* id 25, wireType 5 =*/205).float(message.particlesTps);
            return writer;
        };

        /**
         * Encodes the specified AirQualityMetrics message, length delimited. Does not implicitly {@link meshtastic.AirQualityMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {meshtastic.IAirQualityMetrics} message AirQualityMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AirQualityMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AirQualityMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.AirQualityMetrics} AirQualityMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AirQualityMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.AirQualityMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pm10Standard = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pm25Standard = reader.uint32();
                        break;
                    }
                case 3: {
                        message.pm100Standard = reader.uint32();
                        break;
                    }
                case 4: {
                        message.pm10Environmental = reader.uint32();
                        break;
                    }
                case 5: {
                        message.pm25Environmental = reader.uint32();
                        break;
                    }
                case 6: {
                        message.pm100Environmental = reader.uint32();
                        break;
                    }
                case 7: {
                        message.particles_03um = reader.uint32();
                        break;
                    }
                case 8: {
                        message.particles_05um = reader.uint32();
                        break;
                    }
                case 9: {
                        message.particles_10um = reader.uint32();
                        break;
                    }
                case 10: {
                        message.particles_25um = reader.uint32();
                        break;
                    }
                case 11: {
                        message.particles_50um = reader.uint32();
                        break;
                    }
                case 12: {
                        message.particles_100um = reader.uint32();
                        break;
                    }
                case 13: {
                        message.co2 = reader.uint32();
                        break;
                    }
                case 14: {
                        message.co2Temperature = reader.float();
                        break;
                    }
                case 15: {
                        message.co2Humidity = reader.float();
                        break;
                    }
                case 16: {
                        message.formFormaldehyde = reader.float();
                        break;
                    }
                case 17: {
                        message.formHumidity = reader.float();
                        break;
                    }
                case 18: {
                        message.formTemperature = reader.float();
                        break;
                    }
                case 19: {
                        message.pm40Standard = reader.uint32();
                        break;
                    }
                case 20: {
                        message.particles_40um = reader.uint32();
                        break;
                    }
                case 21: {
                        message.pmTemperature = reader.float();
                        break;
                    }
                case 22: {
                        message.pmHumidity = reader.float();
                        break;
                    }
                case 23: {
                        message.pmVocIdx = reader.float();
                        break;
                    }
                case 24: {
                        message.pmNoxIdx = reader.float();
                        break;
                    }
                case 25: {
                        message.particlesTps = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AirQualityMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.AirQualityMetrics} AirQualityMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AirQualityMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AirQualityMetrics message.
         * @function verify
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AirQualityMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.pm10Standard != null && message.hasOwnProperty("pm10Standard")) {
                properties._pm10Standard = 1;
                if (!$util.isInteger(message.pm10Standard))
                    return "pm10Standard: integer expected";
            }
            if (message.pm25Standard != null && message.hasOwnProperty("pm25Standard")) {
                properties._pm25Standard = 1;
                if (!$util.isInteger(message.pm25Standard))
                    return "pm25Standard: integer expected";
            }
            if (message.pm100Standard != null && message.hasOwnProperty("pm100Standard")) {
                properties._pm100Standard = 1;
                if (!$util.isInteger(message.pm100Standard))
                    return "pm100Standard: integer expected";
            }
            if (message.pm10Environmental != null && message.hasOwnProperty("pm10Environmental")) {
                properties._pm10Environmental = 1;
                if (!$util.isInteger(message.pm10Environmental))
                    return "pm10Environmental: integer expected";
            }
            if (message.pm25Environmental != null && message.hasOwnProperty("pm25Environmental")) {
                properties._pm25Environmental = 1;
                if (!$util.isInteger(message.pm25Environmental))
                    return "pm25Environmental: integer expected";
            }
            if (message.pm100Environmental != null && message.hasOwnProperty("pm100Environmental")) {
                properties._pm100Environmental = 1;
                if (!$util.isInteger(message.pm100Environmental))
                    return "pm100Environmental: integer expected";
            }
            if (message.particles_03um != null && message.hasOwnProperty("particles_03um")) {
                properties._particles_03um = 1;
                if (!$util.isInteger(message.particles_03um))
                    return "particles_03um: integer expected";
            }
            if (message.particles_05um != null && message.hasOwnProperty("particles_05um")) {
                properties._particles_05um = 1;
                if (!$util.isInteger(message.particles_05um))
                    return "particles_05um: integer expected";
            }
            if (message.particles_10um != null && message.hasOwnProperty("particles_10um")) {
                properties._particles_10um = 1;
                if (!$util.isInteger(message.particles_10um))
                    return "particles_10um: integer expected";
            }
            if (message.particles_25um != null && message.hasOwnProperty("particles_25um")) {
                properties._particles_25um = 1;
                if (!$util.isInteger(message.particles_25um))
                    return "particles_25um: integer expected";
            }
            if (message.particles_50um != null && message.hasOwnProperty("particles_50um")) {
                properties._particles_50um = 1;
                if (!$util.isInteger(message.particles_50um))
                    return "particles_50um: integer expected";
            }
            if (message.particles_100um != null && message.hasOwnProperty("particles_100um")) {
                properties._particles_100um = 1;
                if (!$util.isInteger(message.particles_100um))
                    return "particles_100um: integer expected";
            }
            if (message.co2 != null && message.hasOwnProperty("co2")) {
                properties._co2 = 1;
                if (!$util.isInteger(message.co2))
                    return "co2: integer expected";
            }
            if (message.co2Temperature != null && message.hasOwnProperty("co2Temperature")) {
                properties._co2Temperature = 1;
                if (typeof message.co2Temperature !== "number")
                    return "co2Temperature: number expected";
            }
            if (message.co2Humidity != null && message.hasOwnProperty("co2Humidity")) {
                properties._co2Humidity = 1;
                if (typeof message.co2Humidity !== "number")
                    return "co2Humidity: number expected";
            }
            if (message.formFormaldehyde != null && message.hasOwnProperty("formFormaldehyde")) {
                properties._formFormaldehyde = 1;
                if (typeof message.formFormaldehyde !== "number")
                    return "formFormaldehyde: number expected";
            }
            if (message.formHumidity != null && message.hasOwnProperty("formHumidity")) {
                properties._formHumidity = 1;
                if (typeof message.formHumidity !== "number")
                    return "formHumidity: number expected";
            }
            if (message.formTemperature != null && message.hasOwnProperty("formTemperature")) {
                properties._formTemperature = 1;
                if (typeof message.formTemperature !== "number")
                    return "formTemperature: number expected";
            }
            if (message.pm40Standard != null && message.hasOwnProperty("pm40Standard")) {
                properties._pm40Standard = 1;
                if (!$util.isInteger(message.pm40Standard))
                    return "pm40Standard: integer expected";
            }
            if (message.particles_40um != null && message.hasOwnProperty("particles_40um")) {
                properties._particles_40um = 1;
                if (!$util.isInteger(message.particles_40um))
                    return "particles_40um: integer expected";
            }
            if (message.pmTemperature != null && message.hasOwnProperty("pmTemperature")) {
                properties._pmTemperature = 1;
                if (typeof message.pmTemperature !== "number")
                    return "pmTemperature: number expected";
            }
            if (message.pmHumidity != null && message.hasOwnProperty("pmHumidity")) {
                properties._pmHumidity = 1;
                if (typeof message.pmHumidity !== "number")
                    return "pmHumidity: number expected";
            }
            if (message.pmVocIdx != null && message.hasOwnProperty("pmVocIdx")) {
                properties._pmVocIdx = 1;
                if (typeof message.pmVocIdx !== "number")
                    return "pmVocIdx: number expected";
            }
            if (message.pmNoxIdx != null && message.hasOwnProperty("pmNoxIdx")) {
                properties._pmNoxIdx = 1;
                if (typeof message.pmNoxIdx !== "number")
                    return "pmNoxIdx: number expected";
            }
            if (message.particlesTps != null && message.hasOwnProperty("particlesTps")) {
                properties._particlesTps = 1;
                if (typeof message.particlesTps !== "number")
                    return "particlesTps: number expected";
            }
            return null;
        };

        /**
         * Creates an AirQualityMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.AirQualityMetrics} AirQualityMetrics
         */
        AirQualityMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.AirQualityMetrics)
                return object;
            var message = new $root.meshtastic.AirQualityMetrics();
            if (object.pm10Standard != null)
                message.pm10Standard = object.pm10Standard >>> 0;
            if (object.pm25Standard != null)
                message.pm25Standard = object.pm25Standard >>> 0;
            if (object.pm100Standard != null)
                message.pm100Standard = object.pm100Standard >>> 0;
            if (object.pm10Environmental != null)
                message.pm10Environmental = object.pm10Environmental >>> 0;
            if (object.pm25Environmental != null)
                message.pm25Environmental = object.pm25Environmental >>> 0;
            if (object.pm100Environmental != null)
                message.pm100Environmental = object.pm100Environmental >>> 0;
            if (object.particles_03um != null)
                message.particles_03um = object.particles_03um >>> 0;
            if (object.particles_05um != null)
                message.particles_05um = object.particles_05um >>> 0;
            if (object.particles_10um != null)
                message.particles_10um = object.particles_10um >>> 0;
            if (object.particles_25um != null)
                message.particles_25um = object.particles_25um >>> 0;
            if (object.particles_50um != null)
                message.particles_50um = object.particles_50um >>> 0;
            if (object.particles_100um != null)
                message.particles_100um = object.particles_100um >>> 0;
            if (object.co2 != null)
                message.co2 = object.co2 >>> 0;
            if (object.co2Temperature != null)
                message.co2Temperature = Number(object.co2Temperature);
            if (object.co2Humidity != null)
                message.co2Humidity = Number(object.co2Humidity);
            if (object.formFormaldehyde != null)
                message.formFormaldehyde = Number(object.formFormaldehyde);
            if (object.formHumidity != null)
                message.formHumidity = Number(object.formHumidity);
            if (object.formTemperature != null)
                message.formTemperature = Number(object.formTemperature);
            if (object.pm40Standard != null)
                message.pm40Standard = object.pm40Standard >>> 0;
            if (object.particles_40um != null)
                message.particles_40um = object.particles_40um >>> 0;
            if (object.pmTemperature != null)
                message.pmTemperature = Number(object.pmTemperature);
            if (object.pmHumidity != null)
                message.pmHumidity = Number(object.pmHumidity);
            if (object.pmVocIdx != null)
                message.pmVocIdx = Number(object.pmVocIdx);
            if (object.pmNoxIdx != null)
                message.pmNoxIdx = Number(object.pmNoxIdx);
            if (object.particlesTps != null)
                message.particlesTps = Number(object.particlesTps);
            return message;
        };

        /**
         * Creates a plain object from an AirQualityMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {meshtastic.AirQualityMetrics} message AirQualityMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AirQualityMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.pm10Standard != null && message.hasOwnProperty("pm10Standard")) {
                object.pm10Standard = message.pm10Standard;
                if (options.oneofs)
                    object._pm10Standard = "pm10Standard";
            }
            if (message.pm25Standard != null && message.hasOwnProperty("pm25Standard")) {
                object.pm25Standard = message.pm25Standard;
                if (options.oneofs)
                    object._pm25Standard = "pm25Standard";
            }
            if (message.pm100Standard != null && message.hasOwnProperty("pm100Standard")) {
                object.pm100Standard = message.pm100Standard;
                if (options.oneofs)
                    object._pm100Standard = "pm100Standard";
            }
            if (message.pm10Environmental != null && message.hasOwnProperty("pm10Environmental")) {
                object.pm10Environmental = message.pm10Environmental;
                if (options.oneofs)
                    object._pm10Environmental = "pm10Environmental";
            }
            if (message.pm25Environmental != null && message.hasOwnProperty("pm25Environmental")) {
                object.pm25Environmental = message.pm25Environmental;
                if (options.oneofs)
                    object._pm25Environmental = "pm25Environmental";
            }
            if (message.pm100Environmental != null && message.hasOwnProperty("pm100Environmental")) {
                object.pm100Environmental = message.pm100Environmental;
                if (options.oneofs)
                    object._pm100Environmental = "pm100Environmental";
            }
            if (message.particles_03um != null && message.hasOwnProperty("particles_03um")) {
                object.particles_03um = message.particles_03um;
                if (options.oneofs)
                    object._particles_03um = "particles_03um";
            }
            if (message.particles_05um != null && message.hasOwnProperty("particles_05um")) {
                object.particles_05um = message.particles_05um;
                if (options.oneofs)
                    object._particles_05um = "particles_05um";
            }
            if (message.particles_10um != null && message.hasOwnProperty("particles_10um")) {
                object.particles_10um = message.particles_10um;
                if (options.oneofs)
                    object._particles_10um = "particles_10um";
            }
            if (message.particles_25um != null && message.hasOwnProperty("particles_25um")) {
                object.particles_25um = message.particles_25um;
                if (options.oneofs)
                    object._particles_25um = "particles_25um";
            }
            if (message.particles_50um != null && message.hasOwnProperty("particles_50um")) {
                object.particles_50um = message.particles_50um;
                if (options.oneofs)
                    object._particles_50um = "particles_50um";
            }
            if (message.particles_100um != null && message.hasOwnProperty("particles_100um")) {
                object.particles_100um = message.particles_100um;
                if (options.oneofs)
                    object._particles_100um = "particles_100um";
            }
            if (message.co2 != null && message.hasOwnProperty("co2")) {
                object.co2 = message.co2;
                if (options.oneofs)
                    object._co2 = "co2";
            }
            if (message.co2Temperature != null && message.hasOwnProperty("co2Temperature")) {
                object.co2Temperature = options.json && !isFinite(message.co2Temperature) ? String(message.co2Temperature) : message.co2Temperature;
                if (options.oneofs)
                    object._co2Temperature = "co2Temperature";
            }
            if (message.co2Humidity != null && message.hasOwnProperty("co2Humidity")) {
                object.co2Humidity = options.json && !isFinite(message.co2Humidity) ? String(message.co2Humidity) : message.co2Humidity;
                if (options.oneofs)
                    object._co2Humidity = "co2Humidity";
            }
            if (message.formFormaldehyde != null && message.hasOwnProperty("formFormaldehyde")) {
                object.formFormaldehyde = options.json && !isFinite(message.formFormaldehyde) ? String(message.formFormaldehyde) : message.formFormaldehyde;
                if (options.oneofs)
                    object._formFormaldehyde = "formFormaldehyde";
            }
            if (message.formHumidity != null && message.hasOwnProperty("formHumidity")) {
                object.formHumidity = options.json && !isFinite(message.formHumidity) ? String(message.formHumidity) : message.formHumidity;
                if (options.oneofs)
                    object._formHumidity = "formHumidity";
            }
            if (message.formTemperature != null && message.hasOwnProperty("formTemperature")) {
                object.formTemperature = options.json && !isFinite(message.formTemperature) ? String(message.formTemperature) : message.formTemperature;
                if (options.oneofs)
                    object._formTemperature = "formTemperature";
            }
            if (message.pm40Standard != null && message.hasOwnProperty("pm40Standard")) {
                object.pm40Standard = message.pm40Standard;
                if (options.oneofs)
                    object._pm40Standard = "pm40Standard";
            }
            if (message.particles_40um != null && message.hasOwnProperty("particles_40um")) {
                object.particles_40um = message.particles_40um;
                if (options.oneofs)
                    object._particles_40um = "particles_40um";
            }
            if (message.pmTemperature != null && message.hasOwnProperty("pmTemperature")) {
                object.pmTemperature = options.json && !isFinite(message.pmTemperature) ? String(message.pmTemperature) : message.pmTemperature;
                if (options.oneofs)
                    object._pmTemperature = "pmTemperature";
            }
            if (message.pmHumidity != null && message.hasOwnProperty("pmHumidity")) {
                object.pmHumidity = options.json && !isFinite(message.pmHumidity) ? String(message.pmHumidity) : message.pmHumidity;
                if (options.oneofs)
                    object._pmHumidity = "pmHumidity";
            }
            if (message.pmVocIdx != null && message.hasOwnProperty("pmVocIdx")) {
                object.pmVocIdx = options.json && !isFinite(message.pmVocIdx) ? String(message.pmVocIdx) : message.pmVocIdx;
                if (options.oneofs)
                    object._pmVocIdx = "pmVocIdx";
            }
            if (message.pmNoxIdx != null && message.hasOwnProperty("pmNoxIdx")) {
                object.pmNoxIdx = options.json && !isFinite(message.pmNoxIdx) ? String(message.pmNoxIdx) : message.pmNoxIdx;
                if (options.oneofs)
                    object._pmNoxIdx = "pmNoxIdx";
            }
            if (message.particlesTps != null && message.hasOwnProperty("particlesTps")) {
                object.particlesTps = options.json && !isFinite(message.particlesTps) ? String(message.particlesTps) : message.particlesTps;
                if (options.oneofs)
                    object._particlesTps = "particlesTps";
            }
            return object;
        };

        /**
         * Converts this AirQualityMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.AirQualityMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AirQualityMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AirQualityMetrics
         * @function getTypeUrl
         * @memberof meshtastic.AirQualityMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AirQualityMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.AirQualityMetrics";
        };

        return AirQualityMetrics;
    })();

    meshtastic.LocalStats = (function() {

        /**
         * Properties of a LocalStats.
         * @memberof meshtastic
         * @interface ILocalStats
         * @property {number|null} [uptimeSeconds] LocalStats uptimeSeconds
         * @property {number|null} [channelUtilization] LocalStats channelUtilization
         * @property {number|null} [airUtilTx] LocalStats airUtilTx
         * @property {number|null} [numPacketsTx] LocalStats numPacketsTx
         * @property {number|null} [numPacketsRx] LocalStats numPacketsRx
         * @property {number|null} [numPacketsRxBad] LocalStats numPacketsRxBad
         * @property {number|null} [numOnlineNodes] LocalStats numOnlineNodes
         * @property {number|null} [numTotalNodes] LocalStats numTotalNodes
         * @property {number|null} [numRxDupe] LocalStats numRxDupe
         * @property {number|null} [numTxRelay] LocalStats numTxRelay
         * @property {number|null} [numTxRelayCanceled] LocalStats numTxRelayCanceled
         * @property {number|null} [heapTotalBytes] LocalStats heapTotalBytes
         * @property {number|null} [heapFreeBytes] LocalStats heapFreeBytes
         * @property {number|null} [numTxDropped] LocalStats numTxDropped
         */

        /**
         * Constructs a new LocalStats.
         * @memberof meshtastic
         * @classdesc Represents a LocalStats.
         * @implements ILocalStats
         * @constructor
         * @param {meshtastic.ILocalStats=} [properties] Properties to set
         */
        function LocalStats(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LocalStats uptimeSeconds.
         * @member {number} uptimeSeconds
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.uptimeSeconds = 0;

        /**
         * LocalStats channelUtilization.
         * @member {number} channelUtilization
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.channelUtilization = 0;

        /**
         * LocalStats airUtilTx.
         * @member {number} airUtilTx
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.airUtilTx = 0;

        /**
         * LocalStats numPacketsTx.
         * @member {number} numPacketsTx
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numPacketsTx = 0;

        /**
         * LocalStats numPacketsRx.
         * @member {number} numPacketsRx
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numPacketsRx = 0;

        /**
         * LocalStats numPacketsRxBad.
         * @member {number} numPacketsRxBad
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numPacketsRxBad = 0;

        /**
         * LocalStats numOnlineNodes.
         * @member {number} numOnlineNodes
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numOnlineNodes = 0;

        /**
         * LocalStats numTotalNodes.
         * @member {number} numTotalNodes
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numTotalNodes = 0;

        /**
         * LocalStats numRxDupe.
         * @member {number} numRxDupe
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numRxDupe = 0;

        /**
         * LocalStats numTxRelay.
         * @member {number} numTxRelay
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numTxRelay = 0;

        /**
         * LocalStats numTxRelayCanceled.
         * @member {number} numTxRelayCanceled
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numTxRelayCanceled = 0;

        /**
         * LocalStats heapTotalBytes.
         * @member {number} heapTotalBytes
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.heapTotalBytes = 0;

        /**
         * LocalStats heapFreeBytes.
         * @member {number} heapFreeBytes
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.heapFreeBytes = 0;

        /**
         * LocalStats numTxDropped.
         * @member {number} numTxDropped
         * @memberof meshtastic.LocalStats
         * @instance
         */
        LocalStats.prototype.numTxDropped = 0;

        /**
         * Creates a new LocalStats instance using the specified properties.
         * @function create
         * @memberof meshtastic.LocalStats
         * @static
         * @param {meshtastic.ILocalStats=} [properties] Properties to set
         * @returns {meshtastic.LocalStats} LocalStats instance
         */
        LocalStats.create = function create(properties) {
            return new LocalStats(properties);
        };

        /**
         * Encodes the specified LocalStats message. Does not implicitly {@link meshtastic.LocalStats.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.LocalStats
         * @static
         * @param {meshtastic.ILocalStats} message LocalStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalStats.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uptimeSeconds != null && Object.hasOwnProperty.call(message, "uptimeSeconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uptimeSeconds);
            if (message.channelUtilization != null && Object.hasOwnProperty.call(message, "channelUtilization"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.channelUtilization);
            if (message.airUtilTx != null && Object.hasOwnProperty.call(message, "airUtilTx"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.airUtilTx);
            if (message.numPacketsTx != null && Object.hasOwnProperty.call(message, "numPacketsTx"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numPacketsTx);
            if (message.numPacketsRx != null && Object.hasOwnProperty.call(message, "numPacketsRx"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numPacketsRx);
            if (message.numPacketsRxBad != null && Object.hasOwnProperty.call(message, "numPacketsRxBad"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.numPacketsRxBad);
            if (message.numOnlineNodes != null && Object.hasOwnProperty.call(message, "numOnlineNodes"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.numOnlineNodes);
            if (message.numTotalNodes != null && Object.hasOwnProperty.call(message, "numTotalNodes"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.numTotalNodes);
            if (message.numRxDupe != null && Object.hasOwnProperty.call(message, "numRxDupe"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.numRxDupe);
            if (message.numTxRelay != null && Object.hasOwnProperty.call(message, "numTxRelay"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.numTxRelay);
            if (message.numTxRelayCanceled != null && Object.hasOwnProperty.call(message, "numTxRelayCanceled"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.numTxRelayCanceled);
            if (message.heapTotalBytes != null && Object.hasOwnProperty.call(message, "heapTotalBytes"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.heapTotalBytes);
            if (message.heapFreeBytes != null && Object.hasOwnProperty.call(message, "heapFreeBytes"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.heapFreeBytes);
            if (message.numTxDropped != null && Object.hasOwnProperty.call(message, "numTxDropped"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.numTxDropped);
            return writer;
        };

        /**
         * Encodes the specified LocalStats message, length delimited. Does not implicitly {@link meshtastic.LocalStats.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.LocalStats
         * @static
         * @param {meshtastic.ILocalStats} message LocalStats message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocalStats.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LocalStats message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.LocalStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.LocalStats} LocalStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalStats.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.LocalStats();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.uptimeSeconds = reader.uint32();
                        break;
                    }
                case 2: {
                        message.channelUtilization = reader.float();
                        break;
                    }
                case 3: {
                        message.airUtilTx = reader.float();
                        break;
                    }
                case 4: {
                        message.numPacketsTx = reader.uint32();
                        break;
                    }
                case 5: {
                        message.numPacketsRx = reader.uint32();
                        break;
                    }
                case 6: {
                        message.numPacketsRxBad = reader.uint32();
                        break;
                    }
                case 7: {
                        message.numOnlineNodes = reader.uint32();
                        break;
                    }
                case 8: {
                        message.numTotalNodes = reader.uint32();
                        break;
                    }
                case 9: {
                        message.numRxDupe = reader.uint32();
                        break;
                    }
                case 10: {
                        message.numTxRelay = reader.uint32();
                        break;
                    }
                case 11: {
                        message.numTxRelayCanceled = reader.uint32();
                        break;
                    }
                case 12: {
                        message.heapTotalBytes = reader.uint32();
                        break;
                    }
                case 13: {
                        message.heapFreeBytes = reader.uint32();
                        break;
                    }
                case 14: {
                        message.numTxDropped = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LocalStats message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.LocalStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.LocalStats} LocalStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocalStats.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LocalStats message.
         * @function verify
         * @memberof meshtastic.LocalStats
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocalStats.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds"))
                if (!$util.isInteger(message.uptimeSeconds))
                    return "uptimeSeconds: integer expected";
            if (message.channelUtilization != null && message.hasOwnProperty("channelUtilization"))
                if (typeof message.channelUtilization !== "number")
                    return "channelUtilization: number expected";
            if (message.airUtilTx != null && message.hasOwnProperty("airUtilTx"))
                if (typeof message.airUtilTx !== "number")
                    return "airUtilTx: number expected";
            if (message.numPacketsTx != null && message.hasOwnProperty("numPacketsTx"))
                if (!$util.isInteger(message.numPacketsTx))
                    return "numPacketsTx: integer expected";
            if (message.numPacketsRx != null && message.hasOwnProperty("numPacketsRx"))
                if (!$util.isInteger(message.numPacketsRx))
                    return "numPacketsRx: integer expected";
            if (message.numPacketsRxBad != null && message.hasOwnProperty("numPacketsRxBad"))
                if (!$util.isInteger(message.numPacketsRxBad))
                    return "numPacketsRxBad: integer expected";
            if (message.numOnlineNodes != null && message.hasOwnProperty("numOnlineNodes"))
                if (!$util.isInteger(message.numOnlineNodes))
                    return "numOnlineNodes: integer expected";
            if (message.numTotalNodes != null && message.hasOwnProperty("numTotalNodes"))
                if (!$util.isInteger(message.numTotalNodes))
                    return "numTotalNodes: integer expected";
            if (message.numRxDupe != null && message.hasOwnProperty("numRxDupe"))
                if (!$util.isInteger(message.numRxDupe))
                    return "numRxDupe: integer expected";
            if (message.numTxRelay != null && message.hasOwnProperty("numTxRelay"))
                if (!$util.isInteger(message.numTxRelay))
                    return "numTxRelay: integer expected";
            if (message.numTxRelayCanceled != null && message.hasOwnProperty("numTxRelayCanceled"))
                if (!$util.isInteger(message.numTxRelayCanceled))
                    return "numTxRelayCanceled: integer expected";
            if (message.heapTotalBytes != null && message.hasOwnProperty("heapTotalBytes"))
                if (!$util.isInteger(message.heapTotalBytes))
                    return "heapTotalBytes: integer expected";
            if (message.heapFreeBytes != null && message.hasOwnProperty("heapFreeBytes"))
                if (!$util.isInteger(message.heapFreeBytes))
                    return "heapFreeBytes: integer expected";
            if (message.numTxDropped != null && message.hasOwnProperty("numTxDropped"))
                if (!$util.isInteger(message.numTxDropped))
                    return "numTxDropped: integer expected";
            return null;
        };

        /**
         * Creates a LocalStats message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.LocalStats
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.LocalStats} LocalStats
         */
        LocalStats.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.LocalStats)
                return object;
            var message = new $root.meshtastic.LocalStats();
            if (object.uptimeSeconds != null)
                message.uptimeSeconds = object.uptimeSeconds >>> 0;
            if (object.channelUtilization != null)
                message.channelUtilization = Number(object.channelUtilization);
            if (object.airUtilTx != null)
                message.airUtilTx = Number(object.airUtilTx);
            if (object.numPacketsTx != null)
                message.numPacketsTx = object.numPacketsTx >>> 0;
            if (object.numPacketsRx != null)
                message.numPacketsRx = object.numPacketsRx >>> 0;
            if (object.numPacketsRxBad != null)
                message.numPacketsRxBad = object.numPacketsRxBad >>> 0;
            if (object.numOnlineNodes != null)
                message.numOnlineNodes = object.numOnlineNodes >>> 0;
            if (object.numTotalNodes != null)
                message.numTotalNodes = object.numTotalNodes >>> 0;
            if (object.numRxDupe != null)
                message.numRxDupe = object.numRxDupe >>> 0;
            if (object.numTxRelay != null)
                message.numTxRelay = object.numTxRelay >>> 0;
            if (object.numTxRelayCanceled != null)
                message.numTxRelayCanceled = object.numTxRelayCanceled >>> 0;
            if (object.heapTotalBytes != null)
                message.heapTotalBytes = object.heapTotalBytes >>> 0;
            if (object.heapFreeBytes != null)
                message.heapFreeBytes = object.heapFreeBytes >>> 0;
            if (object.numTxDropped != null)
                message.numTxDropped = object.numTxDropped >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a LocalStats message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.LocalStats
         * @static
         * @param {meshtastic.LocalStats} message LocalStats
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocalStats.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uptimeSeconds = 0;
                object.channelUtilization = 0;
                object.airUtilTx = 0;
                object.numPacketsTx = 0;
                object.numPacketsRx = 0;
                object.numPacketsRxBad = 0;
                object.numOnlineNodes = 0;
                object.numTotalNodes = 0;
                object.numRxDupe = 0;
                object.numTxRelay = 0;
                object.numTxRelayCanceled = 0;
                object.heapTotalBytes = 0;
                object.heapFreeBytes = 0;
                object.numTxDropped = 0;
            }
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds"))
                object.uptimeSeconds = message.uptimeSeconds;
            if (message.channelUtilization != null && message.hasOwnProperty("channelUtilization"))
                object.channelUtilization = options.json && !isFinite(message.channelUtilization) ? String(message.channelUtilization) : message.channelUtilization;
            if (message.airUtilTx != null && message.hasOwnProperty("airUtilTx"))
                object.airUtilTx = options.json && !isFinite(message.airUtilTx) ? String(message.airUtilTx) : message.airUtilTx;
            if (message.numPacketsTx != null && message.hasOwnProperty("numPacketsTx"))
                object.numPacketsTx = message.numPacketsTx;
            if (message.numPacketsRx != null && message.hasOwnProperty("numPacketsRx"))
                object.numPacketsRx = message.numPacketsRx;
            if (message.numPacketsRxBad != null && message.hasOwnProperty("numPacketsRxBad"))
                object.numPacketsRxBad = message.numPacketsRxBad;
            if (message.numOnlineNodes != null && message.hasOwnProperty("numOnlineNodes"))
                object.numOnlineNodes = message.numOnlineNodes;
            if (message.numTotalNodes != null && message.hasOwnProperty("numTotalNodes"))
                object.numTotalNodes = message.numTotalNodes;
            if (message.numRxDupe != null && message.hasOwnProperty("numRxDupe"))
                object.numRxDupe = message.numRxDupe;
            if (message.numTxRelay != null && message.hasOwnProperty("numTxRelay"))
                object.numTxRelay = message.numTxRelay;
            if (message.numTxRelayCanceled != null && message.hasOwnProperty("numTxRelayCanceled"))
                object.numTxRelayCanceled = message.numTxRelayCanceled;
            if (message.heapTotalBytes != null && message.hasOwnProperty("heapTotalBytes"))
                object.heapTotalBytes = message.heapTotalBytes;
            if (message.heapFreeBytes != null && message.hasOwnProperty("heapFreeBytes"))
                object.heapFreeBytes = message.heapFreeBytes;
            if (message.numTxDropped != null && message.hasOwnProperty("numTxDropped"))
                object.numTxDropped = message.numTxDropped;
            return object;
        };

        /**
         * Converts this LocalStats to JSON.
         * @function toJSON
         * @memberof meshtastic.LocalStats
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocalStats.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LocalStats
         * @function getTypeUrl
         * @memberof meshtastic.LocalStats
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LocalStats.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.LocalStats";
        };

        return LocalStats;
    })();

    meshtastic.HealthMetrics = (function() {

        /**
         * Properties of a HealthMetrics.
         * @memberof meshtastic
         * @interface IHealthMetrics
         * @property {number|null} [heartBpm] HealthMetrics heartBpm
         * @property {number|null} [spO2] HealthMetrics spO2
         * @property {number|null} [temperature] HealthMetrics temperature
         */

        /**
         * Constructs a new HealthMetrics.
         * @memberof meshtastic
         * @classdesc Represents a HealthMetrics.
         * @implements IHealthMetrics
         * @constructor
         * @param {meshtastic.IHealthMetrics=} [properties] Properties to set
         */
        function HealthMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HealthMetrics heartBpm.
         * @member {number|null|undefined} heartBpm
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        HealthMetrics.prototype.heartBpm = null;

        /**
         * HealthMetrics spO2.
         * @member {number|null|undefined} spO2
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        HealthMetrics.prototype.spO2 = null;

        /**
         * HealthMetrics temperature.
         * @member {number|null|undefined} temperature
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        HealthMetrics.prototype.temperature = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HealthMetrics _heartBpm.
         * @member {"heartBpm"|undefined} _heartBpm
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        Object.defineProperty(HealthMetrics.prototype, "_heartBpm", {
            get: $util.oneOfGetter($oneOfFields = ["heartBpm"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * HealthMetrics _spO2.
         * @member {"spO2"|undefined} _spO2
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        Object.defineProperty(HealthMetrics.prototype, "_spO2", {
            get: $util.oneOfGetter($oneOfFields = ["spO2"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * HealthMetrics _temperature.
         * @member {"temperature"|undefined} _temperature
         * @memberof meshtastic.HealthMetrics
         * @instance
         */
        Object.defineProperty(HealthMetrics.prototype, "_temperature", {
            get: $util.oneOfGetter($oneOfFields = ["temperature"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HealthMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {meshtastic.IHealthMetrics=} [properties] Properties to set
         * @returns {meshtastic.HealthMetrics} HealthMetrics instance
         */
        HealthMetrics.create = function create(properties) {
            return new HealthMetrics(properties);
        };

        /**
         * Encodes the specified HealthMetrics message. Does not implicitly {@link meshtastic.HealthMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {meshtastic.IHealthMetrics} message HealthMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HealthMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heartBpm != null && Object.hasOwnProperty.call(message, "heartBpm"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.heartBpm);
            if (message.spO2 != null && Object.hasOwnProperty.call(message, "spO2"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.spO2);
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.temperature);
            return writer;
        };

        /**
         * Encodes the specified HealthMetrics message, length delimited. Does not implicitly {@link meshtastic.HealthMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {meshtastic.IHealthMetrics} message HealthMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HealthMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HealthMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.HealthMetrics} HealthMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HealthMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.HealthMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.heartBpm = reader.uint32();
                        break;
                    }
                case 2: {
                        message.spO2 = reader.uint32();
                        break;
                    }
                case 3: {
                        message.temperature = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HealthMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.HealthMetrics} HealthMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HealthMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HealthMetrics message.
         * @function verify
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HealthMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.heartBpm != null && message.hasOwnProperty("heartBpm")) {
                properties._heartBpm = 1;
                if (!$util.isInteger(message.heartBpm))
                    return "heartBpm: integer expected";
            }
            if (message.spO2 != null && message.hasOwnProperty("spO2")) {
                properties._spO2 = 1;
                if (!$util.isInteger(message.spO2))
                    return "spO2: integer expected";
            }
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                properties._temperature = 1;
                if (typeof message.temperature !== "number")
                    return "temperature: number expected";
            }
            return null;
        };

        /**
         * Creates a HealthMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.HealthMetrics} HealthMetrics
         */
        HealthMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.HealthMetrics)
                return object;
            var message = new $root.meshtastic.HealthMetrics();
            if (object.heartBpm != null)
                message.heartBpm = object.heartBpm >>> 0;
            if (object.spO2 != null)
                message.spO2 = object.spO2 >>> 0;
            if (object.temperature != null)
                message.temperature = Number(object.temperature);
            return message;
        };

        /**
         * Creates a plain object from a HealthMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {meshtastic.HealthMetrics} message HealthMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HealthMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.heartBpm != null && message.hasOwnProperty("heartBpm")) {
                object.heartBpm = message.heartBpm;
                if (options.oneofs)
                    object._heartBpm = "heartBpm";
            }
            if (message.spO2 != null && message.hasOwnProperty("spO2")) {
                object.spO2 = message.spO2;
                if (options.oneofs)
                    object._spO2 = "spO2";
            }
            if (message.temperature != null && message.hasOwnProperty("temperature")) {
                object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                if (options.oneofs)
                    object._temperature = "temperature";
            }
            return object;
        };

        /**
         * Converts this HealthMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.HealthMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HealthMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HealthMetrics
         * @function getTypeUrl
         * @memberof meshtastic.HealthMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HealthMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.HealthMetrics";
        };

        return HealthMetrics;
    })();

    meshtastic.HostMetrics = (function() {

        /**
         * Properties of a HostMetrics.
         * @memberof meshtastic
         * @interface IHostMetrics
         * @property {number|null} [uptimeSeconds] HostMetrics uptimeSeconds
         * @property {number|Long|null} [freememBytes] HostMetrics freememBytes
         * @property {number|Long|null} [diskfree1Bytes] HostMetrics diskfree1Bytes
         * @property {number|Long|null} [diskfree2Bytes] HostMetrics diskfree2Bytes
         * @property {number|Long|null} [diskfree3Bytes] HostMetrics diskfree3Bytes
         * @property {number|null} [load1] HostMetrics load1
         * @property {number|null} [load5] HostMetrics load5
         * @property {number|null} [load15] HostMetrics load15
         * @property {string|null} [userString] HostMetrics userString
         */

        /**
         * Constructs a new HostMetrics.
         * @memberof meshtastic
         * @classdesc Represents a HostMetrics.
         * @implements IHostMetrics
         * @constructor
         * @param {meshtastic.IHostMetrics=} [properties] Properties to set
         */
        function HostMetrics(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HostMetrics uptimeSeconds.
         * @member {number} uptimeSeconds
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.uptimeSeconds = 0;

        /**
         * HostMetrics freememBytes.
         * @member {number|Long} freememBytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.freememBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HostMetrics diskfree1Bytes.
         * @member {number|Long} diskfree1Bytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.diskfree1Bytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HostMetrics diskfree2Bytes.
         * @member {number|Long|null|undefined} diskfree2Bytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.diskfree2Bytes = null;

        /**
         * HostMetrics diskfree3Bytes.
         * @member {number|Long|null|undefined} diskfree3Bytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.diskfree3Bytes = null;

        /**
         * HostMetrics load1.
         * @member {number} load1
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.load1 = 0;

        /**
         * HostMetrics load5.
         * @member {number} load5
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.load5 = 0;

        /**
         * HostMetrics load15.
         * @member {number} load15
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.load15 = 0;

        /**
         * HostMetrics userString.
         * @member {string|null|undefined} userString
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        HostMetrics.prototype.userString = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * HostMetrics _diskfree2Bytes.
         * @member {"diskfree2Bytes"|undefined} _diskfree2Bytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        Object.defineProperty(HostMetrics.prototype, "_diskfree2Bytes", {
            get: $util.oneOfGetter($oneOfFields = ["diskfree2Bytes"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * HostMetrics _diskfree3Bytes.
         * @member {"diskfree3Bytes"|undefined} _diskfree3Bytes
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        Object.defineProperty(HostMetrics.prototype, "_diskfree3Bytes", {
            get: $util.oneOfGetter($oneOfFields = ["diskfree3Bytes"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * HostMetrics _userString.
         * @member {"userString"|undefined} _userString
         * @memberof meshtastic.HostMetrics
         * @instance
         */
        Object.defineProperty(HostMetrics.prototype, "_userString", {
            get: $util.oneOfGetter($oneOfFields = ["userString"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new HostMetrics instance using the specified properties.
         * @function create
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {meshtastic.IHostMetrics=} [properties] Properties to set
         * @returns {meshtastic.HostMetrics} HostMetrics instance
         */
        HostMetrics.create = function create(properties) {
            return new HostMetrics(properties);
        };

        /**
         * Encodes the specified HostMetrics message. Does not implicitly {@link meshtastic.HostMetrics.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {meshtastic.IHostMetrics} message HostMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HostMetrics.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uptimeSeconds != null && Object.hasOwnProperty.call(message, "uptimeSeconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uptimeSeconds);
            if (message.freememBytes != null && Object.hasOwnProperty.call(message, "freememBytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.freememBytes);
            if (message.diskfree1Bytes != null && Object.hasOwnProperty.call(message, "diskfree1Bytes"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.diskfree1Bytes);
            if (message.diskfree2Bytes != null && Object.hasOwnProperty.call(message, "diskfree2Bytes"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.diskfree2Bytes);
            if (message.diskfree3Bytes != null && Object.hasOwnProperty.call(message, "diskfree3Bytes"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.diskfree3Bytes);
            if (message.load1 != null && Object.hasOwnProperty.call(message, "load1"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.load1);
            if (message.load5 != null && Object.hasOwnProperty.call(message, "load5"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.load5);
            if (message.load15 != null && Object.hasOwnProperty.call(message, "load15"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.load15);
            if (message.userString != null && Object.hasOwnProperty.call(message, "userString"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.userString);
            return writer;
        };

        /**
         * Encodes the specified HostMetrics message, length delimited. Does not implicitly {@link meshtastic.HostMetrics.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {meshtastic.IHostMetrics} message HostMetrics message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HostMetrics.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HostMetrics message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.HostMetrics} HostMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HostMetrics.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.HostMetrics();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.uptimeSeconds = reader.uint32();
                        break;
                    }
                case 2: {
                        message.freememBytes = reader.uint64();
                        break;
                    }
                case 3: {
                        message.diskfree1Bytes = reader.uint64();
                        break;
                    }
                case 4: {
                        message.diskfree2Bytes = reader.uint64();
                        break;
                    }
                case 5: {
                        message.diskfree3Bytes = reader.uint64();
                        break;
                    }
                case 6: {
                        message.load1 = reader.uint32();
                        break;
                    }
                case 7: {
                        message.load5 = reader.uint32();
                        break;
                    }
                case 8: {
                        message.load15 = reader.uint32();
                        break;
                    }
                case 9: {
                        message.userString = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HostMetrics message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.HostMetrics} HostMetrics
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HostMetrics.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HostMetrics message.
         * @function verify
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HostMetrics.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds"))
                if (!$util.isInteger(message.uptimeSeconds))
                    return "uptimeSeconds: integer expected";
            if (message.freememBytes != null && message.hasOwnProperty("freememBytes"))
                if (!$util.isInteger(message.freememBytes) && !(message.freememBytes && $util.isInteger(message.freememBytes.low) && $util.isInteger(message.freememBytes.high)))
                    return "freememBytes: integer|Long expected";
            if (message.diskfree1Bytes != null && message.hasOwnProperty("diskfree1Bytes"))
                if (!$util.isInteger(message.diskfree1Bytes) && !(message.diskfree1Bytes && $util.isInteger(message.diskfree1Bytes.low) && $util.isInteger(message.diskfree1Bytes.high)))
                    return "diskfree1Bytes: integer|Long expected";
            if (message.diskfree2Bytes != null && message.hasOwnProperty("diskfree2Bytes")) {
                properties._diskfree2Bytes = 1;
                if (!$util.isInteger(message.diskfree2Bytes) && !(message.diskfree2Bytes && $util.isInteger(message.diskfree2Bytes.low) && $util.isInteger(message.diskfree2Bytes.high)))
                    return "diskfree2Bytes: integer|Long expected";
            }
            if (message.diskfree3Bytes != null && message.hasOwnProperty("diskfree3Bytes")) {
                properties._diskfree3Bytes = 1;
                if (!$util.isInteger(message.diskfree3Bytes) && !(message.diskfree3Bytes && $util.isInteger(message.diskfree3Bytes.low) && $util.isInteger(message.diskfree3Bytes.high)))
                    return "diskfree3Bytes: integer|Long expected";
            }
            if (message.load1 != null && message.hasOwnProperty("load1"))
                if (!$util.isInteger(message.load1))
                    return "load1: integer expected";
            if (message.load5 != null && message.hasOwnProperty("load5"))
                if (!$util.isInteger(message.load5))
                    return "load5: integer expected";
            if (message.load15 != null && message.hasOwnProperty("load15"))
                if (!$util.isInteger(message.load15))
                    return "load15: integer expected";
            if (message.userString != null && message.hasOwnProperty("userString")) {
                properties._userString = 1;
                if (!$util.isString(message.userString))
                    return "userString: string expected";
            }
            return null;
        };

        /**
         * Creates a HostMetrics message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.HostMetrics} HostMetrics
         */
        HostMetrics.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.HostMetrics)
                return object;
            var message = new $root.meshtastic.HostMetrics();
            if (object.uptimeSeconds != null)
                message.uptimeSeconds = object.uptimeSeconds >>> 0;
            if (object.freememBytes != null)
                if ($util.Long)
                    (message.freememBytes = $util.Long.fromValue(object.freememBytes)).unsigned = true;
                else if (typeof object.freememBytes === "string")
                    message.freememBytes = parseInt(object.freememBytes, 10);
                else if (typeof object.freememBytes === "number")
                    message.freememBytes = object.freememBytes;
                else if (typeof object.freememBytes === "object")
                    message.freememBytes = new $util.LongBits(object.freememBytes.low >>> 0, object.freememBytes.high >>> 0).toNumber(true);
            if (object.diskfree1Bytes != null)
                if ($util.Long)
                    (message.diskfree1Bytes = $util.Long.fromValue(object.diskfree1Bytes)).unsigned = true;
                else if (typeof object.diskfree1Bytes === "string")
                    message.diskfree1Bytes = parseInt(object.diskfree1Bytes, 10);
                else if (typeof object.diskfree1Bytes === "number")
                    message.diskfree1Bytes = object.diskfree1Bytes;
                else if (typeof object.diskfree1Bytes === "object")
                    message.diskfree1Bytes = new $util.LongBits(object.diskfree1Bytes.low >>> 0, object.diskfree1Bytes.high >>> 0).toNumber(true);
            if (object.diskfree2Bytes != null)
                if ($util.Long)
                    (message.diskfree2Bytes = $util.Long.fromValue(object.diskfree2Bytes)).unsigned = true;
                else if (typeof object.diskfree2Bytes === "string")
                    message.diskfree2Bytes = parseInt(object.diskfree2Bytes, 10);
                else if (typeof object.diskfree2Bytes === "number")
                    message.diskfree2Bytes = object.diskfree2Bytes;
                else if (typeof object.diskfree2Bytes === "object")
                    message.diskfree2Bytes = new $util.LongBits(object.diskfree2Bytes.low >>> 0, object.diskfree2Bytes.high >>> 0).toNumber(true);
            if (object.diskfree3Bytes != null)
                if ($util.Long)
                    (message.diskfree3Bytes = $util.Long.fromValue(object.diskfree3Bytes)).unsigned = true;
                else if (typeof object.diskfree3Bytes === "string")
                    message.diskfree3Bytes = parseInt(object.diskfree3Bytes, 10);
                else if (typeof object.diskfree3Bytes === "number")
                    message.diskfree3Bytes = object.diskfree3Bytes;
                else if (typeof object.diskfree3Bytes === "object")
                    message.diskfree3Bytes = new $util.LongBits(object.diskfree3Bytes.low >>> 0, object.diskfree3Bytes.high >>> 0).toNumber(true);
            if (object.load1 != null)
                message.load1 = object.load1 >>> 0;
            if (object.load5 != null)
                message.load5 = object.load5 >>> 0;
            if (object.load15 != null)
                message.load15 = object.load15 >>> 0;
            if (object.userString != null)
                message.userString = String(object.userString);
            return message;
        };

        /**
         * Creates a plain object from a HostMetrics message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {meshtastic.HostMetrics} message HostMetrics
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HostMetrics.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uptimeSeconds = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.freememBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.freememBytes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.diskfree1Bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.diskfree1Bytes = options.longs === String ? "0" : 0;
                object.load1 = 0;
                object.load5 = 0;
                object.load15 = 0;
            }
            if (message.uptimeSeconds != null && message.hasOwnProperty("uptimeSeconds"))
                object.uptimeSeconds = message.uptimeSeconds;
            if (message.freememBytes != null && message.hasOwnProperty("freememBytes"))
                if (typeof message.freememBytes === "number")
                    object.freememBytes = options.longs === String ? String(message.freememBytes) : message.freememBytes;
                else
                    object.freememBytes = options.longs === String ? $util.Long.prototype.toString.call(message.freememBytes) : options.longs === Number ? new $util.LongBits(message.freememBytes.low >>> 0, message.freememBytes.high >>> 0).toNumber(true) : message.freememBytes;
            if (message.diskfree1Bytes != null && message.hasOwnProperty("diskfree1Bytes"))
                if (typeof message.diskfree1Bytes === "number")
                    object.diskfree1Bytes = options.longs === String ? String(message.diskfree1Bytes) : message.diskfree1Bytes;
                else
                    object.diskfree1Bytes = options.longs === String ? $util.Long.prototype.toString.call(message.diskfree1Bytes) : options.longs === Number ? new $util.LongBits(message.diskfree1Bytes.low >>> 0, message.diskfree1Bytes.high >>> 0).toNumber(true) : message.diskfree1Bytes;
            if (message.diskfree2Bytes != null && message.hasOwnProperty("diskfree2Bytes")) {
                if (typeof message.diskfree2Bytes === "number")
                    object.diskfree2Bytes = options.longs === String ? String(message.diskfree2Bytes) : message.diskfree2Bytes;
                else
                    object.diskfree2Bytes = options.longs === String ? $util.Long.prototype.toString.call(message.diskfree2Bytes) : options.longs === Number ? new $util.LongBits(message.diskfree2Bytes.low >>> 0, message.diskfree2Bytes.high >>> 0).toNumber(true) : message.diskfree2Bytes;
                if (options.oneofs)
                    object._diskfree2Bytes = "diskfree2Bytes";
            }
            if (message.diskfree3Bytes != null && message.hasOwnProperty("diskfree3Bytes")) {
                if (typeof message.diskfree3Bytes === "number")
                    object.diskfree3Bytes = options.longs === String ? String(message.diskfree3Bytes) : message.diskfree3Bytes;
                else
                    object.diskfree3Bytes = options.longs === String ? $util.Long.prototype.toString.call(message.diskfree3Bytes) : options.longs === Number ? new $util.LongBits(message.diskfree3Bytes.low >>> 0, message.diskfree3Bytes.high >>> 0).toNumber(true) : message.diskfree3Bytes;
                if (options.oneofs)
                    object._diskfree3Bytes = "diskfree3Bytes";
            }
            if (message.load1 != null && message.hasOwnProperty("load1"))
                object.load1 = message.load1;
            if (message.load5 != null && message.hasOwnProperty("load5"))
                object.load5 = message.load5;
            if (message.load15 != null && message.hasOwnProperty("load15"))
                object.load15 = message.load15;
            if (message.userString != null && message.hasOwnProperty("userString")) {
                object.userString = message.userString;
                if (options.oneofs)
                    object._userString = "userString";
            }
            return object;
        };

        /**
         * Converts this HostMetrics to JSON.
         * @function toJSON
         * @memberof meshtastic.HostMetrics
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HostMetrics.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for HostMetrics
         * @function getTypeUrl
         * @memberof meshtastic.HostMetrics
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        HostMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.HostMetrics";
        };

        return HostMetrics;
    })();

    meshtastic.Telemetry = (function() {

        /**
         * Properties of a Telemetry.
         * @memberof meshtastic
         * @interface ITelemetry
         * @property {number|null} [time] Telemetry time
         * @property {meshtastic.IDeviceMetrics|null} [deviceMetrics] Telemetry deviceMetrics
         * @property {meshtastic.IEnvironmentMetrics|null} [environmentMetrics] Telemetry environmentMetrics
         * @property {meshtastic.IAirQualityMetrics|null} [airQualityMetrics] Telemetry airQualityMetrics
         * @property {meshtastic.IPowerMetrics|null} [powerMetrics] Telemetry powerMetrics
         * @property {meshtastic.ILocalStats|null} [localStats] Telemetry localStats
         * @property {meshtastic.IHealthMetrics|null} [healthMetrics] Telemetry healthMetrics
         * @property {meshtastic.IHostMetrics|null} [hostMetrics] Telemetry hostMetrics
         */

        /**
         * Constructs a new Telemetry.
         * @memberof meshtastic
         * @classdesc Represents a Telemetry.
         * @implements ITelemetry
         * @constructor
         * @param {meshtastic.ITelemetry=} [properties] Properties to set
         */
        function Telemetry(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Telemetry time.
         * @member {number} time
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.time = 0;

        /**
         * Telemetry deviceMetrics.
         * @member {meshtastic.IDeviceMetrics|null|undefined} deviceMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.deviceMetrics = null;

        /**
         * Telemetry environmentMetrics.
         * @member {meshtastic.IEnvironmentMetrics|null|undefined} environmentMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.environmentMetrics = null;

        /**
         * Telemetry airQualityMetrics.
         * @member {meshtastic.IAirQualityMetrics|null|undefined} airQualityMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.airQualityMetrics = null;

        /**
         * Telemetry powerMetrics.
         * @member {meshtastic.IPowerMetrics|null|undefined} powerMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.powerMetrics = null;

        /**
         * Telemetry localStats.
         * @member {meshtastic.ILocalStats|null|undefined} localStats
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.localStats = null;

        /**
         * Telemetry healthMetrics.
         * @member {meshtastic.IHealthMetrics|null|undefined} healthMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.healthMetrics = null;

        /**
         * Telemetry hostMetrics.
         * @member {meshtastic.IHostMetrics|null|undefined} hostMetrics
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Telemetry.prototype.hostMetrics = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Telemetry variant.
         * @member {"deviceMetrics"|"environmentMetrics"|"airQualityMetrics"|"powerMetrics"|"localStats"|"healthMetrics"|"hostMetrics"|undefined} variant
         * @memberof meshtastic.Telemetry
         * @instance
         */
        Object.defineProperty(Telemetry.prototype, "variant", {
            get: $util.oneOfGetter($oneOfFields = ["deviceMetrics", "environmentMetrics", "airQualityMetrics", "powerMetrics", "localStats", "healthMetrics", "hostMetrics"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Telemetry instance using the specified properties.
         * @function create
         * @memberof meshtastic.Telemetry
         * @static
         * @param {meshtastic.ITelemetry=} [properties] Properties to set
         * @returns {meshtastic.Telemetry} Telemetry instance
         */
        Telemetry.create = function create(properties) {
            return new Telemetry(properties);
        };

        /**
         * Encodes the specified Telemetry message. Does not implicitly {@link meshtastic.Telemetry.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Telemetry
         * @static
         * @param {meshtastic.ITelemetry} message Telemetry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Telemetry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.time);
            if (message.deviceMetrics != null && Object.hasOwnProperty.call(message, "deviceMetrics"))
                $root.meshtastic.DeviceMetrics.encode(message.deviceMetrics, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.environmentMetrics != null && Object.hasOwnProperty.call(message, "environmentMetrics"))
                $root.meshtastic.EnvironmentMetrics.encode(message.environmentMetrics, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.airQualityMetrics != null && Object.hasOwnProperty.call(message, "airQualityMetrics"))
                $root.meshtastic.AirQualityMetrics.encode(message.airQualityMetrics, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.powerMetrics != null && Object.hasOwnProperty.call(message, "powerMetrics"))
                $root.meshtastic.PowerMetrics.encode(message.powerMetrics, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.localStats != null && Object.hasOwnProperty.call(message, "localStats"))
                $root.meshtastic.LocalStats.encode(message.localStats, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.healthMetrics != null && Object.hasOwnProperty.call(message, "healthMetrics"))
                $root.meshtastic.HealthMetrics.encode(message.healthMetrics, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.hostMetrics != null && Object.hasOwnProperty.call(message, "hostMetrics"))
                $root.meshtastic.HostMetrics.encode(message.hostMetrics, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Telemetry message, length delimited. Does not implicitly {@link meshtastic.Telemetry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Telemetry
         * @static
         * @param {meshtastic.ITelemetry} message Telemetry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Telemetry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Telemetry message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Telemetry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Telemetry} Telemetry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Telemetry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Telemetry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.fixed32();
                        break;
                    }
                case 2: {
                        message.deviceMetrics = $root.meshtastic.DeviceMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.environmentMetrics = $root.meshtastic.EnvironmentMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.airQualityMetrics = $root.meshtastic.AirQualityMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.powerMetrics = $root.meshtastic.PowerMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.localStats = $root.meshtastic.LocalStats.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.healthMetrics = $root.meshtastic.HealthMetrics.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.hostMetrics = $root.meshtastic.HostMetrics.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Telemetry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Telemetry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Telemetry} Telemetry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Telemetry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Telemetry message.
         * @function verify
         * @memberof meshtastic.Telemetry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Telemetry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.deviceMetrics != null && message.hasOwnProperty("deviceMetrics")) {
                properties.variant = 1;
                {
                    var error = $root.meshtastic.DeviceMetrics.verify(message.deviceMetrics);
                    if (error)
                        return "deviceMetrics." + error;
                }
            }
            if (message.environmentMetrics != null && message.hasOwnProperty("environmentMetrics")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.EnvironmentMetrics.verify(message.environmentMetrics);
                    if (error)
                        return "environmentMetrics." + error;
                }
            }
            if (message.airQualityMetrics != null && message.hasOwnProperty("airQualityMetrics")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.AirQualityMetrics.verify(message.airQualityMetrics);
                    if (error)
                        return "airQualityMetrics." + error;
                }
            }
            if (message.powerMetrics != null && message.hasOwnProperty("powerMetrics")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.PowerMetrics.verify(message.powerMetrics);
                    if (error)
                        return "powerMetrics." + error;
                }
            }
            if (message.localStats != null && message.hasOwnProperty("localStats")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.LocalStats.verify(message.localStats);
                    if (error)
                        return "localStats." + error;
                }
            }
            if (message.healthMetrics != null && message.hasOwnProperty("healthMetrics")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.HealthMetrics.verify(message.healthMetrics);
                    if (error)
                        return "healthMetrics." + error;
                }
            }
            if (message.hostMetrics != null && message.hasOwnProperty("hostMetrics")) {
                if (properties.variant === 1)
                    return "variant: multiple values";
                properties.variant = 1;
                {
                    var error = $root.meshtastic.HostMetrics.verify(message.hostMetrics);
                    if (error)
                        return "hostMetrics." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Telemetry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Telemetry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Telemetry} Telemetry
         */
        Telemetry.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Telemetry)
                return object;
            var message = new $root.meshtastic.Telemetry();
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.deviceMetrics != null) {
                if (typeof object.deviceMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.deviceMetrics: object expected");
                message.deviceMetrics = $root.meshtastic.DeviceMetrics.fromObject(object.deviceMetrics);
            }
            if (object.environmentMetrics != null) {
                if (typeof object.environmentMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.environmentMetrics: object expected");
                message.environmentMetrics = $root.meshtastic.EnvironmentMetrics.fromObject(object.environmentMetrics);
            }
            if (object.airQualityMetrics != null) {
                if (typeof object.airQualityMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.airQualityMetrics: object expected");
                message.airQualityMetrics = $root.meshtastic.AirQualityMetrics.fromObject(object.airQualityMetrics);
            }
            if (object.powerMetrics != null) {
                if (typeof object.powerMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.powerMetrics: object expected");
                message.powerMetrics = $root.meshtastic.PowerMetrics.fromObject(object.powerMetrics);
            }
            if (object.localStats != null) {
                if (typeof object.localStats !== "object")
                    throw TypeError(".meshtastic.Telemetry.localStats: object expected");
                message.localStats = $root.meshtastic.LocalStats.fromObject(object.localStats);
            }
            if (object.healthMetrics != null) {
                if (typeof object.healthMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.healthMetrics: object expected");
                message.healthMetrics = $root.meshtastic.HealthMetrics.fromObject(object.healthMetrics);
            }
            if (object.hostMetrics != null) {
                if (typeof object.hostMetrics !== "object")
                    throw TypeError(".meshtastic.Telemetry.hostMetrics: object expected");
                message.hostMetrics = $root.meshtastic.HostMetrics.fromObject(object.hostMetrics);
            }
            return message;
        };

        /**
         * Creates a plain object from a Telemetry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Telemetry
         * @static
         * @param {meshtastic.Telemetry} message Telemetry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Telemetry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.time = 0;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.deviceMetrics != null && message.hasOwnProperty("deviceMetrics")) {
                object.deviceMetrics = $root.meshtastic.DeviceMetrics.toObject(message.deviceMetrics, options);
                if (options.oneofs)
                    object.variant = "deviceMetrics";
            }
            if (message.environmentMetrics != null && message.hasOwnProperty("environmentMetrics")) {
                object.environmentMetrics = $root.meshtastic.EnvironmentMetrics.toObject(message.environmentMetrics, options);
                if (options.oneofs)
                    object.variant = "environmentMetrics";
            }
            if (message.airQualityMetrics != null && message.hasOwnProperty("airQualityMetrics")) {
                object.airQualityMetrics = $root.meshtastic.AirQualityMetrics.toObject(message.airQualityMetrics, options);
                if (options.oneofs)
                    object.variant = "airQualityMetrics";
            }
            if (message.powerMetrics != null && message.hasOwnProperty("powerMetrics")) {
                object.powerMetrics = $root.meshtastic.PowerMetrics.toObject(message.powerMetrics, options);
                if (options.oneofs)
                    object.variant = "powerMetrics";
            }
            if (message.localStats != null && message.hasOwnProperty("localStats")) {
                object.localStats = $root.meshtastic.LocalStats.toObject(message.localStats, options);
                if (options.oneofs)
                    object.variant = "localStats";
            }
            if (message.healthMetrics != null && message.hasOwnProperty("healthMetrics")) {
                object.healthMetrics = $root.meshtastic.HealthMetrics.toObject(message.healthMetrics, options);
                if (options.oneofs)
                    object.variant = "healthMetrics";
            }
            if (message.hostMetrics != null && message.hasOwnProperty("hostMetrics")) {
                object.hostMetrics = $root.meshtastic.HostMetrics.toObject(message.hostMetrics, options);
                if (options.oneofs)
                    object.variant = "hostMetrics";
            }
            return object;
        };

        /**
         * Converts this Telemetry to JSON.
         * @function toJSON
         * @memberof meshtastic.Telemetry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Telemetry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Telemetry
         * @function getTypeUrl
         * @memberof meshtastic.Telemetry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Telemetry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Telemetry";
        };

        return Telemetry;
    })();

    /**
     * TelemetrySensorType enum.
     * @name meshtastic.TelemetrySensorType
     * @enum {number}
     * @property {number} SENSOR_UNSET=0 SENSOR_UNSET value
     * @property {number} BME280=1 BME280 value
     * @property {number} BME680=2 BME680 value
     * @property {number} MCP9808=3 MCP9808 value
     * @property {number} INA260=4 INA260 value
     * @property {number} INA219=5 INA219 value
     * @property {number} BMP280=6 BMP280 value
     * @property {number} SHTC3=7 SHTC3 value
     * @property {number} LPS22=8 LPS22 value
     * @property {number} QMC6310=9 QMC6310 value
     * @property {number} QMI8658=10 QMI8658 value
     * @property {number} QMC5883L=11 QMC5883L value
     * @property {number} SHT31=12 SHT31 value
     * @property {number} PMSA003I=13 PMSA003I value
     * @property {number} INA3221=14 INA3221 value
     * @property {number} BMP085=15 BMP085 value
     * @property {number} RCWL9620=16 RCWL9620 value
     * @property {number} SHT4X=17 SHT4X value
     * @property {number} VEML7700=18 VEML7700 value
     * @property {number} MLX90632=19 MLX90632 value
     * @property {number} OPT3001=20 OPT3001 value
     * @property {number} LTR390UV=21 LTR390UV value
     * @property {number} TSL25911FN=22 TSL25911FN value
     * @property {number} AHT10=23 AHT10 value
     * @property {number} DFROBOT_LARK=24 DFROBOT_LARK value
     * @property {number} NAU7802=25 NAU7802 value
     * @property {number} BMP3XX=26 BMP3XX value
     * @property {number} ICM20948=27 ICM20948 value
     * @property {number} MAX17048=28 MAX17048 value
     * @property {number} CUSTOM_SENSOR=29 CUSTOM_SENSOR value
     * @property {number} MAX30102=30 MAX30102 value
     * @property {number} MLX90614=31 MLX90614 value
     * @property {number} SCD4X=32 SCD4X value
     * @property {number} RADSENS=33 RADSENS value
     * @property {number} INA226=34 INA226 value
     * @property {number} DFROBOT_RAIN=35 DFROBOT_RAIN value
     * @property {number} DPS310=36 DPS310 value
     * @property {number} RAK12035=37 RAK12035 value
     * @property {number} MAX17261=38 MAX17261 value
     * @property {number} PCT2075=39 PCT2075 value
     * @property {number} ADS1X15=40 ADS1X15 value
     * @property {number} ADS1X15_ALT=41 ADS1X15_ALT value
     * @property {number} SFA30=42 SFA30 value
     * @property {number} SEN5X=43 SEN5X value
     * @property {number} TSL2561=44 TSL2561 value
     * @property {number} BH1750=45 BH1750 value
     */
    meshtastic.TelemetrySensorType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SENSOR_UNSET"] = 0;
        values[valuesById[1] = "BME280"] = 1;
        values[valuesById[2] = "BME680"] = 2;
        values[valuesById[3] = "MCP9808"] = 3;
        values[valuesById[4] = "INA260"] = 4;
        values[valuesById[5] = "INA219"] = 5;
        values[valuesById[6] = "BMP280"] = 6;
        values[valuesById[7] = "SHTC3"] = 7;
        values[valuesById[8] = "LPS22"] = 8;
        values[valuesById[9] = "QMC6310"] = 9;
        values[valuesById[10] = "QMI8658"] = 10;
        values[valuesById[11] = "QMC5883L"] = 11;
        values[valuesById[12] = "SHT31"] = 12;
        values[valuesById[13] = "PMSA003I"] = 13;
        values[valuesById[14] = "INA3221"] = 14;
        values[valuesById[15] = "BMP085"] = 15;
        values[valuesById[16] = "RCWL9620"] = 16;
        values[valuesById[17] = "SHT4X"] = 17;
        values[valuesById[18] = "VEML7700"] = 18;
        values[valuesById[19] = "MLX90632"] = 19;
        values[valuesById[20] = "OPT3001"] = 20;
        values[valuesById[21] = "LTR390UV"] = 21;
        values[valuesById[22] = "TSL25911FN"] = 22;
        values[valuesById[23] = "AHT10"] = 23;
        values[valuesById[24] = "DFROBOT_LARK"] = 24;
        values[valuesById[25] = "NAU7802"] = 25;
        values[valuesById[26] = "BMP3XX"] = 26;
        values[valuesById[27] = "ICM20948"] = 27;
        values[valuesById[28] = "MAX17048"] = 28;
        values[valuesById[29] = "CUSTOM_SENSOR"] = 29;
        values[valuesById[30] = "MAX30102"] = 30;
        values[valuesById[31] = "MLX90614"] = 31;
        values[valuesById[32] = "SCD4X"] = 32;
        values[valuesById[33] = "RADSENS"] = 33;
        values[valuesById[34] = "INA226"] = 34;
        values[valuesById[35] = "DFROBOT_RAIN"] = 35;
        values[valuesById[36] = "DPS310"] = 36;
        values[valuesById[37] = "RAK12035"] = 37;
        values[valuesById[38] = "MAX17261"] = 38;
        values[valuesById[39] = "PCT2075"] = 39;
        values[valuesById[40] = "ADS1X15"] = 40;
        values[valuesById[41] = "ADS1X15_ALT"] = 41;
        values[valuesById[42] = "SFA30"] = 42;
        values[valuesById[43] = "SEN5X"] = 43;
        values[valuesById[44] = "TSL2561"] = 44;
        values[valuesById[45] = "BH1750"] = 45;
        return values;
    })();

    meshtastic.Nau7802Config = (function() {

        /**
         * Properties of a Nau7802Config.
         * @memberof meshtastic
         * @interface INau7802Config
         * @property {number|null} [zeroOffset] Nau7802Config zeroOffset
         * @property {number|null} [calibrationFactor] Nau7802Config calibrationFactor
         */

        /**
         * Constructs a new Nau7802Config.
         * @memberof meshtastic
         * @classdesc Represents a Nau7802Config.
         * @implements INau7802Config
         * @constructor
         * @param {meshtastic.INau7802Config=} [properties] Properties to set
         */
        function Nau7802Config(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Nau7802Config zeroOffset.
         * @member {number} zeroOffset
         * @memberof meshtastic.Nau7802Config
         * @instance
         */
        Nau7802Config.prototype.zeroOffset = 0;

        /**
         * Nau7802Config calibrationFactor.
         * @member {number} calibrationFactor
         * @memberof meshtastic.Nau7802Config
         * @instance
         */
        Nau7802Config.prototype.calibrationFactor = 0;

        /**
         * Creates a new Nau7802Config instance using the specified properties.
         * @function create
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {meshtastic.INau7802Config=} [properties] Properties to set
         * @returns {meshtastic.Nau7802Config} Nau7802Config instance
         */
        Nau7802Config.create = function create(properties) {
            return new Nau7802Config(properties);
        };

        /**
         * Encodes the specified Nau7802Config message. Does not implicitly {@link meshtastic.Nau7802Config.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {meshtastic.INau7802Config} message Nau7802Config message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nau7802Config.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.zeroOffset != null && Object.hasOwnProperty.call(message, "zeroOffset"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.zeroOffset);
            if (message.calibrationFactor != null && Object.hasOwnProperty.call(message, "calibrationFactor"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.calibrationFactor);
            return writer;
        };

        /**
         * Encodes the specified Nau7802Config message, length delimited. Does not implicitly {@link meshtastic.Nau7802Config.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {meshtastic.INau7802Config} message Nau7802Config message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Nau7802Config.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Nau7802Config message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.Nau7802Config} Nau7802Config
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nau7802Config.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.Nau7802Config();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.zeroOffset = reader.int32();
                        break;
                    }
                case 2: {
                        message.calibrationFactor = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Nau7802Config message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.Nau7802Config} Nau7802Config
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Nau7802Config.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Nau7802Config message.
         * @function verify
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Nau7802Config.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.zeroOffset != null && message.hasOwnProperty("zeroOffset"))
                if (!$util.isInteger(message.zeroOffset))
                    return "zeroOffset: integer expected";
            if (message.calibrationFactor != null && message.hasOwnProperty("calibrationFactor"))
                if (typeof message.calibrationFactor !== "number")
                    return "calibrationFactor: number expected";
            return null;
        };

        /**
         * Creates a Nau7802Config message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.Nau7802Config} Nau7802Config
         */
        Nau7802Config.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.Nau7802Config)
                return object;
            var message = new $root.meshtastic.Nau7802Config();
            if (object.zeroOffset != null)
                message.zeroOffset = object.zeroOffset | 0;
            if (object.calibrationFactor != null)
                message.calibrationFactor = Number(object.calibrationFactor);
            return message;
        };

        /**
         * Creates a plain object from a Nau7802Config message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {meshtastic.Nau7802Config} message Nau7802Config
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Nau7802Config.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.zeroOffset = 0;
                object.calibrationFactor = 0;
            }
            if (message.zeroOffset != null && message.hasOwnProperty("zeroOffset"))
                object.zeroOffset = message.zeroOffset;
            if (message.calibrationFactor != null && message.hasOwnProperty("calibrationFactor"))
                object.calibrationFactor = options.json && !isFinite(message.calibrationFactor) ? String(message.calibrationFactor) : message.calibrationFactor;
            return object;
        };

        /**
         * Converts this Nau7802Config to JSON.
         * @function toJSON
         * @memberof meshtastic.Nau7802Config
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Nau7802Config.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Nau7802Config
         * @function getTypeUrl
         * @memberof meshtastic.Nau7802Config
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Nau7802Config.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.Nau7802Config";
        };

        return Nau7802Config;
    })();

    meshtastic.XModem = (function() {

        /**
         * Properties of a XModem.
         * @memberof meshtastic
         * @interface IXModem
         * @property {meshtastic.XModem.Control|null} [control] XModem control
         * @property {number|null} [seq] XModem seq
         * @property {number|null} [crc16] XModem crc16
         * @property {Uint8Array|null} [buffer] XModem buffer
         */

        /**
         * Constructs a new XModem.
         * @memberof meshtastic
         * @classdesc Represents a XModem.
         * @implements IXModem
         * @constructor
         * @param {meshtastic.IXModem=} [properties] Properties to set
         */
        function XModem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * XModem control.
         * @member {meshtastic.XModem.Control} control
         * @memberof meshtastic.XModem
         * @instance
         */
        XModem.prototype.control = 0;

        /**
         * XModem seq.
         * @member {number} seq
         * @memberof meshtastic.XModem
         * @instance
         */
        XModem.prototype.seq = 0;

        /**
         * XModem crc16.
         * @member {number} crc16
         * @memberof meshtastic.XModem
         * @instance
         */
        XModem.prototype.crc16 = 0;

        /**
         * XModem buffer.
         * @member {Uint8Array} buffer
         * @memberof meshtastic.XModem
         * @instance
         */
        XModem.prototype.buffer = $util.newBuffer([]);

        /**
         * Creates a new XModem instance using the specified properties.
         * @function create
         * @memberof meshtastic.XModem
         * @static
         * @param {meshtastic.IXModem=} [properties] Properties to set
         * @returns {meshtastic.XModem} XModem instance
         */
        XModem.create = function create(properties) {
            return new XModem(properties);
        };

        /**
         * Encodes the specified XModem message. Does not implicitly {@link meshtastic.XModem.verify|verify} messages.
         * @function encode
         * @memberof meshtastic.XModem
         * @static
         * @param {meshtastic.IXModem} message XModem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        XModem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.control != null && Object.hasOwnProperty.call(message, "control"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.control);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
            if (message.crc16 != null && Object.hasOwnProperty.call(message, "crc16"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.crc16);
            if (message.buffer != null && Object.hasOwnProperty.call(message, "buffer"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.buffer);
            return writer;
        };

        /**
         * Encodes the specified XModem message, length delimited. Does not implicitly {@link meshtastic.XModem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof meshtastic.XModem
         * @static
         * @param {meshtastic.IXModem} message XModem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        XModem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a XModem message from the specified reader or buffer.
         * @function decode
         * @memberof meshtastic.XModem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {meshtastic.XModem} XModem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        XModem.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.meshtastic.XModem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.control = reader.int32();
                        break;
                    }
                case 2: {
                        message.seq = reader.uint32();
                        break;
                    }
                case 3: {
                        message.crc16 = reader.uint32();
                        break;
                    }
                case 4: {
                        message.buffer = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a XModem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof meshtastic.XModem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {meshtastic.XModem} XModem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        XModem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a XModem message.
         * @function verify
         * @memberof meshtastic.XModem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        XModem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.control != null && message.hasOwnProperty("control"))
                switch (message.control) {
                default:
                    return "control: enum value expected";
                case 0:
                case 1:
                case 2:
                case 4:
                case 6:
                case 21:
                case 24:
                case 26:
                    break;
                }
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.crc16 != null && message.hasOwnProperty("crc16"))
                if (!$util.isInteger(message.crc16))
                    return "crc16: integer expected";
            if (message.buffer != null && message.hasOwnProperty("buffer"))
                if (!(message.buffer && typeof message.buffer.length === "number" || $util.isString(message.buffer)))
                    return "buffer: buffer expected";
            return null;
        };

        /**
         * Creates a XModem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof meshtastic.XModem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {meshtastic.XModem} XModem
         */
        XModem.fromObject = function fromObject(object) {
            if (object instanceof $root.meshtastic.XModem)
                return object;
            var message = new $root.meshtastic.XModem();
            switch (object.control) {
            default:
                if (typeof object.control === "number") {
                    message.control = object.control;
                    break;
                }
                break;
            case "NUL":
            case 0:
                message.control = 0;
                break;
            case "SOH":
            case 1:
                message.control = 1;
                break;
            case "STX":
            case 2:
                message.control = 2;
                break;
            case "EOT":
            case 4:
                message.control = 4;
                break;
            case "ACK":
            case 6:
                message.control = 6;
                break;
            case "NAK":
            case 21:
                message.control = 21;
                break;
            case "CAN":
            case 24:
                message.control = 24;
                break;
            case "CTRLZ":
            case 26:
                message.control = 26;
                break;
            }
            if (object.seq != null)
                message.seq = object.seq >>> 0;
            if (object.crc16 != null)
                message.crc16 = object.crc16 >>> 0;
            if (object.buffer != null)
                if (typeof object.buffer === "string")
                    $util.base64.decode(object.buffer, message.buffer = $util.newBuffer($util.base64.length(object.buffer)), 0);
                else if (object.buffer.length >= 0)
                    message.buffer = object.buffer;
            return message;
        };

        /**
         * Creates a plain object from a XModem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof meshtastic.XModem
         * @static
         * @param {meshtastic.XModem} message XModem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        XModem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.control = options.enums === String ? "NUL" : 0;
                object.seq = 0;
                object.crc16 = 0;
                if (options.bytes === String)
                    object.buffer = "";
                else {
                    object.buffer = [];
                    if (options.bytes !== Array)
                        object.buffer = $util.newBuffer(object.buffer);
                }
            }
            if (message.control != null && message.hasOwnProperty("control"))
                object.control = options.enums === String ? $root.meshtastic.XModem.Control[message.control] === undefined ? message.control : $root.meshtastic.XModem.Control[message.control] : message.control;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.crc16 != null && message.hasOwnProperty("crc16"))
                object.crc16 = message.crc16;
            if (message.buffer != null && message.hasOwnProperty("buffer"))
                object.buffer = options.bytes === String ? $util.base64.encode(message.buffer, 0, message.buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.buffer) : message.buffer;
            return object;
        };

        /**
         * Converts this XModem to JSON.
         * @function toJSON
         * @memberof meshtastic.XModem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        XModem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for XModem
         * @function getTypeUrl
         * @memberof meshtastic.XModem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        XModem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/meshtastic.XModem";
        };

        /**
         * Control enum.
         * @name meshtastic.XModem.Control
         * @enum {number}
         * @property {number} NUL=0 NUL value
         * @property {number} SOH=1 SOH value
         * @property {number} STX=2 STX value
         * @property {number} EOT=4 EOT value
         * @property {number} ACK=6 ACK value
         * @property {number} NAK=21 NAK value
         * @property {number} CAN=24 CAN value
         * @property {number} CTRLZ=26 CTRLZ value
         */
        XModem.Control = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NUL"] = 0;
            values[valuesById[1] = "SOH"] = 1;
            values[valuesById[2] = "STX"] = 2;
            values[valuesById[4] = "EOT"] = 4;
            values[valuesById[6] = "ACK"] = 6;
            values[valuesById[21] = "NAK"] = 21;
            values[valuesById[24] = "CAN"] = 24;
            values[valuesById[26] = "CTRLZ"] = 26;
            return values;
        })();

        return XModem;
    })();

    return meshtastic;
})();

module.exports = $root;
